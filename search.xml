<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[前端行业的你需要哪些网站]]></title>
      <url>%2F2017%2F05%2F11%2F%E5%89%8D%E7%AB%AF%E8%A1%8C%E4%B8%9A%E7%9A%84%E4%BD%A0%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E7%BD%91%E7%AB%99%2F</url>
      <content type="text"><![CDATA[除了肯定会逛的掘金、CSDN、知乎等技术论坛。 提高开发效率teambition是一个简单,高效的项目协作工具,你可以在这里管理项目,跟踪任务进度,存储项目文件,让你的团队协作更高效 tower功能与teambition差不多 Travis CI自动测试系统,CI意思为持续集成，Travis可以将你github上的项目自动编译，有人提交即可执行编译让你第一时间知道提交是否OK Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。具体介绍看官方文档 社交类领英全球最大的职业社交网站，是一家面向商业客户的社交网络（SNS） Github全球最大的男性交友平台，毫无疑问，不需要解释 美感与设计UI中国前身为 iconfans,是专业的 UI 设计师交流、学习与展示的平台。会员均为职业 UI 设计师,覆盖全国互联网公司。 Behance著名设计社区，在上面，创意设计人士可以展示自己的作品，发现别人分享的创意作品（上面有许多质量上乘的设计作品），相互还可以进行互动（评论、关注、站内短信等） 乐乎国内优质图片社交平台]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysql数据库基本使用]]></title>
      <url>%2F2017%2F05%2F10%2FMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[太久没有用命令行操作Mysql,今天有个项目想用下都不知道怎么用了，都是些最近本的东西，把这些坑记下来吧。 记得本地的Mysql数据库服务（当然下面要将的第一条是要求不能启动，我说的是正常操作的情况下，的启动Mysql服务才行），启动方法是，win+R代开运行窗口之后输入services.msc，打开服务功能视图，找到MySQL那个选项，将它启动就可以了。 忘记登录密码怎么办直接看这里吧，挺好的一个教程 教程中是还要进到mysql安装目录的bin文件夹下，运行mysql.exe，这是没有添加系统环境变量的缘故，把bin文件夹的目录路径添加到环境变量的path中就行，具体过程就不多说了，自己百度。添加了之后，就能在cmd的任意地方输入mysql登陆命令直接登陆mysql而不用一定得在bin目录下才可以。 教程最后还讲了绕过用户认证登陆后进行更改密码的操作，这也不失为一种更改密码的方法，不过更改完后必须重新启动数据库服务才能生效，记住是services.msc里面的数据库服务，而不是简单地把cmd窗口打开再关掉。 怎么登陆在命令窗口输入：mysql -u用户名 -p密码 这样就能登陆了，在此之前记得像最开始说的先启动mysql服务，另外注意-u和用户名之间没有空格，-p和密码之间也没有空格 查看mysql版本方法一命令窗口下：mysql –version 方法二登录mysql后输入：status;或者输入：select version(); 查看端口号登录mysql后输入：show global variables like ‘port’; 基本命令查看当前用户下的数据库show databases; 选中某个数据库（决定对某个数据库进行操作）use 数据库名; 查看数据库中都有什么表show tables;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github团队协作基础教程]]></title>
      <url>%2F2017%2F05%2F08%2FGithub%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[创建组织既然是团队项目，说明该项目是属于某个组织的，应该先建立一个组织，如下图： 进入组织的创建页面，填好组织名称和接收的消息的邮箱，这里我们将组织名称命名为TestWebTeam，选免费的方案，如果是真正的公司，则就会付费去创建一个组织，因为有些内容不能公开。点击create organization即完成组织的创建。（注意组织名称不能重复，接收邮箱必须添加） 点击创建后会进入成员邀请页 ，我们先直接点击finish跳过，只有再进行邀请。 这样组织就创建完成了。 创建小组组织就是现实意义上的组织，一个组织内部可以有很多个小组，他们之间可以共享一些仓库，拥有对不同仓库不同的控制权限，我们下面来创建一个小组，比如说这小组叫Designer，即设计小组。点击team,r然后点击create new team 进入小组创建页，填写小组名称Team name和小组描述Description,Team visibility是用户显示的内容，英语都看得懂就不说了，默认选第一个。然后点击create创建。 这就小组创建成功了，可以通过addmember来搜索github用户添加组员 创建和配置代码仓库权限组织有了，组织内部的开发小组也有了，需要的就是代码仓库了，一个组织可以有多个代码仓库，下面先创建一个，组织主页，点击创建新的仓库。（另外也可以像建个人仓库一样点击右上角的加号创建仓库，只是到时候将所属对象从个人改成目的组织就行了） 跟创建个人仓库没什么区别，只是owner变了，仓库名字命名为TestRepository 创建成功，点击setting给这个仓库指定哪些小组可以使用，并规定访问权限 中途会让你输入用户密码，输入就是了。然后左边选择Collaborators&amp;team、右边选择team，选择select team添加可以操作该仓库的小组。 添加完后，可以编辑该小组使用该仓库时的权限，三个权限，既然是想让小组来用这个代码仓库，则选择write即可，admin权限将使所有小组成员变成该项目管理员，可以随意编辑该仓库的设置，慎重选择。 下面的collaborators是添加该仓库的个人协作者（区别于小组），可自行扩展 为小组创建Pull Request组织通过Pull Request进行代码检查，当你对代码进行更改时可以邀请你的小组审核你的更改并提供反馈。下面来创建一个小的Pull Request，主要是对我们之前创建的代码仓库TestRepository的README文件进行更改。 移到最下面，添加主要提交的描述以及选择创建一个新的分支，因为我们要使用pull request，如果选第一个选项就直接合并到主分支去了 点击propose file change,进入open a pull prequest界面，这个页面是让你来更加详细的描述这次更改的原因，以及更改了什么地方，另外还可以用“@”来通知全体组员（就像QQ的@全体成员），让他们知道你的这次pull request 然后点击create pull request,这样小组的所有成员就都将知道你创建了一个pull request Pull Request的作用鉴于有些人可能不大清楚Pull Request的作用，下面来讲一下。 要打开一个pull request必须先拥有一个带有更改的分支，所以pull request适合团队工作，因为个人的话一般会一直工作在主分支上。 Pull Request用于提出对项目的更改，是一个开始提交讨论的方式，经常用于代码审查当中，如果是 一个人工作，则可能用Pull Request比较少，因为个人可以通过git命令推送更改到主分支中，并不 存在其他的分支，但如果在公司项目或者开源项目这种团队工作的情况下，就必须使用Pull Request了。 Pull Request是在开发者在创建一个区别于master的分支并进行相应的更改之后，想仓库管理者提出的将自己的分支（即更改内容）合并到主分支的一个请求，发出的这个请求可以被可访问这个仓库的所有人看见，并进行讨论，看是否合并、更改是否合理等等。即Pull Request用于对正在更改的代码仓库的讨论。 拿上面创建的pull request为例： 有三个视图，conversation视图用来讨论这次的更改 commit 提交视图包含了有关谁对这个文件进行更改的信息，每个提交都被记录到这个视图中，让我们知道提交前后发生了什么变化 files changed 文件更改视图，用来查看文件的更改记录。绿色表示已经添加的内容，红色表示内容被删除 那如何合并分支，对于公司，一般会有人来签署更改，但如果是个人在自己仓库的操作，则自己就可以进行合并操作，在coversation视图点击merge pull request就可以将这个提交合并到主分支了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现console.log不换行输出的方法]]></title>
      <url>%2F2017%2F05%2F06%2F%E5%AE%9E%E7%8E%B0console-log%E4%B8%8D%E6%8D%A2%E8%A1%8C%E8%BE%93%E5%87%BA%2F</url>
      <content type="text"><![CDATA[有点标题党的感觉，因为console.log()是无法实现不换行输出的，每执行一次console.log()都会自动占据一行。不过我们可以改变我们的输出思路。 用数组以及其方法：toString(),join(),reverse()来解决。 例子： 1234for(var i=0;i&lt;3;i++)&#123; console.log(i);&#125; 结果将是： 0 1 2 但我们想在一行内输出：0,1,2或者0–&gt;1–&gt;2或者2,1,0该怎么办？相信看来最开始我说的用数组及其方法的应该已经想到了。 先用一个数组把想输出的内容存储下来，之后再用相关的数组方法将其打印就可以了。 例子： 12345678910var A=[],k=0;for(var i=0;i&lt;3;i++)&#123; A[k]=i; k++;&#125;console.log(A.toString());console.log(A.reverse().join('--&gt;')); 很明显，结果将是： 0,1,2 2–&gt;1–&gt;0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js实现简单排序算法]]></title>
      <url>%2F2017%2F04%2F29%2FJs%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[这里用JavaScript实现冒泡排序、选择排序、插入排序、归并排序以及快速排序这些基本的排序算法 首先我们给本文约定一个实现的框架：定义一个ArrayList类里面包含排序数组声明、数组元素添加、排序算法实现以及数组输出的方法。 代码框架： 123456789101112131415161718192021222324function ArrayList()&#123; var array=[]; this.inputArraymember=function()&#123; //将10个大小在1~15的随机数添加到数组中 var ins=0; for(var i=0;i&lt;10;i++)&#123; ins=Math.floor(Math.random()*15+1); array.push(ins); &#125; &#125;; this.相应的排序算法=function()&#123;...算法的具体实现代码...&#125;; //代码块替换部分 this.toString=function(separator)&#123; //将数组按指定分隔符生成字符串方便输出 return array.join(separator); &#125;;&#125;var a = new ArrayList();a.inputArraymember();console.log("随机生成的原始数组为："+a.toString('-'));a.bubbleSort();console.log("排序后数组为："+a.toString('-')); 冒泡排序用两层循环，第一层用来记录剩余的还未排序的数的个数，第二层用来在剩下的未排序的数中找到最大的数并将其放到未排序数的最后面（冒泡）。 代码实现： 12345678910this.bubbleSort=function()&#123; var length=array.length; for(var i=0;i&lt;length;i++)&#123; for(var j=0;j&lt;length-1-i;j++)&#123; if(array[j]&gt;array[j+1])&#123; var t=array[j]; array[j]=array[j+1];array[j+1]=t; &#125; &#125; &#125;&#125;; 冒泡排序的时间复杂度是O(n&sup2;)。将以上代码替换文章开始约定的代码框架中的“代码块替换部分”即可用于在调试工具中运行查看代码运行结果。 选择排序思路很简单，每次都找出未排序的数当中最小的数并放在开头，直到所有数的位置确定下来。说清楚点就是从所有序列中先找到最小的，然后放到第一个位置。之后再看剩余元素中最小的，放到第二个位置……以此类推。 代码实现： 1234567891011121314151617this.selectsort=function()&#123; var length=array.length,currentMin; for(var i=0;i&lt;length-1;i++)&#123; //每循环一趟就会有一个数得到排序 currentMin=i; //用来记录最小数的下标，默认为最开始的未排序的元素下标 for(var j=i;j&lt;length;j++)&#123; if(array[currentMin]&gt;array[j])&#123; currentMin=j; &#125; &#125; if(i!==currentMin)&#123; //若下标不是未排序的最开始的那个元素的下标，则将两者的值交换 var t=array[currentMin]; array[currentMin]=array[i]; array[i]=t; &#125; &#125;&#125;; 可看出，选择排序也用了两个嵌套着的循环，所以时间复杂度也是O(n&sup2;)，是一种原址排序。 插入排序从第二个数开始（因为第一个数只有一个，前面没得比。），与前面的数挨个比较，直到找到前一个数比当前值小，后一个数比当前值大的位置，让后将当前值置于此处，以此类推。 代码实现： 12345678910111213this.insertsort=function()&#123; var length=array.length, j,temp; for(var i=1;i&lt;length;i++)&#123; j=i; temp=array[i]; //先存储待比较的数 while(j&gt;0&amp;&amp;array[j-1]&gt;temp)&#123; //如果这个数比上一个数小，则让上一个数占据现在这个数的位置（右移每个比当前数小的数） array[j]=array[j-1]; j-- &#125; array[j]=temp; //直到这个数不比上一个数小的时候，将这个数放在当前的位置 &#125;&#125;; 归并排序时间复杂度为O(nlogn)。归并用的是分治的思想，将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着讲小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142 this.mergeSort=function() &#123; array = mergeSortRec(array); &#125;;//建堆函数，将数组一直拆分成两部分，直到各部分数组长度都为1的时候停止，然后进行merge操作 var mergeSortRec = function(array)&#123; var length = array.length; if (length === 1) &#123; return array; &#125; var mid = Math.floor(length / 2), left = array.slice(0, mid),//slice() 方法可从已有的数组中返回选定的元素,语法 arrayObject.slice(start,end) right = array.slice(mid, length); return merge(mergeSortRec(left), mergeSortRec(right)); &#125;;//将各部分进行归并 var merge = function(left, right) &#123; var result = [], il = 0, ir = 0; while(il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; if (left[il] &lt; right[ir]) &#123; result.push(left[il++]); &#125; else &#123; result.push(right[ir++]); &#125; &#125; //如果il数组还有剩余，则将其剩余部分添加到结果数组中 while (il &lt; left.length) &#123; result.push(left[il++]); &#125; //如果ir数组还有剩余，则将其剩余部分添加到结果数组中 while (ir &lt; right.length) &#123; result.push(right[ir++]); &#125; return result; &#125;; 快速排序时间复杂度为O(logn)。用的是分治的思想。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 this.quickSort = function()&#123; quick(array, 0, array.length - 1); &#125;; var partition = function(array, left, right) &#123; //划分过程//主元的选择方法最好是随机选择一个数组想或是选择中间项，这里选择中间项 var pivot = array[Math.floor((right + left) / 2)], i = left, j = right; console.log('pivot is ' + pivot + '; left is ' + left + '; right is ' + right); while (i &lt;= j) &#123; while (array[i] &lt; pivot) &#123; i++; console.log('i = ' + i); &#125; while (array[j] &gt; pivot) &#123; j--; console.log('j = ' + j); &#125; if (i &lt;= j) &#123; console.log('swap ' + array[i] + ' with ' + array[j]); swapQuickStort(array, i, j); i++; j--; &#125; &#125; return i; &#125;; var swapQuickStort = function(array, index1, index2)&#123; var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux; &#125;; var quick = function(array, left, right)&#123;//将子数组分离为较小值数组和较大值数组 var index; if (array.length &gt; 1) &#123; index = partition(array, left, right); if (left &lt; index - 1) &#123; quick(array, left, index - 1); &#125; if (index &lt; right) &#123; quick(array, index, right); &#125; &#125; return array; &#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript数组介绍]]></title>
      <url>%2F2017%2F04%2F27%2FJavaScript%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[JavaScript的数组中的元素可以具有不同的类型，即var a=[&#39;hello&#39;,12,&#39;kk&#39;];是合法的。 对于一维数组，可直接用console.log(数组名)来输出数组内容，若是多维数组则需要自行构建函数来输出 创建和初始化数组123456var everyday=new Array();var everyday=new Array();var everyday=new Array('hello','world',123,'china');var evaryday=[];var evaryday=['hello','world',123,'china']; 可使用everyday.length来获得数组的长度 添加和删除数组元素添加到数组末尾123everyday[everyday.length]='新元素';或everyday.push('新元素1','新元素2'); 添加到数组首部1eveday.unshit('新元素1','新元素2'); 删除最靠后元素1everyday.pop(); 用push()和pop()可以用数组来模拟栈 删除第一个元素1everyday.shift(); 用shift()和unshift()可以用数组模拟队列 删除任意位置的元素1everyday.splice(2,3); 注解：表示删除了从下标2的元素开始往后的两个元素（包括下标为2的），即everyday[2]、everyday[3]、everyday[4]。 插入任意为位置 任意值1everyday.splice(2,0,5,3,6) 注释：这才是splice()函数的完整用法。第一个参数是要执行删除操作的开始下标，第二个是要删除的个数，咱现在目的是为了添加，所以写0，第三个参数及以后则是要新添加的元素，此例执行后everyday[2]值变成5，以此类推。 二维和多维数组JavaScript只支持一维数组，但由于JavaScript数组对元素类型的宽容性，我们可以采用数组套数组的方法来实现多维数组。 12345678var a1=[];a1[0]=['hello',23,'world'];a1[2]=['china','england'];或var a2=[];a2[0]=[];a2[0][0]='hello';a2[0][1]='woeld'; 此时用console.log(a2)将不能输出数组内容，因为console.log()之只能用来输出具体的元素，应该自行创建一个函数来简化输出 123456789function printfMatrix(myMatrix)&#123;for(var i=0;i&lt;myMatrix.length;i++)&#123; for(var j=0;j&lt;myMatrix[i].length;j++)&#123; console.log(myMatrix[i][j]); &#125; &#125;&#125;printfMatrix(数组名); 操作数组的方法（函数）数组合并–concat方法 按照指定的顺序连接起来，很好理解 迭代器函数every方法every会迭代数组中的每一个元素，直到返回false 注释：给每个元素迭代执行zhengshu这个方法（是小于0则继续迭代，直到遇到正数，返回false） some方法every会迭代数组中的每一个元素，直到返回true 注释：给每个元素迭代执行zhengshu这个方法（是大于0则继续迭代，直达遇到负数，返回true） forEach方法foreach会迭代整个数组的元素 map方法map会生成一个数组，用来保存迭代所有元素时产生的结果 filter方法filter会生成一个新数组，用来保存迭代所有元素时时函数返回true的元素 reduce方法reduce接收一个函数作为参数，这个函数有四个参数：prevousValue、currentValue、index和array。这个函数会返回一个将被叠加到累加器的值，reduce方法停止执行后返回这个累加器。如果要对一个数组中的所有元素求和，这就很有用。 搜索和排序数组反序–reverse方法就是将原本数组元素的排列顺序颠倒 数组自动排序–sort方法sort在排序的时候，是默认把元素当成字符串来比较。比如底下这样用就会出错： 那应该怎么办？ 自己写比较函数 123var a=[2,6,18,19,1];console.log(a.sort(function(a,b)&#123;return a-b;&#125;)); 主要的是代码a.sort(function(a,b){return a-b;})，此代码表示当a小于b时返回负数，当a大于b时返回正数，相等时放回0，这样sort方法就会根据返回值的情况给数组排序，当然这行代码额可以改写成比较好理解的以下以下代码： 注意比较函数的调用方法（没有传参） 自定义排序可以创建任何对象类型的数组排序，也可以创建compareFunction来比较元素： 12345678910111213var person=[&#123;name:'小明',age:15&#125;,&#123;name:'小王',age:14&#125;,&#123;name:'小东',age:18&#125;];function comparePerson(a,b)&#123; if(a.age&lt;b.age)&#123; return -1; &#125; if(a.age&gt;b.age)&#123; return 1; &#125; return 0;&#125;console.log(person.sort(comparePerson)); 结果: 字符串排序对于字符创的比较，sort是根据ASCII值来比较的，比如： 即Jmn会排在apple的前面，如果我们想让它排序正确，则需要自己写一个忽略大小写的比较函数： 搜索 indexOf()方法：返回与参数匹配的第一个元素的索引 lastIndexOf()方法：返回与参数匹配的最后一个元素的索引。 例子： 结果分析，前两个没什么好说的，第三个查找10，因为没有这个元素，所以返回-1 输出数组为字符串及指定分隔符 toString()将数组里的所有元素输出为一个字符串 join()用一个不同的分隔符把元素隔开 例子：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 Canvas入门]]></title>
      <url>%2F2017%2F04%2F26%2FHTML5-Canvas%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Canvas元素本身没有绘图能力，所有的绘图工作必须在JavaScript内部完成。拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 直接上代码。 绘制2d线条 先在html页面下添加Canvas元素。设定画布的id和宽高。 1&lt;canvas id="myCanvas" width="200" height="100" style="border:1px solid #000;"&gt;&lt;/canvas&gt; 用JavaScript在画布上面绘制图像 123456789 // 获得画布 var c=document.getElementById("huabu"); // 创建基于所获得画布的2d画笔 var pan= c.getContext("2d"); pan.moveTo(10,10);//移动画笔 pan.lineTo(40,40);//从源点绘制到指定点（30,40）pan.lineTo(50,100);//从源点绘制到指定点（50,100） pan.lineTo(150,20); pan.stroke();//之前是在构建，这里是把构思正式画到画布上，一定要这一步 结果 注意 如果想绘制两条线，不能想当然的moveTo(),然后再lineTo()，应该再声明一支画笔 12345var pan2= c.getContext("2d"); pan2.moveTo(40,10);pan2.lineTo(30,60); pan2.lineTo(188,170); pan2.stroke(); 结果：（绘制两条线） 绘制圆形 先在html页面下添加Canvas元素。设定画布的id和宽高。 1&lt;canvas id="myCanvas" width="200" height="100" style="border:1px solid #000;"&gt;&lt;/canvas&gt; 用JavaScript在画布上面绘制图像 12345678910111213 //获得画布var c=document.getElementById("huabu");var pan= c.getContext("2d");//设置图形填充的颜色pan.fillStyle='#00f';//开始绘制图形pan.beginPath();//arc是圆的英文前几个字母//括号内指定（圆心x轴坐标、圆心y轴坐标、圆半径、开始角度、结束角度、顺时针(false)还是逆时针(true)）pan.arc(100,100,50,0,Math.PI/2,true);//结束绘图pan.closePath();pan.fill();//一定要有，将构建好的图形正式填充到画布上去 学习以下代码 获得2d画笔后，用beginPath()方法绘制新路径 用strokeStyle指定路径颜色 arc()设置圆的属性 stroke()绘制弧线 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;HTML5 Canvas绘制弧线入门示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 添加canvas标签，并加上红色边框以便于在页面上查看 --&gt;&lt;canvas id="myCanvas" width="400px" height="300px" style="border: 1px solid red;"&gt;您的浏览器不支持canvas标签。&lt;/canvas&gt;&lt;script type="text/javascript"&gt;//获取Canvas对象(画布)var canvas = document.getElementById("myCanvas");//简单地检测当前浏览器是否支持Canvas对象，以免在一些不支持html5的浏览器中提示语法错误if(canvas.getContext)&#123; //获取对应的CanvasRenderingContext2D对象(画笔) var ctx = canvas.getContext("2d"); //开始一个新的绘制路径 ctx.beginPath(); //设置弧线的颜色为蓝色 ctx.strokeStyle = "blue"; var circle = &#123; x : 100, //圆心的x轴坐标值 y : 100, //圆心的y轴坐标值 r : 50 //圆的半径 &#125;; //沿着坐标点(100,100)为圆心、半径为50px的圆的顺时针方向绘制弧线 ctx.arc(circle.x, circle.y, circle.r, 0, Math.PI / 2, false); //按照指定的路径绘制弧线 ctx.stroke();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 给画布添加图像1234567891011&lt;script type="text/javascript"&gt;var c=document.getElementById("myCanvas");var cxt=c.getContext("2d");var img=new Image()img.src="image.png"//drawImage(图像元素，左上角顶点x轴坐标，左上角顶点y轴坐标)cxt.drawImage(img,0,0);&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS动画入门]]></title>
      <url>%2F2017%2F04%2F26%2FCSS%E5%8A%A8%E7%94%BB%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[css3常用动画+动画库 transitionCSS过渡 介绍俗称“过渡”，是指某元素从一种样式逐渐转变为另一种样式的过程。即用于转换元素两个不同的状态，这个转换过程（或者说触发过程）可以是伪类比如:hover, :active 或者是通过 javascript 动态设定。IE10+支持 transitionz是简写，主要包含的是一下属性。 用法必须规定了两个属性 要添加过渡效果的属性 效果转换的持续时间 多个属性转换用逗号隔开 例子12345678910111213141516171819&lt;!--HTML--&gt; &lt;div id="zi"&gt;&lt;/div&gt;&lt;!--CSS--&gt;#zi&#123; height:100px; width: 100px; background-color: yellow; transition: width 2s,height 2s,color 2s;&lt;!--不同属性效果用逗号隔开--&gt; -webkit-transition: width 2s,height 2s,background-color 2s;-o-transition: width 2s,height 2s,background-color 2s; -moz-transition: width 2s,height 2s,background-color 2s;&#125;#zi:hover&#123; background-color: red; height: 150px; width: 200px;&#125; animationCSS动画 介绍animation属性结合@keyframes规则,能创建由当前样式逐渐改为新样式的动画效果。Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。 用法@keyframes创建动画并制定动画的名字（随便起，主要是用来给animation选择），animation中选择相应的动画名字来使用对应的动画，还要设置动画执行的持续时间，还可设置所选动画的执行方式。即： @keyframes 用于创建动画 用法： 规定动画名，内容为from某种样式to某种样式，还要设置不同浏览器的前缀。也可以不用from-to而是直接用百分比来划分时间，进而规定特定时间内的动画样式。 “from” 和 “to”，等同于 0% 和 100%，0% 是动画的开始，100% 是动画的完成 例1： 例2： animation 用于选择动画并规定动画的执行方式 用法： 必须固定的有动画名称和动画时长 另外还可以添加其他规定项： 例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:100px;height:100px;background:red;position:relative;animation-name:myfirst;animation-duration:5s;animation-timing-function:linear;/*表示变换速度，linear表示从头到尾匀速*/animation-delay:2s;animation-iteration-count:infinite;/*表示动画无限次循环，可改为常数来规定执行次数*/animation-direction:alternate;animation-play-state:running;/* Firefox: */-moz-animation-name:myfirst;-moz-animation-duration:5s;-moz-animation-timing-function:linear;-moz-animation-delay:2s;-moz-animation-iteration-count:infinite;-moz-animation-direction:alternate;-moz-animation-play-state:running;/* Safari and Chrome: */-webkit-animation-name:myfirst;-webkit-animation-duration:5s;-webkit-animation-timing-function:linear;-webkit-animation-delay:2s;-webkit-animation-iteration-count:infinite;-webkit-animation-direction:alternate;-webkit-animation-play-state:running;/* Opera: */-o-animation-name:myfirst;-o-animation-duration:5s;-o-animation-timing-function:linear;-o-animation-delay:2s;-o-animation-iteration-count:infinite;-o-animation-direction:alternate;-o-animation-play-state:running;&#125;@keyframes myfirst&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 也可以将animation简写成： animation：动画名称 持续时间 执行速度变化 动画延迟 循环次数 是否下一周期逆向播放 div { width:100px; height:100px; background:red; position:relative; animation:myfirst 5s linear 2s infinite alternate; /* Firefox: */ -moz-animation:myfirst 5s linear 2s infinite alternate; /* Safari and Chrome: */ -webkit-animation:myfirst 5s linear 2s infinite alternate; /* Opera: */ -o-animation:myfirst 5s linear 2s infinite alternate; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Powershell基本命令]]></title>
      <url>%2F2017%2F04%2F26%2FPowershell%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[Powershell是微软在cmd基础上改进后推出的励志于提高用户开发体验的命令行程序，可以这么说，cmd有的Powershell全都有，Powershell有的cmd不全有，而且Powershell还比cmd漂亮，为什么不用呢。稍微讲下Powershell的基本命令。 Powershell用的时候会出现中文乱码，用以下命令把Encoding改成UTF8即可：$OutputEncoding = New-Object -typename System.Text.UTF8Encoding 注意命令中的空格,。以下命令均默认在要进行操作的文件夹下进行，如果不是在要操作的文件目录下，请自行在操作项目前添加文件路径。 创建文件夹mkdir Folder 创建文件dir &gt; a.txt 向文件内写入内容echo 内容 &gt; a.txt 这种方法会覆盖掉文件原有内容，如果是追加，应用： echo 内容 &gt;&gt; c.txt 这种方法，每次写入内容后面都会自动换行 图形化编辑txt文件notepad a.txt 这会直接以记事本的形式打开指定的文件 读取文件内容cat a.txt 此命令只能在操作当前目录的文件时可用 type a.txt 此命令可跨目录使用，即可添加路径 打开doc文件路径没错的情况下，直接输入文件名，然后回车，即可用相应的软件将其打开 指定用某软件打开某文件 将要使用的软件的exe文件所在的目录添加到系统环境变量里面 之后就可以用该软件打开想要打开的文件了 软件名或软件名.exe 文件名.文件后缀 删除文件del a.txt 删除文件夹del 文件夹 重命名文件ren a.txt b.txt 将文件a,txt重命名为b.txt 重命名文件夹ren 文件夹名1 文件夹名2 将文件夹名1改为文件夹名2 复制文件copy b.txt 文件夹1 将当前文件夹下的b.txt文件拷贝到当前文件夹下的文件夹1里面，其他操作可自行添加路径解决。 复制文件夹和剪切操作之后再做补充查看文件夹的目录结构 tree 可以查看当前目录及以下各级的目录结构，但是查看不了文件 tree /f可以查看对当前目录及以下各级的目录结构以及相应的文件 tree /f &gt;123.txt将查询到的文件目录结构保存在123.txt（新建）文件中 关闭某个软件 taskkill /im 软件名.exe 先输入tasklist 获取改进程的PID，假设PID号为3502， 再输入 taskkill /f /pid 3502]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js相等操作符]]></title>
      <url>%2F2017%2F04%2F25%2FJs%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[对于有其他编程语言编程经验的人来说，在判断两个值是否相等时，会用“==”，但是此方法用于Js，特别是用Webstorm等前端IDE编写Js程序时，会发现此方法会报错，并提示应该更改为“===”，这到底是怎么回事，下面我们就来区别一下Js这两个相等操作符——“==”和“===” 总的一句：==不管类型相不相同，只要进行转化后条件符合（具体怎么转化请往下看），就会判定为相等；===必须比较的两个值类型和值相等时才相等，即===要比==严格。 “===”先说简单的，===。 用于比较的两个值，类型不相等则不相等，类型相等且值相等，则相等。 例子例一： 12console.log('test'===true); //结果为：false，以为类型不相等，一个字符串一个布尔值console.log('test'==='test'); //结果为：true，因为类型相等且值相等 值得注意的一点是，关于对象，就算是分别定义的两个对象的内容一样，用’===’进行比较也是不相等的，因为存储的位置不同，除非是用引用的方式将一个对象的值赋给另一个对象，这才返回true。（什么是对象的引用可以看这篇文章：对象引用问题上Java和Js是相通的–Java入门） 例二： 123456789var person1=&#123;a:'xiao'&#125;;var person2=&#123;a:'xiao'&#125;;console.log(person1===person2);//结果为：false，因为person1和person2的存储位置不一样，所以是不同的对象var person1=&#123;a:'xiao'&#125;;var person2=person1;console.log(person1===person2);//结果为：true，因为person2是对person1的引用，它们指向的是用一个内存块，所以相等 “==”使用==时，不同类型的值也可以被看做相等，不过Js会对其进行一定的转化后再惊醒比较，下面来看看如果对不同类型的值使用“==”进行比较，Js会进行怎样的转化： 若x和y类型相同，Js会比较它们的值或者对向值。如果不同，则按上面的形式进行转化后再比较。其他没有列在表格中的情况都会返回false。 toNumber和toPrimitive的转化结果toNumber toPrimitive 例子例一： 1console.log('test'?true:false);//结果为:true 原因：这里是判断test字符串变成布尔值后是什么，因为字符串的长度大于一。这里涉及到Js中true和false的问题，稍微说下Js中true和false是怎么转换的： 例二： 1console.log('test'==true); //结果为：false 原因：进行比较的时候，布尔值true被toNumber变成数字1；而字符串test则被toNumber转换成NaN，进而表达式转换成判断NaN==1，结果自然为false。 例三： 1console.log('test'==false); //结果为：false 原因：同例二一样的道理，结果表达式被转换成判断NaN==0,结果仍然为false。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[远方]]></title>
      <url>%2F2017%2F04%2F23%2F%E8%BF%9C%E6%96%B9%2F</url>
      <content type="text"><![CDATA[“当你发现日子特别艰难的时候 可能这次的收获特别巨大”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github Pages托管静态页面]]></title>
      <url>%2F2017%2F04%2F22%2FGithub-Pages%E6%89%98%E7%AE%A1%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[什么是 Github Pages？ Github Pages 是 Github 的静态页面托管服务。它设计的初衷是为了用户能够直接通过 Github仓库来托管用户个人、组织或是项目的专属页面。 我们可以利用 Github 的静态页面托管服务 Github Pages 来帮助我们做页面展示。见得最多的就是把它拿来托管自己的博客，当然博客是静态的，不过，不止博客，我们github账户上的所有仓库只要把Github Pages的功能代开，就都能拥有自己的展示主页。 托管博客github提供的博客托管仓库只有一个，那就是username.github.io，下面说一下具体怎么弄： 创建一个名为username.github.io的仓库，其中username是你的github用户名，其他的默认即可 进入username.github.io这个仓库，点击setting选项进行设置 本地git关联和上传到这个仓库的步骤我就不说了，也就是git init、git add、git commit、git remote add origin https://仓库地址、git push origin master这些基本步骤，相信能来看这个的对git的基本操作都已经掌握了。 进入到setting里面，左边学则Options这一栏,右边滑到GitHub Pages那一栏，将Source的Node改成你放博客文件的分支名字，一般是直接用master分支，然后Save Theme chooser那一个选项是给你的这个主页设置显示的主题的，咱们是自己创建的博客不需要它的东西，直接跳过就行了 此时访问在浏览器搜索框输入username.github.io其实已经可以访问，只是会提示404，因为咱们没有放页面 此时只要上传本地的博客文件到这个仓库就可以了 注意：博客的首页必须命名为index.html且放在这个仓库的最外面，不能放在某某文件夹里面，不然访问username.github.io还是会找不到页面 上面的工作都做完后，就能通过输入username.github.io(记住，这里提到的username都得改成自己的用户名)访问自己托管的静态博客了 如果不喜欢github提供的这个username.github.io域名怎么办，也可以绑定到自己注册的域名，详情请看我的这篇博客：挂载Hexo主题的Github绑定自己的域名,博主用的是Hexo的Next主题，不过不影响，操作都差不多 到服务商购买域名 username.github.io仓库添加最外面添加一个CNAME文件，里面写上自己购买的域名 解析购买的域名到github的域名和IP地址，等待一会儿就能通过自己的域名访问了 生成项目的展示主页这才是Github Pages这功能开放的真正目的，为的是让托管在github上的仓库都能有直接进行展示的机会 步骤跟托管博客的步骤一样，随便一个仓库，Setting-&gt;Options-&gt;GitHub Pages-&gt;Source-&gt;分支名这样就成功了，通过http://博客域名/仓库名，就可也访问了，同样该仓库需要一个放在最外面的index.html页面来做首页 Github Pages的限制好东西还是有限制的： 仓库存储的所有文件不能超过 1 GB 页面的带宽限制是低于每月 100 GB 或是每月 100,000 次请求。 每小时最多只能部署 10 个静态网站。不够对于托管个博客应该是绰绰有余了，如果真的不小心超了，Github 那边不会采取什么强制措施，而是会发一份邮件提醒你应该找一个更适合你的托管对象的服务。 至于仓库的存储的文件大小限度是各个仓库的总和还是自己有自己的1GB，这我没研究过，毕竟Github还没给我发过提醒邮件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[“百花齐放”的前端时代]]></title>
      <url>%2F2017%2F04%2F21%2F%E2%80%9C%E7%99%BE%E8%8A%B1%E9%BD%90%E6%94%BE%E2%80%9D%E7%9A%84%E5%89%8D%E7%AB%AF%E6%97%B6%E4%BB%A3%2F</url>
      <content type="text"><![CDATA[笼统的前端 现在前端领域各种框架、库并行，新技术层出不穷，暂且称它为“繁荣”吧。 对一个刚刚走进这个江湖的菜鸟来说，jQuery、Angular、React、Vue、Bootstrap、Node这些经常在各大公司招聘要求以及各大前端论坛信息中的看到词到底是什么，有什么作用，一会儿框架，一会儿库的，还有MVC、MVVM以及npm、gulp、webpack等，就像各大帮派一样，搞得人一头雾水。 链接 我眼中的前端框架jQuery，Angular，React，Vue——以及我看前端架构 浅析angular，react，vue.js，jQuery使用区别 Gulp和webpack的区别，是一种工具吗？ nodejs+gulp+webpack基础实战篇 各路英雄的见解关于框架 前端框架天下三分：Angular、React 和 Vue 按照时代出场顺序排序：jQuery、Angular、React、Vue jQuery肯定要学的，Angular、React 和 Vue三个先学一个，三个都是比较类似的 React，Angular,Vue三个也是没有关联相互独立的框架。使用这三个框架搭建的网站主要特点就是动态刷新，路由控制不通过后端，全是JS完成，每次跳转页面都是动态替换index.html页面root节点的内容 Angular、React、Vue是Js框架，本身都是用js原生写的，就是别人把一些js的代码封装了，你调用之后就能用别人写好的方法，会方便很多，也被局限在别人的框架内部了 Bootstrap是UI框架 vue是国人弄出来的，官方文档都是中文，学起来比较不麻烦 分清楚 库，框架，构建工具、 插件的作用 需要引用或者调用，就可以直接用，并不会对你做太多约束。那么这种大部分都称之为库。如jQuery 需要按照他的标准构建文件结构或者文件夹结构或者代码书写方式那么这东西可以称之为框架，一般框架都是多种组合在一起的，如React+gulp 或者 jQuery mobile 解决开发过程中重复或者需要自动化智能化完成事情，也就是构建工具，如grunt和gulp 基于 库，框架，工具，提供的补充优化的模块就叫做插件 关于工具 gulp是工具链、构建工具，可以配合各种插件做js压缩，css压缩，less编译 替代手工实现自动化工作 webpack是文件打包工具，可以把项目的各种js文、css文件等打包合并成一个或多个文件，主要用于模块化方案，预编译模块的方案 关于node一个让我笑半天的回答 node到底是什么？ 让Js也可以做后端 Node.js 通过用单线程取代多线程，事件驱动 I/O 来解决了高并发，取代了 Java 平台的标准]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[定义和声明的区别]]></title>
      <url>%2F2017%2F04%2F20%2F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[声明就是指给除了当前变量或者函数，或者类什么的名字，不给其中的内容，就是先告诉你有这样一个什么类型的变量或者函数，但是这个变量或者函数的具体信息却是不知道的。就好比跟你介绍一个人的时候，声明就是只告诉你这个人叫什么，但是缺不给你说这个人到底怎么样，他有哪些优点，缺点，喜好问题是什么的 定义就不一样了，定义直接告诉你了所有的东西，这个变量是什么，这个函数是什么功能，这个类里面包含了什么东西。很具体的说明 当然一般对于变量来说，我们不怎么区分声明或者定义之类的，一般没有人去说我要声明一个变量，然后定义这个变量什么的。要说都是直接说定义变量 声明一般都是对函数或者类来说的，声明在前，定义在后 int a;可以说是声明，广泛的说是定义一个变量a，也不算错 例子：123456789int a; //等价于 声明一个人：小张int a = 3; //等价于 定义一个人 ：小张 年龄为三岁。//定义是带有初始化的//函数的声明和定义void My(); // 这个是声明//这个是定义void My()&#123;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[挂载Hexo主题的Github绑定自己的域名]]></title>
      <url>%2F2017%2F04%2F19%2F%E6%8C%82%E8%BD%BDHexo%E4%B8%BB%E9%A2%98%E7%9A%84Github%E7%BB%91%E5%AE%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%2F</url>
      <content type="text"><![CDATA[用的Hexo的博客框架，本地生成并托管到github上之后，通过“username.github.io”便能访问自己的博客了，但是如何将url改成自己想要的域名，需要如下一些步骤。 到域名提供商那注册自己想要的域名，国内比较大的有阿里云、百度云等等、国外有godaddy、bluehost等，bluehost还支持支付宝，还不错，其实一个域名也不用纠结太多，毕竟域名不管在国内还是国外买的，只要服务器是国外的就不用走中国内地的备案套路，比如本篇文章讲的博客在github上就不用担心什么备案，不过要注意的是如果买的是.cn这种中国域名，就需要购买人提供身份证电子照片进行验证，政府部门通过后才能用。 到github的username.github.io目录下，创建新文件CNAME（一定要大写，而且不加任何后缀）,其中包含你注册的域名，注意要填的是顶级域名，比如roderic.cn 第二步是告诉github你要将该博客地址转到你CNAME文件中指定的域名。现在到你购买域名的服务商那为你购买的域名添加三条解析记录，如下： 前两条记录是指定该域名跳转的IP（github pages的，固定的，照抄，不用管）地址，第三条是指定该域名跳转到username.github.io（注意这里的username都得用你github的用户名替换） 这样经过短时间的等待，你就可以用你注册的域名访问你的博客了，当然此时用username。github.io也还是能访问博客的。 本例讲的是Hexo的博客框架，都知道Hexo每次都要重新生成静态文件再上传，这样每次CNAME都得重新创建很麻烦，解决方法是把CNAME文件放在source文件夹下，这样生成静态文件的时候，就会自动添加CNAME这个文件了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java入门（三）]]></title>
      <url>%2F2017%2F04%2F17%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[有关读取用户输入的问题首先导入包import java.util.Scanner;这里面有处理用户输入的方法。 输入数字情况123456789101112public static void main(String[] args) &#123; //创建输入对象 Scanner sc=new Scanner(System.in); //获取用户输入的数字 System.out.print("请输入任意数字:"); int str=sc.nextInt(); //用来获取数字 System.out.println("你输入的数字为:"+str); &#125; 输入字符串12345678910111213public static void main(String[] args) &#123; //创建输入对象 Scanner sc=new Scanner(System.in); //获取用户输入的字符串 String str=null; System.out.print("请输入任意字符:"); str=sc.nextLine(); //用来获取字符串 System.out.println("你输入的字符为:"+str); &#125; 若要输入字符数组思路：先用输入字符串的方法读入字符串，然后再将其转换为字符数组 注经过测试，一个输入对象只能接受一种数据类型，要想输入不同的数据对象，就得现创建不同的输入对象1234567Scanner in1=new Scanner(System.in); //接受数字输入int x1=in1.nextInt(); int x2=in1.nextInt(); //同种类型不必再new输入对象Scanner sc2=new Scanner(System.in); //接受字符串输入，不同类型得创新new输入对象，而且不同名String str=sc2.nextLine(); String str=sc2.nextLine();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java入门（二）]]></title>
      <url>%2F2017%2F04%2F15%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[注： 同一个包下，不同java文件中的类名不能相同，因为同一包下，不同java文件中的类是可以相互继承的！ 不同java类文件中的内部类（一个类中还包含着另外一个类）可以同名，但是同一文件下的public或者是默认范围的java类是不可以同名的。 当类中方法的访问权限修饰符为private时，该方法只能被自己的类访问，不能被外部的类访问 初始化时，若没有赋值则为默认值，具体时：数字为0、对象为null、布尔值为false、字符值为’\0’ 对象的引用 引用是一个地址，它指明了对象的变量和方法的存储位置 将对象赋给变量或将其作为参数传递给方法时，实际上并没有使用对象，甚至没有使用对象的拷贝，使用的是对象的引用 例子：123456789101112131415package Mypackage;import java.awt.Point;class RefTester&#123;public static void main(String[] args)&#123; Point pt1,pt2; pt1=new Point(100,100); pt2=pt1; pt1.x=200; pt1.y=200; System.out.println("Point1:"+pt1.x+","+pt1.y); System.out.println("Point2:"+pt2.x+","+pt2.y);&#125;&#125; 执行结果： 可以发现，pt2的值也被改变了，这是pt2=pt1是让pt2引用pt1，而不是将pt1的拷贝纸给pt2，pt1和pt2现在是指向同一个对象 如果改成：12pt1=new Point(100,100);pt2=new Point(100,100); 结果就将是： 注：(不想重写代码，假设pt1和pt2现在是String类型) 若pt2=pt1，此时用“==”来判断pt1和pt2是否相等，得到的结果是“true”,因为指向同一个对象，用“pt2.equals(pt1)”得到的结果也将是“true”，因为两个字符串值相同 若pt1=new Point(100,100);pt2=new Point(100,100);，此时用“==”来判断pt1和pt2是否相等，得到的结果是“false”,因为它们现在在内存中不是同一个对象，用“pt2.equals(pt1)”得到的结果也将是“true”，因为两个字符串值相同 方法重写与方法重载方法重写 子类可以定义新的特征，当子类需要修改父类的一些方法进行扩展，增大功能，程序设计者常常把这样的一种操作方法称为重写，也叫称为覆写或覆盖，重写是建立在继承关系上 所谓方法的重写是指子类中的方法与父类中继承的方法有完全相同的返回值类型、方法名、参数个数以及参数类型。这样，就可以实现对父类方法的覆盖 例子： 1234567891011121314151617class Person//定义父类&#123;public void print()&#123;//父类中的方法System.out.println( 父类Person的print方法! );&#125;&#125;class Student extends Person//定义子类继承Person类&#123;public void print()&#123;//方法的重写System.out.println( 子类Student的print方法! );&#125;&#125;public class 0verrideExampleO1&#123;public static void main(String args[])&#123;Student s=new Student();S.print();&#125;&#125; 运行结果：子类Student的print方法! 可见当子类重写了父类中的print()方法后，使用S调用的是子类的print()方法，如果一定要调用父类中的方法，可以用super关键字，super关键字可以从子类访问父类中的内容，如果要访问被重写过的方法，使用“super.方法名(参数列表)”的形式调用 例子： 1234567891011121314151617class Person2&#123;public void print () &#123;System.out.println( "父类Person的print方法! ");&#125;&#125;class Student2 extends Person2&#123;public void print () &#123;super.print();//访问父类中被子类覆写过的方法System.out.println(" 子类Student的print方法!" );&#125;&#125;public class OverrideExample02&#123;public static void main(String args[])&#123;Student2 s=new Student2();s.print();&#125;&#125; 运行结果： 被子类重写的方法不能拥有比父类方法更加严格的访问权限 当父类中方法的访问权限修饰符为private时，该方法只能被自己的类访问，不能被外部的类访问，在子类是不能被重写的。如果定义父类的方法为public，在子类定义为private，程序运行时就会报错 在继承过程中如果父类当中的方法抛出异常，那么在子类中重写父类的该方法时，也要抛出异常，而且抛出的异常不能多于父类中抛出的异常(可以等于父类中抛出的异常)。换句话说，重写方法一定不能抛出新的检查异常，或者比被重写方法声明更加宽泛的检查型异常。例如，父类的一个方法申明了一个检查异常IOException，在重写这个方法时就不能抛出Exception，只能抛出IOException的子类异常，可以抛出非检查异常 方法重载 方法重载是让类以统一的方式处理不同类型数据的一种手段。调用方法时通过传递给它们的不同个数和类型的参数来决定具体使用哪个方法，这就是多态性 所谓方法重载是指在一个类中，多个方法的方法名相同，但是参数列表不同，参数列表不同指的是参数个数、参数类型或者参数的顺序不同 不仅是一般的方法，构造方法也可以重载 例子： 1234567891011121314151617181920212223242526 Class Person &#123;&#123;String name; int age;void print()&#123; System.out.println("姓名：" +name+"年龄：" +age); &#125;void print(String a，int b)&#123; System.out.println("姓名：" +a+"年龄："+b); void print(String a，int b，intC)&#123; System.out.println("姓名："+a+"年龄：" +b+"ID号：" +c); &#125;void print(String a，int b，doubleC)&#123; System.out.println("姓名："+a+"年龄：" +b+"ID号："+c); &#125; &#125;public class OverLoadExampleOL &#123;public static void main(String[] args) &#123;Personpl=new Person();p1.name="李明";p1.age=22;p1.print(); p1.print("王小早",19); p1.print("金波",18,100325); p1.print("婉宁",25,110903); &#125; &#125; 在上面的程序中，可以看到Person类中有多个名为 void print的方法，这就是方法的重载。执行程序，运行结果如下： 每个重载方法可以有不同的返回类型,只要参数列表不同就可以了 可以有不同的访问修饰符 可以抛出不同的异常 总结 在面向对象程序设计的思想中，类的继承和多态性主要就是体现在子类重写父类的方法。而构造方法的重载作为方法重载的一个典型特例，可以通过重载构造方法来表达对象的多种初始化行为。灵活的运用方法重写与方法重载，不仅能减少编码的工作量，也能大大提高程序的可维护性及可扩展性 参考文章链接 注意以下这个方法重载的例子，实例方法可以用类名来作为返回类型创建！！ 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.awt.Point;//该类定义了一个矩形class Box &#123; int x1 = 0; int y1 = 0; int x2 = 0; int y2 = 0; Box buildBox(int x1, int y1, int x2, int y2) &#123; this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2; return this; &#125; Box buildBox(Point topLeft, Point bottomRight) &#123; x1 = topLeft.x; y1 = topLeft.y; x2 = bottomRight.x; y2 = bottomRight.y; return this; &#125; Box buildBox(Point topLeft, int w, int h) &#123; x1 = topLeft.x; y1 = topLeft.y; x2 = (x1 + w); y2 = (y1 + h); return this; &#125; void printBox()&#123; System.out.print("Box: &lt;" + x1 + ", " + y1); System.out.println(", " + x2 + ", " + y2 + "&gt;"); &#125; public static void main(String[] arguments) &#123; Box rect = new Box(); System.out.println("Calling buildBox with " + "coordinates (25,25) and (50,50):"); rect.buildBox(25, 25, 50, 50); rect.printBox(); System.out.println("\nCalling buildBox with " + "points (10,10) and (20,20):"); rect.buildBox(new Point(10, 10), new Point(20, 20)); rect.printBox(); System.out.println("\nCalling buildBox with " + "point (10,10), width 50 and height 50:"); rect.buildBox(new Point(10, 10), 50, 50); rect.printBox(); &#125;&#125; 结果为：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java入门（一）]]></title>
      <url>%2F2017%2F04%2F15%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Java作为一种面向对象语言。支持以下基本概念： 多态 继承 封装 抽象 类 对象 实例 方法 重载 成员变量包括：实例变量、类变量 成员方法包括：实例方法、类方法、构造方法 基本数据类型包括：byte、short、int、long、float、double、boolean、char 指针问题：不能说Java没有指针，它只是没有显示指针。对象引用实际上就是指针 Java中工程（项目）、包、类区别 项目就是project，包就是package，而class就是类了，项目里面包括所有的包，包是用来便于管理类，防止命名冲突，类是代码的容器，它们的关系就是上级与下级的关系，项目的下一级就是包，包的下级就是类 工程相当于一个软件，包相当于模块，类相当于模块下各个功能的实现 类下再有各种自己具体完成任务需要的成员变量和实现方法。主方法也在某一个public类中 包(package)相当于姓名中的“姓”，类(class)相当于“名”。所以在调用某类方法的时候，不仅需要指明方法所在的“名”，即类，还要指明方法类所在的“姓”，即类。这样编译器才知道你调用的方法是哪一个。 包类具体使用： 注意： 类名和文件名相同，一个Java文件中最好仅定义一个类，多类不方便管理。 如果多类定义，则仅有一个类可以被public修饰，这个类且必须和文件同名，其他类则不能被其他包里类所引用。此外，若存在主方法main函数，public的main方法只能存放在这个public类当中。 由于main方法是静态的，所以不可以直接调用类中非静态成员变量或方法。但是可以在main函数中创建实体（对象）再调用方法和变量。(即用new) 包建议小写字母开头，而类以大写字母开头。 类、实例、对象区别 类是对一项事物的抽象概括，是一个模板，可以包含该事物的一些属性定义，以及操作属性的方法 实例简单理解，就是new，就是对类的实例化，创建这个类对应的实际对象，类只是对事物的描述，而实例化就相当于为这个描述新开辟了一块内存，可以改变这块区域里的各种属性（成员变量），当然，也可以实例化多块区域，只是不同的对象而已。 类跟对象 可以这么说，对象就是实例，new的过程就是对象实例化的过程 例：1234567891011121314//ps就是对象的一个**引用**，要对这个对象进行操作的时候，就可以通过这个引用public class Peason &#123; String name; String sex; int age; public static void main(String [] args) &#123; Peason ps=new Peason(); ps.name=”张三”; ps.sex=”男”; ps.age=10; &#125; &#125; 构造方法（即构造函数） 是一种特殊的方法，它是一个与类同名且没有返回值类型的方法 对象的创建就是通过构造方法来完成，其功能主要是完成对象的初始化 满足如下语法规则： 方法名与类名相同 不要声明返回类型 不能被static、final、synchronized、abstract和native修饰。构造方法不能被子类继承，所以用final和abstract修饰没有意义 不能使用return语句来返回一个值 例子：一个类可以有多个构造方法！ 12345678910111213141516//以下Sample类中，具有int返回类型的Sample(int x)方法只是个普通的实例方法，不能作为构造方法public class Sample &#123;private int x; public Sample() &#123; // 不带参数的构造方法 this(1); &#125; public Sample(int x) &#123; //带参数的构造方法 this.x=x; &#125; public int Sample(int x) &#123; //不是构造方法 return x++; &#125; &#125; 如果构造函数的部分行为与已有的构造函数相同，可以在该构造函数中调用已有的构造函数。 例子： 123456789101112131415//第二个构造函数只接受x和y的坐标作为参数，由于没有定义半径，//因此使用默认值1——调用第一个构造函数，并将xPoint、yPoint、1作为参数传递给它 class Circle&#123; int x,y,radius; Circle(int xPoint,int yPoint,int rediusLength)&#123; this.x=xPoint; this.y=yPoint; this.radius=rediusLength; &#125; Circle(int xPoint,int yPoint)&#123; this(xPoint,yPoint,1); &#125;&#125; 注意： 构造方法可以重载，以参数的数目，类型，顺序 如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造器，这个构造器不执行任何代码。 构造方法不能被继承： 子类只继承父类的默认(缺省)构造函数（即无形参构造函数），如果父类没有默认构造函数，那子类不能从父类继承默认构造函数。 子类从父类处继承来的父类默认构造函数，不能成为子类的默认构造函数。 在创建对象时，先调用父类默认构造函数对对象进行初始化，然后调用子类自身自己定义的构造函数。 如果子类想调用父类的非默认构造函数，则必须使用super来实现 内存管理不同于其他面向对象语言，Java在内存管理是动态的、自动的，当你创建对象时，Java自动分配相应的内存，当使用完对象后，Java虚拟机自动查找未用的对象并回收这些对象占用的内存 权限问题Java类的访问控制 Java中不同控制符对应的权限java中的访问修饰符讲解 实例变量与类变量的区别，实例方法和类方法的区别详细链接一详细链接二 类变量：静态域，静态字段，或叫静态变量，它属于该类所有实例共有的属性，在内存中只有一个地方存储这个变量 类变量、类方法就是类中的变量、方法，必须是静态的，要加static；故其又称静态变量、静态方法。 实例变量：实例域，实例字段，或叫成员变量。 实例方法：或叫成员方法，必须先有实例，然后才能通过实例调用该实例方法 类变量和实例变量都必须在方法和语句块之外，区别在于类变量static而实例变量不是，类方法和实例方法的区别也是在有没有static上 类方法是属于整个类，而不属于某个对象 类方法的调用可以通过类名.类方法和对象.类方法，而实例方法只能通过对象.实例方法访问 类方法只能访问类方法，而实例方法可以访问类方法和实例方法。 类方法不能被覆盖，实例方法可以被覆盖（待验证） 每个实例都将有一个实例变量的一个副本，他们可以修改实例变量的值，而不会影响其他的示例；类变量只有一个副本，修改它的值将影响所有的实例 类方法与类变量一样，适用于整个类，而不是某个实例。类方法通常用作通用的工具方法，然不是直接操作某个对象，而是整个类。 类方法还可以用来将通用的方法集中起来，放在一个地方（即类中）。例如：在java.lang包中定义的类Math,将大量的数学运算作为类方法。不能创建Math对象，但可以只用它的类方法，并将数字和布尔值作为参数 使用方法： 类方法可以直接调用类变量和类方法 类方法不可以直接调用实例变量和实例方法 类方法中没有this，因为没有实例，this不知道调用哪个实例(只能在实力方法的定义体内使用this)，super也不行 类方法可以从类里面直接访问类成员 实例方法可以调用类方法，访问类变量，但是不提倡这样做，会把类方法和类变量混淆成实例方法和实例变量 例子： 12345678910111213141516171819202122232425262728293031 package Mypackage; class AnIntegerNamedX &#123; static int x; // 这里写成static，结果就变成全是2了，因为类变量是被实例所共享的， //包括myX和anotherX调用anotherX时所有的实例都改变了。 public int x() &#123; return x; &#125; public void setX(int newX) &#123; x = newX; &#125;&#125;public class Practice &#123;public static void main(String args[]) &#123; AnIntegerNamedX myX = new AnIntegerNamedX(); AnIntegerNamedX anotherX = new AnIntegerNamedX(); myX.setX(1); anotherX.x = 2; // 这里把X的值改成2，所有实例的X都是2了，因为类变量是被 //所有实例共享的，任何实例都可以对类变量做最终的修改 System.out.println("myX.x = " + myX.x()); System.out.println("anotherX.x = " + anotherX.x());&#125;&#125; 结果为： 若将static int x;改成int x;，则结果为： 若将static int x;改成int x;，将x()方法和setX()加上static变成静态方法，则会提示错误让把X变成静态，是因为类方法不能直接访问实例变量！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用例图学习笔记]]></title>
      <url>%2F2017%2F04%2F15%2F%E7%94%A8%E4%BE%8B%E5%9B%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[基本概念 主要用来图示化系统的主事件流程 用例就是软件的功能模块，是设计系统分析阶段的起点 描述软件应该具备哪些功能模块以及这些模块之间的调用关系 用例图包含“用例”和“参与者” 用例之间通过关联来连接，以便把系统的整个结构和功能反映给客户 对应的是软件的结构和功能分解 用例之间可以抽象出：包含、扩展、泛化关系。（最常见是：关联） 图示 关联 包含 扩展 泛化 示例 包含 扩展 泛化 具体讲解请戳 组成：系统、用例、参与者、关系 解释 被包含的用例可以单独执行 一个用例被定义为基础用例的增量扩展，称作为扩展关系，在特定的条件发生时，扩展用例才会被执行 泛化关系中，父用例往往表现为抽象用例，任何父用例出现的地方，子用例也可出现 简单说： 泛化侧重子用例之间的互斥性； 包含侧重被包含用例对参与者提供服务的间接性； 扩展侧重扩展用例的出发不确定性。 参与者种类： 系统用户 与所建造的系统交互的其他系统 一些可以运行的进程 用例图建模技术分为：对语境建模、对需求建模 对语境建模 对需求建模 实现步骤 确定系统涉及的总体信息 确定系统的参与者 确定系统的用例 绘制系统的用例图 例子 绘制步骤 添加参与者与用例 添加参与者与用例之间的关系 添加用例之间的关系]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NexT主题配置进阶]]></title>
      <url>%2F2017%2F04%2F15%2FNexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%BF%9B%E9%98%B6%2F</url>
      <content type="text"><![CDATA[主题配置包括： 设置「RSS」 添加「标签」页面 如何为文章添加标签或者分类 添加「分类」页面 设置「字体」 设置「代码高亮主题」 侧边栏社交链接 开启打赏功能 设置友情链接 腾讯公益404页面 站点建立时间 订阅微信公众号 设置「动画效果」 设置「背景动画」 第三方服务包括： 评论系统 数据统计与分析 内容分享服务 搜索服务 其他服务 稍微写一下基本操作：标签 新建标签页面：（这样标签合辑的页面被制作出来） 编辑刚刚新建的页面，将其页面类型设置为tags（这样主题将知道这是一个标签页面，并为这个页面显示标签云） 编辑主题配置文件，添加tags到menu目录中 之后在新建的文章中就可以通过设置文章中的开始的声明来为文章添加标签了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo安装及默认主题配置]]></title>
      <url>%2F2017%2F04%2F15%2FHexo%E5%AE%89%E8%A3%85%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[#安装Hexo 想重建博客，又不想花时间从头设计实现网站，就开始找有什么方法能快速实现页面布局和设计，最开始用了wordpress平台，后来又看到大佬推荐Hexo,就看了看。 PS:Hexo依赖于Node,所以电脑得有Node.js环境，然后就可以用Node中强大的npm命令来安装各种东西，当然包括Hexo。Node和Git的安装教程自己百度。 Hexo安装教程 hexo入门指南 yilia主题 Next主题 yelee主题 另外还找到jekyll直接托管在github上，好像挺牛逼的，有时间再折腾吧准备自己建一个个人博客，有什么好的框架推荐？ 我的安装过程 在git bash内使用npm install hexo -g安装，直接在根目录下装的 然后在想要创建博客的地方使用hexo init blog命令创建blog文件夹（不只是文件夹，整个默认的hexo博客主题等都将从github上下到该文件夹下） 完成后，在blog文件夹内，hexo generate生成静态页面，生成的静态页面存储在public文件夹下，只要有一个web server就可以独立运行网站了 hexo server启动本地服务，浏览器输入http://localhost:4000/即可访问刚刚创建的博客了 如果不行，说明端口被占用，用hexo s -p 5000重新开启本地服务，然后http://localhost:5000/即可访问创建的页面 就是这么简单，主要都是细节问题，对于刚入门的同道，需要知道的是，以上命令都在git bash里面执行就可以，因为cmd有的功能bash基本上都有，Node博主当时是默认安装在C盘，用npm install npm -g升级了下Node自带的npm，然后直接在根目录（刚打开git bash时的目录）执行的npm install hexo -g安装hexo，在其他目录安装的话，用全局安装应该也可以，不过我没折腾过。 部署到github部署到github 修改blog目录下的_config.yml文件如下：title为网站主标题，subtitle为副标题，都是顾名思义的，language和timezone要注意书写格式，还有，每个“：”之后要记得加上空格 更改完_config.yml之后，输入npm install hexo-deployer-git --save（不知道是不是必须的，可能是怕没有安装deploy，怕在后面发布到github的时候出错） 在终端输入hexo new &quot;文章标题&quot;来新建文章，也可以在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件。 可能会出现发布后中文乱码的问题，只要把相应的.md文件保存成UTF-8格式就行了。比如用txt打开，然后另存为UTF-8格式。 然后进行本地发布：$ hexo server 此时浏览器输入http://localhost:4000/可以看到我们搭建好的博客和发布的文章 目前只能在本机看到 接下来用 $ hexo generate//生成静态页面 $ hexo deploy//发布到更改_config.yml时指定的githubc仓库上 这样使用github的仓库地址例如本例的http://inerdstack.github.io就可以访问我们的博客了 部署步骤每次部署的步骤，可按以下三步来进行。 hexo clean hexo generate hexo deploy 一些常用命令： hexo new”postName” #新建文章 hexo new page”pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo的hexo deploy无法使用]]></title>
      <url>%2F2017%2F04%2F15%2FHexo%E7%9A%84hexo-deploy%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[具体情况是，在hexo generate生成静态页面后，用hexo deploy命令想发布到github上，却出现了问题，报错如下： 即提示找不到用户名，这应该是ssh配置的问题，索性就没用ssh传输，直接在博客文件夹下用 $ git init $ git remote add origin https://github.com/{USER_NAME}/{REPOSITORY_NAME}.git 然后再执行hexo deploy就成功了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-NexT主题]]></title>
      <url>%2F2017%2F04%2F15%2FHexo-NexT%E4%B8%BB%E9%A2%98%2F</url>
      <content type="text"><![CDATA[看来很多Hexo主题，最后还是想用NexT主题的Mist版本，简直不能再棒。不愧是最受欢迎的Hexo主题。 官网讲得已经很好了 我稍微再说一下。 能想到用NexT的肯定对Hexo、Node、Git、Github有了解了，我就不再过多描述了。 步骤 在终端窗口（比如：git bash），定位到Hexo的博客目录下，输入以下命令： $ cd your-hexo-site //比如我的博客目录是blog,就写blog $git clone https://github.com/iissnan/hexo-theme-next themes/next 完成后，更改站点配置文件，即blog目录下的_config.yml,找到theme字段，将其值置为next 这样其实就已经完成了 在终端输入$ hexo server通过相应端口访问就可以验证主题是否设置成功了 选择样式 Next有3种样式默认的是Muse，另外还有Mist和Pisces，可以通过更改主题的配置文件来选择样式，主题配置文件路径为\themes\next_config.yml 搜索scheme关键字，找到三行scheme的配置，将要启用的样式前的“#”去掉，不用的样式前加上“#”即可 另外主题语言、菜单、头像等的相关设置可以参见官网，讲得通俗易懂，已经很容易理解了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node安装]]></title>
      <url>%2F2017%2F04%2F15%2FNode%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[之前就久仰Node.js大名，最近想弄个Hexo+github的博客，需要Node支持，所以开始接触这个方面的内容。 这个链接介绍了Node安装和通过Node创建简单的服务器：我们安装了Nodejs是安装了什么 Node安装完后，安装目录下会多出几个文件，其中： Node_modules（Nodejs的模块都在这里，默认有一个Npm包管理模块） Node.exe（nodejs的核心解析器） 网上对Node.js的说法 Node 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”。 node.js…它既是开发平台, 也是运行环境, 也是个新的语言…它本身是基于google的javascript v8引擎开发的 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，使得Javascript也具备了写“服务器端”的能力。 支持多用户的高并发是其优势之一 它的出现能够让前端工程师更好的理解后端服务器运作原理，搭建一个功能全面的web应用。学习nodejs对于了解http、tcp协议是很好的。 什么是npm经常看到一些npm开头的命令，所以搜了一下 npm 是 nodejs 的包管理和分发工具。它可以让 javascript 开发者能够更加轻松的共享代码和共用代码片段，并且通过 npm 管理你分享的代码也很方便快捷和简单。 安装完 nodejs 就已经有了npm, 不过由于 nodejs 更新速度要慢于npm ，因此在一般情况下要升级你的 npm 到最新版本，输入如下命令： npm install npm -g 我的安装步骤： 到官网下载node.js 然后直接默认安装 听说自带的npm版本会比较低，所以就用npm install npm -g命令升级了一下 命令操作都是在cmd里面进行的，在git bash里面好像也行，难道这俩是互通的？？？ 查了下，确实是相通的，git bash和windows里的cmd功能差不多，只不过git bash里加了几个实用的linux命令以及git自己的命令]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WampServer 3.0环境配置问题]]></title>
      <url>%2F2017%2F04%2F15%2FWampServer%203.0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[在网上直接搜“WampServer 3.0”配置，不要只搜“WampServer配置”，因为这样收到的很多都是旧版本的教程，新版本的配置方法略有差别 配置包括： Apache根目录的改变 Wamp根目录的改变（此版本还要更改虚拟主机配置文件中的虚拟主机根目录才能奏效），具体的看教程 还有一个问题是：“wampserver 主页里点击“Your Projects”下面项目名，显示错误的问题。”解决这个问题需要更改Wamp根目录下的index.php文件中的路径代码，具体方法如下： 进入index.php文件，（wamp 3.0.6是在第445行），搜索$projectContents(这是YourProjects文件内容的相关变量)，在搜索结果里，找到一行代码中以$projectContents.=&#39;http://&#39;.$UrlPort.&#39;开头的，改成$projectContents .= &#39;http://localhost&#39;.$UrlPort.&#39;/&#39;.$file.&#39;/&quot;&#39;;如图： 这样子就可以了。 如何让Wampserver允许局域网甚至是外网访问？看这里]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[php环境问题]]></title>
      <url>%2F2017%2F04%2F15%2Fphp%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[用的是phpstorm和wamp搭建的环境，php版本为5.6 提交表单后，运行老是报错“Deprecated: Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version. To avoid this warning set ‘always_populate_raw_post_data’ to ‘-1’ in php.ini and use the php://input stream instead. in Unknown on line 0” 我运行是直接点的phpstorm里面的chrome快捷键，结果出现上面的错误，网上的方法试了，更改php.ini文件的always_populate_raw_post_data的值无效。 后来发现，从phpstorm直接运行的页面地址跟wamp根目录运行的页面地址是不一样的（废话，肯定不一样，因为我phpstorm的项目地址跟wamp的不在一起），而且很奇怪的一点，wamp提供的更改php.ini的地址不是php安装目录里的那个php.ini。搞得我有点晕。 后来索性把要运行的那个项目移动到wamp根目录，用localhost（wamp根地址）运行，结果就成功了，成功了，没错，不报错了，就是这么简单，具体为什么等我把这项目弄完了再好好研究吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Html常用标签大全]]></title>
      <url>%2F2017%2F04%2F14%2FHtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[基本&lt;html&gt;…&lt;/html&gt; 定义 HTML 文档 &lt;head&gt;…&lt;/head&gt; 文档的信息 &lt;meta&gt; HTML 文档的元信息 &lt;title&gt;…&lt;/title&gt; 文档的标题 &lt;link&gt; 文档与外部资源的关系 &lt;style&gt;…&lt;/style&gt; 文档的样式信息 &lt;body&gt;…&lt;/body&gt; 可见的页面内容、 &lt;!--…--&gt; 注释 文本&lt;h1&gt;...&lt;/h1&gt; 标题字大小（h1~h6） &lt;b&gt;...&lt;/b&gt; 粗体字 &lt;strong&gt;...&lt;/strong&gt; 粗体字(强调) &lt;i&gt;...&lt;/i&gt; 斜体字 &lt;em&gt;...&lt;/em&gt; 斜体字(强调) &lt;u&gt;...&lt;/u&gt; 下划线 &lt;del&gt;...&lt;/del&gt; 删除线(表示删除) &lt;center&gt;…&lt;/center&gt; 居中文本 &lt;ul&gt;…&lt;/ul&gt; 无序列表 &lt;ol&gt;…&lt;/ol&gt; 有序列表 &lt;li&gt;…&lt;/li&gt; 列表项目 &lt;a href=”…”&gt;…&lt;/a&gt; 超链接 &lt;font&gt; 定义文本字体尺寸、颜色、大小 &lt;sub&gt; 下标 &lt;sup&gt; 上标 &lt;br&gt; 换行 &lt;p&gt; 段落 图形&lt;img src=’”…”&gt; 定义图像 &lt;hr&gt; 水平线 表格&lt;table&gt;…&lt;/table&gt; 定义表格 &lt;th&gt;…&lt;/th&gt; 定义表格中的表头单元格 &lt;tr&gt;…&lt;/tr&gt; 定义表格中的行 &lt;td&gt;…&lt;/td&gt; 定义表格中的单元 其它&lt;form&gt;…&lt;/form&gt; 定义供用户输入的 HTML 表单 &lt;frame&gt; 定义框架集的窗口或框架 另加16进制颜色，但仅仅有16种颜色名可用英文字母，其余的要用16进制值。 记住哦！ aqua, black, blue, fuchsia, gray, green, lime,maroon, navy, olive, purple, red, silver, teal, white, yellow]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git上传github仓库步骤]]></title>
      <url>%2F2017%2F04%2F07%2FGit%E4%B8%8A%E4%BC%A0github%E4%BB%93%E5%BA%93%E6%AD%A5%E9%AA%A4%2F</url>
      <content type="text"><![CDATA[这个教程是基于电脑上已经装有git和拥有github账号的基础上的。（没装git的可以去git官网下载，本文以windows64位系统为基础） 在git bash内输入以下命令在配置文件中保存身份： git config −−global user.name “github账号” git config −−global user.email “注册github时用的邮箱” 比如你要上传的本地仓库是在桌面的test文件夹内的所有文件：用命令行进入到test文件夹下（本例是上传test内的test.txt文件），涉及相关文件操作命令同linux。 在github中创建新仓库test: 在bash内，输入git init进行初始化： 将所有文件添加到上传队列中(“.”表示全部文件，可以用特定文件名来代替，进行特定文件上传；中间可以用git status 命令来查看文件所在所处的状态)：git add . 提交文件到本地git仓库：git commit −m “注释” 连接github中的test仓库：git remote add origin https://github.com/zifenggao/test.git（此段代码可以到创建成功后的github test仓库的code栏内复制得到） 然后输入git push origin master命令即可完成本地git仓库上传到github仓库的操作： 这样就完成了本地git上传到github仓库的操作，到github中刷新test仓库可以查看到我们上传的内容：]]></content>
    </entry>

    
  
  
</search>
