<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[链表常见面试题]]></title>
      <url>%2F2017%2F10%2F15%2F%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
      <content type="text"><![CDATA[这里只讲思路，具体代码看这里–数据结构常见面试题 求单链表中结点的个数遍历一遍链表，直到结束，注意链表为空的情况，时间复杂度为O(n) 将单链表反转从头到尾遍历原链表，每遍历一个结点，将其摘下放在新链表的最前端。注意链表为空和只有一个结点的情况。时间复杂度为O（n） 查找单链表中的倒数第K个结点（k &gt; 0） 方法一：最普遍的方法是，先统计单链表中结点的个数，然后再找到第（n-k）个结点。注意链表为空，k为0，k为1，k大于链表中节点个数时的情况。时间复杂度为O（n） 方法二：主要思路就是使用两个指针，先让前面的指针走到正向第k个结点，这样前后两个指针的距离差是k-1，之后前后两个指针一起向前走，前面的指针走到最后一个结点时，后面指针所指结点就是倒数第k个结点 查找单链表的中间结点设置两个指针，两个指针同时向前走，前面的指针每次走两步，后面的指针每次走一步，前面的指针走到最后一个结点时，后面的指针所指结点就是中间结点，即第（n/2+1）个结点。注意链表为空，链表结点个数为1和2的情况。时间复杂度O（n）。 从尾到头打印单链表对于这种颠倒顺序的问题，会想到栈，后进先出。所以，这一题要么自己使用栈，要么让系统使用栈，也就是递归。注意链表为空的情况。时间复杂度为O（n） 已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序这个类似归并排序。尤其注意两个链表都为空，和其中一个为空时的情况。只需要O（1）的空间。时间复杂度为O（max(len1, len2)） 判断一个单链表中是否有环用到两个指针。如果一个链表中有环，也就是说用一个指针去遍历，是永远走不到头的。因此，我们可以用两个指针去遍历，一个指针一次走两步，一个指针一次走一步，如果有环，两个指针肯定会在环中相遇。时间复杂度为O（n） 判断两个单链表是否相交如果两个链表相交于某一节点，那么在这个相交节点之后的所有节点都是两个链表所共有的。也就是说，如果两个链表相交，那么最后一个节点肯定是共有的。先遍历第一个链表，记住最后一个节点，然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则不相交。时间复杂度为O(len1+len2)，因为只需要一个额外指针保存最后一个节点地址，空间复杂度为O(1) 求两个单链表相交的第一个节点对第一个链表遍历，计算长度len1，同时保存最后一个节点的地址。 对第二个链表遍历，计算长度len2，同时检查最后一个节点是否和第一个链表的最后一个节点相同，若不相同，不相交，结束。 两个链表均从头节点开始，假设len1大于len2，那么将第一个链表先遍历len1-len2个节点，此时两个链表当前节点到第一个相交节点的距离就相等了，然后一起向后遍历，知道两个节点的地址相同。 时间复杂度，O(len1+len2) 已知一个单链表中存在环，求进入环中的第一个节点首先判断是否存在环，若不存在结束。在环中的一个节点处断开（当然函数结束时不能破坏原链表），这样就形成了两个相交的单链表，求进入环中的第一个节点也就转换成了求两个单链表相交的第一个节点 给出一单链表头指针pHead和一节点指针pToBeDeleted，O(1)时间复杂度删除节点pToBeDeleted对于删除节点，我们普通的思路就是让该节点的前一个节点指向该节点的下一个节点，这种情况需要遍历找到该节点的前一个节点，时间复杂度为O(n)。对于链表，链表中的每个节点结构都是一样的，所以我们可以把该节点的下一个节点的数据复制到该节点，然后删除下一个节点即可。要注意最后一个节点的情况，这个时候只能用常见的方法来操作，先找到前一个节点，但总体的平均时间复杂度还是O(1)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5数据集属性]]></title>
      <url>%2F2017%2F10%2F10%2FHTML5%E6%95%B0%E6%8D%AE%E9%9B%86%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[有时候在HTML元素上绑定一些额外信息，特别是JS选取操作这些元素时特别有帮助。 通常会使用getAttribute()和setAttribute()来读和写非标题属性的值。但为此付出的代价是文档将不再是合法有效的HTML HTML5提供了一个解决方案。在HTML5文档中，任意以”data-“为前缀的小写的属性名字都是合法的。这些“数据集属性”将不会对其元素的表现产生影响，它们定义了一种标准的、附加额外数据的方法，并不是在文档合法性上做出让步。 HTML5还在Element对象上定义了dataset属性。该属性指代一个对象，它的各属性对应于去掉前缀的data-属性。因此dataset.x应该保存data-x属性的值。带连字符的属性对应于驼峰命名法属性名。如Element属性data-jquery-test在js中对应于dataset.jqueryTest属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于clientHeight、offsetHeight、scrollHeight等]]></title>
      <url>%2F2017%2F10%2F05%2F%E5%85%B3%E4%BA%8EclientHeight%E3%80%81offsetHeight%E3%80%81scrollHeight%E7%AD%89%2F</url>
      <content type="text"><![CDATA[关于clientHeight，offsetHeight等小笔记]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CMS系统]]></title>
      <url>%2F2017%2F09%2F27%2FCMS%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"><![CDATA[什么是CMS系统CMS就是内容管理系统 主要功能就是基于内容发布的一种系统。目前cms系统多是打包开发好的成品程序（目前很多程序的二次开发潜力非常丰富），有完整的安装流程，以及帮助文档。 以dedecms为例，使用程序比较简单，到织梦官网去下载好程序以后找到适合的虚拟安装空间，上传以后进入安装环节，输入数据库账号密码，设置管理账号密码，安装即完成。 进入后台以后，设置栏目分类，系统参数等细节，一个网站就搭建完成了。 如果有数据库，该怎么读取？比如说要改变页面显示的内容——读取数据库的内容 这个在cms中可以按照指定标签调用出来。改变页面内容，后台都有相应的编辑功能可以提交更改等。 cms以外的数据库 这个要复杂点了，你可以建立数据库连接，用sql语句进行操作。 都有哪些CMS系统 DEDECMS(织梦内容管理系统) PageAdmin CMS（PageAdmin网站管理系统） ECMS(帝国内容管理系统) PHPCMS 动易CMS PHP168内容管理系统 JTBC_CMS （JTBC内容管理系统） 风讯CMS 新云CMS KINGCMS]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[各大浏览器内核]]></title>
      <url>%2F2017%2F09%2F20%2F%E5%90%84%E5%A4%A7%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%2F</url>
      <content type="text"><![CDATA[Trident内核:IE、Netscape 8 Gecko内核：Firefox、Netscape6至9 WebKit内核：Safari、Chrome、Opera(现在改用这个了) (不对)Presto内核：Opera 7.0+，（旧版Opera 4至6版本使用的Elektra排版引擎）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js实现循环setTimeout输出0,1,2,3,4]]></title>
      <url>%2F2017%2F09%2F20%2Fjs%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AFsetTimeout%E8%BE%93%E5%87%BA0-1-2-3-4%2F</url>
      <content type="text"><![CDATA[转-js实现循环setTimeout输出0,1,2,3,4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP协议]]></title>
      <url>%2F2017%2F09%2F17%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[对整个http协议进行比较全面的介绍：HTTP协议漫谈 http头包含的那些信息：HTTP头部信息解释分析(详细整理) HTTP1.0 HTTP 1.1 HTTP 2.0主要区别 并不是每个请求都会带Referrer信息的http general之Referrer Policies介绍 如上图所示，在 HTTPS 加密中真正起作用的其实是 SSL/TLS 协议。SSL/TLS 协议作用在 HTTP 协议之下，对于上层应用来说，原来的发送接收数据流程不变，这就很好地兼容了老的 HTTP 协议，这也是软件开发中分层实现的体现，SSL/TLS 握手是为了安全地协商出一份对称加密的秘钥。 图解SSL/TLS协议 http中的host应该能就是用来解决不同不明访问同一个ip地址的操作的，到达分布均衡的效果（可以理解成负载均衡）HTTP中的Host字段 HTTP协议有多脆弱：常见攻击HTTP协议的五大方式 HTTP 协议中 Vary 的一些研究–HTTP内容协商、有 BUG 的缓存服务]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TCP/IP OSI各层协议]]></title>
      <url>%2F2017%2F09%2F15%2FTCP-IP-OSI%E5%90%84%E5%B1%82%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[转：TCP/IP OSI各层协议，ARP属于哪一层的协议 Ip是不可靠协议 在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层。 ARP报文是由以太网帧进行封装传输的。没有封装进IP包。 HTTP也是应用层协议 OSI各层对应设备及其协议]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于JS闭包]]></title>
      <url>%2F2017%2F08%2F27%2F%E5%85%B3%E4%BA%8EJS%E9%97%AD%E5%8C%85%2F</url>
      <content type="text"><![CDATA[学习笔记：学习Javascript闭包（Closure）-阮一峰 变量的作用域JS中： 在函数外部自然无法读取函数内的局部变量： 1234function f1()&#123; var n=999; &#125; alert(n); // error 函数内部可以直接读取全局变量 12345var n=999; function f1()&#123; alert(n); &#125; f1(); // 999 函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量: 12345function f1()&#123; n=999; &#125; f1(); alert(n); // 999 如何从外部读取局部变量？正常情况下，这是办不到的，只有通过变通方法才能实现：在函数的内部，再定义一个函数 123456function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的” 链式作用域 “结构（chain scope） 链式作用域 “结构:子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗?见代码： 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 PS:不是很理解，既然像上面那么玩：把函数内的值返回来达到读取函数内的值目的，那这么写不是更简单：可能他这么说另有目的，对下面要说的内容可能有用。不过从他的程序也能学到一点，就是函数A体内在定义一个函数B，外部对A函数执行后的返回值，直接再执行返回值();就能执行其内部的函数B。var result=f1();result(); // 999。不过这好像是建立在A的返回值是B的基础上的。 闭包的概念上一节代码中的f2函数，就是闭包。(PS:好吧，真的有用) 闭包就是能够读取其他函数内部变量的函数。 在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的用途最大的用处有两个： 前面提到的可以读取函数内部的变量 让这些变量的值始终保持在内存中 对于第2个用处： 123456789101112function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999nAdd();result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。(PS:很容易就看懂了，并没有想到什么“局部变量被清除的问题”，震惊。) 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 闭包中由于内部函数的原因，外部函数并不能算是结束，即变量的生命周期没有结束，所以不能进行垃圾回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 使用闭包的注意点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。(结合这篇文章来理解为什么IE会泄露以及为什么用这种解决方法–JavaScript 垃圾回收) 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS的作用域和变量提升问题]]></title>
      <url>%2F2017%2F08%2F21%2FJS%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[作用域（scoping）JavaScript是 函数级作用域。块（可以理解成一个“{}”），就像if语句，并不会创建一个新的作用域，即 没有块级作用域 。只有函数才会创建新的作用域。 123456789101112131415161718//例1function fire(bool) &#123; if (bool) &#123; var foo = "bar"; &#125; console.log(foo);&#125;fire(true); //=&gt; bar//例2var x = 1;console.log(x); // 1if (true) &#123;var x = 2;console.log(x); //2&#125;console.log(x);// 2 变量提升–Hoisting（提升） Hosting 只提升了命名，没有提升定义 看一下这题： 12345var v='Hello World';(function()&#123;alert(v);var v='I love you';&#125;)() //结果：undefined 为什么会是这样的结果？变量提升，JS中声明的变量，不管在哪个地方声明定义的，其这个变量的声明都会默认被提升到作用域的最前面。像上面说的，JS是函数级作用域，也就是说var v=&#39;I love you&#39;中的var v;会被提升到它所处的函数的最前面，上面那段代码等价于： 123456var v='Hello World';(function()&#123;var v; //被提升到这个地方alert(v);v='I love you';&#125;)() 当解析器读到 if 语句的时候，它发现此处有一个变量声明和赋值，于是解析器会将其声明提升至当前作用域的顶部（这是默认行为，并且无法更改），这个行为就叫做 Hoisting。 这样就懂了，alert后自然是undefined。所以写js代码的时候，要把变量的声明写在作用域的最前端，防止出现意外。 这样再来看这个例子就懂了: 12345678function fire(bool) &#123; if (bool) &#123; var foo = "bar"; &#125; else &#123; console.log(foo); &#125;&#125;fire(false); //=&gt; undefined 等价于（只提升了声明，没有提升定义） 123456789function fire(bool) &#123; var foo; //被提示提升到这个地方 if (bool) &#123; foo = "bar"; &#125; else &#123; console.log(foo); &#125;&#125;fire(false); //=&gt; undefined 函数提升函数提升是把整个函数都提到前面去。 我们写函数的时候有两种方式：一种是函数表达式、另一种是函数声明方式。只有函数声明形式才能被提升 函数声明方式提升： 123456789//函数 myTest 是一个声明function myTest()&#123; foo(); function foo()&#123; alert("我来自 foo"); &#125;&#125;myTest(); //（执行成功） 函数表达式方式提升： 12345678910//这里被提升的仅仅是变量名 foo，至于它的定义依然停留在原处。因此在执行 foo() 之前//作用域只知道 foo 的命名，不知道它到底是什么function myTest()&#123; foo(); var foo =function foo()&#123; alert("我来自 foo"); &#125;&#125;myTest(); //（执行失败） let实现块级作用域–解决变量提升问题es6 之前，JavaScript 并没有块级作用域，所谓的块，就是大括号里面的语句所组成的代码块 let定义的变量只有在代码块内有效。 12345678function fire(bool) &#123; if (bool) &#123; let foo = "bar"; &#125; console.log(foo);&#125;fire(true); //=&gt; Uncaught ReferenceError: foo is not defined 其次, let定义的变量不存在变量提升： 12345678function fire(bool) &#123; if (bool) &#123; let foo = "bar"; &#125; else &#123; console.log(foo); &#125;&#125;fire(false); //=&gt; Uncaught ReferenceError: foo is not defined 所以应当尽可能的避免用 var，用 let 来代替，除非需要用到变量提升。 再来几个例子变量提升12345678910var a = 1;function foo() &#123; if (!a) &#123; var a = 2; &#125; alert(a);&#125;;foo();// 结果：2 解释器分析上面的代码时： 12345678910var a;a = 1;function foo() &#123; var a; // 变量提升 if (!a) &#123; a = 2; &#125; alert(a); // 此时的 a 并非函数体外的那个全局变量&#125; 想要结果是1怎么办？–创建新的作用域 alert(a) 在执行的时候，会去寻找变量 a 的位置，它从当前作用域开始向上（或者说向外）一直查找到顶层作用域为止，若是找不到就报 undefined。 因为在 alert(a) 的同级作用域里，我们再次声明了本地变量 a，所以它报 2；所以我们可以把本地变量 a 的声明向下（或者说向内）移动，这样 alert(a) 就找不到它了。 12345678910var a = 1;function foo() &#123; if (!a) &#123; (function() &#123; // 这是上一篇说到过的 IIFE，它会创建一个新的函数作用域 var a = 2; // 并且该作用域在 foo() 的内部，所以 alert 访问不到 &#125;()); // 不过这个作用域可以访问上层作用域哦，这就叫：“闭包” &#125;; alert(a);&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[innerHTML与innerText区别]]></title>
      <url>%2F2017%2F08%2F20%2FinnerHTML%E4%B8%8EinnerText%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[innerHTML与innerText区别 innerHTML与innerText innerHTML指的是从对象的起始位置到终止位置的全部内容,包括Html标签。 innerText 指的是从起始位置到终止位置的内容,但它去除Html标签。 innerHTML 是所有浏览器都支持的，innerText 是IE浏览器和chrome 浏览器支持的，Firefox浏览器不支持。其实，innerHTML 是W3C 组织规定的属性；而innerText 属性是IE浏览器自己的属性，不过后来的浏览器部分实现这个属性罢了。 outerHTMLouterHTML指的是除了包含innerHTML的全部内容外, 还包含对象标签本身 总结innerHTML是符合W3C标准的属性，而innerText只适用于IE浏览器（现在也适应chrome浏览器），因此，尽可能地去使用 innerHTML，而少用innerText，如果要输出不含HTML标签的内容，可以使用innerHTML取得包含HTML标签的内容后，再用正则表达式去除HTML标签，下面是一个简单的符合W3C标准的示例： 12345678910&lt;html&gt; &lt;head&gt;&lt;title&gt;innerHTML&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="d1"&gt;&lt;p id="p1"&gt;hello world &lt;/p&gt;&lt;/div&gt; &lt;script&gt; var content = document.getElementById("p1"); alert(content.innerHTML.replace(/&amp; lt;.+?&gt;/gim,'')); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 弹出的为去掉了html标签之后的内容]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于通过302临时重定向实现网址劫持]]></title>
      <url>%2F2017%2F08%2F19%2F%E5%85%B3%E4%BA%8E%E9%80%9A%E8%BF%87302%E4%B8%B4%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91%E5%AE%9E%E7%8E%B0%E7%BD%91%E5%9D%80%E5%8A%AB%E6%8C%81%2F</url>
      <content type="text"><![CDATA[HTTP返回码中301与302的区别 302重定向和网址劫持（URL hijacking）有什么关系呢？这要从搜索引擎如何处理302转向说起。从定义来说，从网址A做一个302重定向到网址B时，主机服务器的隐含意思是网址A随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到302重定向时，一般只要去抓取目标网址就可以了，也就是说网址B。 实际上如果搜索引擎在遇到302转向时，百分之百的都抓取目标网址B的话，就不用担心网址URL劫持了。问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。为什么呢？比如说，有的时候A网址很短，但是它做了一个302重定向到B网址，而B网址是一个很长的乱七八糟的URL网址，甚至还有可能包含一些问号之类的参数。很自然的，A网址更加用户友好，而B网址既难看，又不用户友好。这时Google很有可能会仍然显示网址A。 由于搜索引擎排名算法只是程序而不是人，在遇到302重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址URL劫持的可能性。也就是说，一个不道德的人在他自己的网址A做一个302重定向到你的网址B，出于某种原因， Google搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B上的内容，这种情况就叫做网址URL劫持。你辛辛苦苦所写的内容就这样被别人偷走了。 这就导致要去考虑网址规范的问题。 如果是301跳转，自然就不同去考虑网址规范的问题了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于Js实现的页面跳转--reload、replace、href、open]]></title>
      <url>%2F2017%2F08%2F19%2F%E5%85%B3%E4%BA%8EJs%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC-reload%E3%80%81replace%E3%80%81href%E3%80%81open%2F</url>
      <content type="text"><![CDATA[window.location.href属于：JS Window操作 用法：window.location.href=地址 新页面会替换当前页面，浏览器有回退（即回到上一个页面）的选项。 window.open属于：JS HTML DOM操作 HTML DOM Window 对象即为Browser对象的window 用法：window.open(地址) 新页面会在新窗口打开 123456&lt;script&gt;function open_win()&#123;window.open("http://www.w3school.com.cn")&#125;&lt;/script&gt; location.reload属于:JS HTML DOM操作 用法：location.reload(force) 123456&lt;script type="text/javascript"&gt;function reloadPage() &#123; window.location.reload() &#125;&lt;/script&gt; 重新加载本页面 location.replace属于：Browser对象 用法：location.replace(newURL) 新页面会替代原本的页面，浏览器不会有会退的箭头，是个全新的页面 12345&lt;script&gt;function replaceDoc()&#123; window.location.replace("http://www.runoob.com")&#125;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于cookie与session]]></title>
      <url>%2F2017%2F08%2F19%2F%E5%85%B3%E4%BA%8Ecookie%E4%B8%8Esession%2F</url>
      <content type="text"><![CDATA[前言 DNS是域名系统(DomainNameSystem)的缩写,是有状态协议 HTTP是无状态协议：同一个会话的连续两个请求互相不了解，他们由最新实例化的环境进行解析，除了应用本身可能已经存储在全局对象中的所有信息外，该环境不保存与会话有关的任何信息。 正是因为这个才导致了cookie和session的产生 无状态是指，当浏览器发送请求给服务器的时候，服务器响应，但是同一个浏览器再发送请求给服务器的时候，他会响应，但是他不知道你就是刚才那个浏览器，简单地说，就是服务器不会去记得你，所以是无状态协议。而DNS是有状态协议 。 两种用于保持HTTP连接状态的技术–Cookie&amp;SessionCookie Cookie是通过客户端保持状态的解决方案。 Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。 当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置，对于Windows操作系统而言，我们可以从：[系统盘]:\Documents and Settings[用户名]\Cookies目录中找到存储的Cookie；自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。而这次，Cookie信息则存放在HTTP请求头（Request Header）了。 我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过Cookie实现的。 cookie还可以用来做广告跟踪，即定向的推送广告 Session 与Cookie相对的一个解决方案，是通过服务器来保持状态的。 我们通常都会把Session翻译成会话，因此我们可以把客户端浏览器与服务器之间一系列交互的动作称为一个Session。从这个语义出发，我们会提到Session持续的时间，会提到在Session过程中进行了什么操作等等；其次，Session指的是服务器端为客户端所开辟的存储空间，在其中保存的信息就是用于保持状态。从这个语义出发，我们则会提到往Session中存放什么内容，如何根据键值从Session中获取匹配的内容等。 那么Session在何时创建呢？当然还是在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建Session的方法 在创建了Session的同时，服务器会为该Session生成唯一的Session id，而这个Session id在随后的请求中会被用来重新获得已经创建的Session；在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session，从而再次使用之。正式这样一个过程，用户的状态也就得以保持了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[页面“宠物仓鼠”的实现]]></title>
      <url>%2F2017%2F08%2F19%2F%E9%A1%B5%E9%9D%A2%E2%80%9C%E5%AE%A0%E7%89%A9%E4%BB%93%E9%BC%A0%E2%80%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[上面这只仓鼠是怎么弄到页面上的，完全可以拿来当桌面宠物。怎么做到的？ 这是官方网站,进去后，直接复制这个框中的代码到html页面就行了。就是这么简单。 另外，点击“edit settings”还能自定义这只老鼠。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对于input的name和value]]></title>
      <url>%2F2017%2F08%2F19%2F%E5%AF%B9%E4%BA%8Einput%E7%9A%84name%E5%92%8Cvalue%2F</url>
      <content type="text"><![CDATA[给input添加readonly=&quot;readonly&quot;使input变成只读 type=”text” input type=”text”表单发回给后端的键是”name” type=”checkbox” input type=”checkbox”,后台读的是”value”,”name”是后台识别这组多选框的基准 input的checkbox类型，提交之后，name和value在后台是都可以读到的，只是name拿来当这个总的多选表单的名字，value则当成各个多选框自己的名字，当然这时我们自己定的，各个多选框的name值可以不同。 type=”radio” 而对于input的radio单选类型,同一部分单选的name就应该相同了（value值来表示各个单选框的值），不然会导致不能实现单选的效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML Meta中添加X-UA-Compatible和IE=Edge，chrome=1的作用]]></title>
      <url>%2F2017%2F08%2F19%2FHTML-Meta%E4%B8%AD%E6%B7%BB%E5%8A%A0X-UA-Compatible%E5%92%8CIE-Edge%EF%BC%8Cchrome-1%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
      <content type="text"><![CDATA[这是一个，文档兼容模式的定义。 Edge 模式告诉 IE 以最高级模式渲染文档，也就是任何 IE 版本都以当前版本所支持的最高级标准模式渲染，避免版本升级造成的影响。简单的说，就是什么版本 IE 就用什么版本的标准模式渲染。 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; 使用以下代码强制 IE 使用 Chrome Frame 渲染 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;chrome=1&quot;&gt; 提示 IE 用户安装 Google Frame Google 官方提供了对 Google Frame 插件安装情况的检测，这里直接调用方法即可，如果检测到 IE 并未安装 Google Frame，则弹出对话框提示安装。 CFInstall.check();最佳的兼容模式方案，结合考虑以上两种： &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery常用函数]]></title>
      <url>%2F2017%2F08%2F19%2FjQuery%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[jQuery是一个包含DOM操作、事件处理、动画和Ajax功能的库，严格来说它不算一个框架。 $.trim()是jQuery提供的函数,用于去掉字符串首尾的空白字符，返回字符串 $(‘#search-btn’).keyup(),这是jQuery的选择器，keyup指按钮按下后，松手的那个事件。 jQuery的show()方法，与hide()对相应，用来显示和隐藏选中的元素 $(‘#username’).val()，提取某个id里面的数据 $(‘#username’).blur(…);在’#username’失去焦点的时候，做blur里面的内容，比如’#username’是个输入框 学习代码(siblings可以理解成匹配其括号内的元素)： 1$('.step-username').hide().siblings('.step-question').show(); $().html();html() 方法返回或设置被选元素的内容 (inner HTML),如果该方法未设置参数，则返回被选元素的当前内容 jQuery hasClass()方法：被选元素是否包含指定的类名称。如果被选元素包含指定的类，该方法返回 “true”。 jQuery addClass()方法：向被选元素添加一个或多个类。该方法不会移除已存在的 class 属性，仅仅添加一个或多个 class 属性。 jQuery removeClass()方法：从被选元素移除一个或多个类。注释：如果没有规定参数，则该方法将从被选元素中删除所有类。 jQuery html() 方法: html() 方法设置或返回被选元素的内容（innerHTML）。 当该方法用于返回内容时，则返回第一个匹配元素的内容。 当该方法用于设置内容时，则重写所有匹配元素的内容。 jQuery.extend()方法：用于将一个或多个对象的内容合并到目标对象。$.extend( target [, object1 ] [, objectN ] ) jQuery on() 方法：在被选元素及子元素上添加一个或多个事件处理程序。自 jQuery 版本 1.7 起，on() 方法是 bind()、live() 和 delegate() 方法的新的替代品。 注意：使用 on() 方法添加的事件处理程序适用于当前及未来的元素（比如由脚本创建的新元素）。 提示：如需移除事件处理程序，请使用 off() 方法。 提示：如需添加只运行一次的事件然后移除，请使用 one() 方法。 $(document).on(‘click’, ‘.cart-select’, function(){});表示给.cart-select绑定一个点击事件，执行的函数是function。 jQuery的parents():获得当前匹配元素集合中每个元素的祖先元素 如果只是想直接指向其父级元素的话，可以直接使用parent()，什么参数都不加 如果想沿着父级一直往上找，这时应用parents()，带参数 jQuery的data() 方法向被选元素附加数据，或者从被选元素获取数据 附加数据时：$(selector).data(name,value)。 name 必需。规定要设置的数据的名称。value 必需。规定要设置的数据的值。 其中data在html中存储的方式即为data-*属性，data-后面的即为name,值即为value jQuery的is() 根据选择器、元素或 jQuery 对象来检测匹配元素集合，如果这些元素中至少有一个元素匹配给定的参数，则返回 true。 语法：.is(selector) $(“input[type=’checkbox’]”) $(this) 12345$(document).ready(function()&#123; $("p").click(function()&#123; $(this).hide();//$(this)是在方法click内，此处的$(this)表示的是当前调用click方法的对象$("p")，就是表示当前对象，当前调用该方法的对象 &#125;); &#125;); jQuery find() 方法获得当前元素集合中每个元素的后代。 $(&quot;p&quot;).find(&quot;span&quot;).css(&#39;color&#39;,&#39;red&#39;); jQUery empty() 方法从被选元素(包括被选元素)移除所有内容，包括所有文本和节点。 jQuery val() 方法返回或设置被选元素的值。如果该方法未设置参数，则返回被选元素的当前值 jQuery attr() 方法设置或返回被选元素的属性值。例：$orderNumber.attr(&#39;href&#39;,$orderNumber.attr(href) + orderNumber); jQuery get() 方法:$.get(URL,data,function(data,status,xhr),dataType) URL：请求的地址 data:可选。规定连同请求发送到服务器的数据。 function:可选。规定当请求成功时运行的函数。 dataType: 可选。规定预期的服务器响应的数据类型。 jQuery attr() 方法：attr() 方法设置或返回被选元素的属性值。–$(selector).attr(attribute) 这东西也可以用来直接添加属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git操作注意点]]></title>
      <url>%2F2017%2F08%2F19%2Fgit%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
      <content type="text"><![CDATA[分支提交注意点 对于在自己分支上开发的，提交时应该 先执行git merge origin master 为了方便以后找某个分支的提交，可以打个tag:git tag tag-dev-initial(tag的用法一般在大版本的时候才会打) git push origin tag-dev-initial 给项目打tag 想给git打个tag，可以在分支git add\commit\push之后，再git tag 标签名，git push origin 标签名。中间没变化也可以打。 版本退回 版本退回；git reset --hard commit_id 更改提交时写的注释（最近一次） git commit --amend可以修改最近一次提交的记录的注释信息。 合并分支(自己能操作主分支时) git在分支（比如：ltt）上完成工作后，要合并分支 先切换回主分支：git checkout master 合并分支内容到主分支: git merge ltt 提交到远程仓库： git push origin master 删除分支：git barnch -d ltt 提交合并分支请求（自己没有操作主分支的权利） 要有个习惯：git合并分支之前先merge master，然后再pull request]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端解决跨域问题的几种方法]]></title>
      <url>%2F2017%2F08%2F19%2F%E5%89%8D%E7%AB%AF%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[好文学习： 前端解决跨域问题的8种方案 同源策略：所谓同源是指，域名，协议，端口相同。JS只能与同一个域中的页面进行通讯。 域名（子域或者主域）、端口、协议 有一个不同就意味着是不同域。不同域的js不能访问另一个的cookie,接收它的HTTP响应等(但它可以向任何其他源发送HTTP请求);AJAX 和 webservice 也受此策略管束.这种手段就叫同源策略; 注意： 如果是协议和端口造成的跨域问题“前台”是无能为力的， 在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。 “URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。 document.domain + iframe (只有在主域相同的时候才能使用该方法)在www.a.com/a.html中： 12345678910document.domain = 'a.com';var ifr = document.createElement('iframe');ifr.src = 'http://www.script.a.com/b.html';ifr.display = none;document.body.appendChild(ifr);ifr.onload = function()&#123; var doc = ifr.contentDocument || ifr.contentWindow.document; //在这里操作doc，也就是b.html ifr.onload = null;&#125;; 在www.script.a.com/b.html中： 1document.domain = 'a.com'; 动态创建script因为script标签不受同源策略的限制。 location.hash + iframe原理是利用location.hash来进行传值。 假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息。 cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面 cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据 同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一旦有变化则获取获取hash值 注：由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe window.name + iframewindow.name 的美妙之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 postMessage（HTML5中的XMLHttpRequest Level 2中的API） a.com/index.html中的代码： 123456789&lt;iframe id="ifr" src="b.com/index.html"&gt;&lt;/iframe&gt;&lt;script type="text/javascript"&gt;window.onload = function() &#123; var ifr = document.getElementById('ifr'); var targetOrigin = 'http://b.com'; // 若写成'http://b.com/c/proxy.html'效果一样 // 若写成'http://c.com'就不会执行postMessage了 ifr.contentWindow.postMessage('I was there!', targetOrigin);&#125;;&lt;/script&gt; b.com/index.html中的代码： 12345678910&lt;script type="text/javascript"&gt; window.addEventListener('message', function(event)&#123; // 通过origin属性判断消息来源地址 if (event.origin == 'http://a.com') &#123; alert(event.data); // 弹出"I was there!" alert(event.source); // 对a.com、index.html中window对象的引用 // 但由于同源策略，这里event.source不可以访问window对象 &#125; &#125;, false);&lt;/script&gt; CORSCORS背后的思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 IE中对CORS的实现是xdr1234567var xdr = new XDomainRequest();xdr.onload = function()&#123; console.log(xdr.responseText);&#125;xdr.open('get', 'http://www.baidu.com');......xdr.send(null); 其它浏览器中的实现就在xhr中1234567891011var xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123; if(xhr.readyState == 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 304 || xhr.status == 304)&#123; console.log(xhr.responseText); &#125; &#125;&#125;xhr.open('get', 'http://www.baidu.com');......xhr.send(null); 实现跨浏览器的CORS12345678910111213141516171819function createCORS(method, url)&#123; var xhr = new XMLHttpRequest(); if('withCredentials' in xhr)&#123; xhr.open(method, url, true); &#125;else if(typeof XDomainRequest != 'undefined')&#123; var xhr = new XDomainRequest(); xhr.open(method, url); &#125;else&#123; xhr = null; &#125; return xhr;&#125;var request = createCORS('get', 'http://www.baidu.com');if(request)&#123; request.onload = function()&#123; ...... &#125;; request.send();&#125; JSONPJSONP包含两部分：回调函数和数据。 回调函数是当响应到来时要放在当前页面被调用的函数。 数据就是传入回调函数中的json数据，也就是回调函数的参数了。 web socketsweb sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用) web sockets原理：在js创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协 只有在支持web socket协议的服务器上才能正常工作。 12345var socket = new WebSockt('ws://www.baidu.com');//http-&gt;ws; https-&gt;wsssocket.send('hello WebSockt');socket.onmessage = function(event)&#123; var data = event.data;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[块级元素与行内元素]]></title>
      <url>%2F2017%2F08%2F19%2F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E4%B8%8E%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[行内元素和块级元素 块级元素：div , p , form, ul, li , ol, dl, form, address, fieldset, hr, menu, table,h1~h6 行内元素：span, strong, em, br, img , input, label, select, textarea, cite, 注意 块级元素可以设置 width, height属性，行内元素设置width, height无效 块级元素可以设置margin 和 padding。内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果。（水平方向有效，竖直方向无效）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[清除浮动的几种方法]]></title>
      <url>%2F2017%2F08%2F19%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[好文学习 ：伪类:after清除浮动的原理和方法 方法一：添加空元素就是在浮动元素下方添加一个非浮动元素。 缺陷：这种方法比较简单，但是要在页面中增加冗余标签，违背了语义网的原则。 方法二：浮动元素的自动clearing给父元素添加：overflow:hidde 关于为何父容器可以自动识别：由于加上overflow:hidden之后要计算超出的大小来隐藏，所以父容器会自动撑开自己把所有的子元素放进去，同时会计算浮动的子元素。 缺点：一个是IE 6不支持，另一个是一旦子元素的大小超过父容器的大小，就会出显示问题。 方法三：使用:after伪类 :after作用是：选择器在被选元素的内容后面插入内容。 123456.clearfix:after &#123;content: "\0020";display: block;height: 0;clear: both;&#125; “clearfix”是父容器的class名称，”content:”020”;”是在父容器的结尾处放一个空白字符，”height: 0;”是让这个这个空白字符不显示出来，”display: block; clear: both;”是确保这个空白字符是非浮动的独立区块。 缺点：:after选择符IE 6不支持，也就是说上面的这段代码在IE 6中无效 解决方法：IE 6的独有命令”zoom:1;”IE 6的独有命令”zoom:1;”，这条命令的作用是激活父元素的”hasLayout”属性，让父元素拥有自己的布局。IE 6会读取这条命令，其他浏览器则会直接忽略它。 123456789.clearfix:after &#123;content: "\0020";display: block;height: 0;clear: both;&#125;.clearfix &#123;zoom: 1;&#125; 插一句：（还能用table的方法来创建BFC达到清除浮动的目的）（这个方法还能防止顶部的空白崩溃–margin-top和margin-bottom重叠问题） 附录：什么是hasLayoutIE使用Layout概念来控制元素的尺寸和位置。如果一个元素有Layout，它就有自身的尺寸和位置；如果没有，它的尺寸和位置由最近的拥有布局的祖先元素控制。 在默认情况下，拥有Layout的元素包括： 123456789101112131415161718&lt;html&gt;, &lt;body&gt;&lt;table&gt;, &lt;tr&gt;, &lt;th&gt;, &lt;td&gt;&lt;img&gt;&lt;hr&gt;&lt;input&gt;, &lt;button&gt;, &lt;select&gt;, &lt;textarea&gt;, &lt;fieldset&gt;, &lt;legend&gt;&lt;iframe&gt;, &lt;embed&gt;, &lt;object&gt;, &lt;applet&gt;&lt;marquee&gt;（注意，&lt;p&gt;和&lt;div&gt;默认不拥有Layout。）凡是具有以下CSS属性的元素，也会拥有布局：position: absolutefloat: left|rightdisplay: inline-blockwidth: any value other than &apos;auto&apos;height: any value other than &apos;auto&apos;zoom: any value other than &apos;normal&apos; （IE专用属性）writing-mode: tb-rl（IE专用属性）overflow: hidden|scroll|auto（只对IE 7及以上版本有效）overflow-x|-y: hidden|scroll|auto（只对IE 7及以上版本有效） hasLayout是IE特有的属性，不是CSS属性。可以用JavaScript函数hasLayout查看一个元素是否拥有Layout。如果有，这个函数就返回true；否则返回false。hasLayout是一个只读属性，所以无法使用JavaScript进行设置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[导航栏二级弹出菜单实现]]></title>
      <url>%2F2017%2F08%2F14%2F%E5%AF%BC%E8%88%AA%E6%A0%8F%E4%BA%8C%E7%BA%A7%E5%BC%B9%E5%87%BA%E8%8F%9C%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[效果一级菜单列表： 当鼠标放上去后，显示二级菜单，移开后二级菜单消失: 代码HTML代码123456789101112131415161718192021222324252627282930313233343536&lt;div id="menu"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;11111&lt;/a&gt; &lt;ul&gt; &lt;li&gt;1-1&lt;/li&gt; &lt;li&gt;1-2&lt;/li&gt; &lt;li&gt;1-3&lt;/li&gt; &lt;li&gt;1-4&lt;/li&gt; &lt;li&gt;1-5&lt;/li&gt; &lt;li&gt;1-6&lt;/li&gt; &lt;li&gt;1-7&lt;/li&gt; &lt;li&gt;1-8&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;22222&lt;/a&gt; &lt;ul&gt; &lt;li&gt;2-1&lt;/li&gt; &lt;li&gt;2-2&lt;/li&gt; &lt;li&gt;2-3&lt;/li&gt; &lt;li&gt;2-4&lt;/li&gt; &lt;li&gt;2-5&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;33333&lt;/a&gt; &lt;ul&gt; &lt;li&gt;3-1&lt;/li&gt; &lt;li&gt;3-2&lt;/li&gt; &lt;li&gt;3-3&lt;/li&gt; &lt;li&gt;3-4&lt;/li&gt; &lt;li&gt;3-5&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;44444&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;55555&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; less代码1234567891011121314151617181920212223242526272829303132333435363738394041body&#123; font-family: sans-serif; font-size: 12px; line-height: 1.5;&#125;#menu ul&#123; margin:0; padding:0; list-style:none; border: 1px solid #ccc; width: 100px; li&#123; text-align: center; position:relative; background-color: #eeeeee; height: 26px; line-height: 26px; border-bottom: 1px solid #cccccc; a&#123; color:#000; text-decoration: none; &amp;:hover&#123; color: #ff0000; &#125; &#125; ul&#123; position: absolute; left: 100px; top: 0px; display: none; &#125; &amp;.current ul&#123; display: block; &#125; &#125;&#125; JavaScript代码1234567891011121314151617startList = function () &#123; var navRoot = document.getElementById('menu'); var ali = navRoot.getElementsByTagName('li'); for(var i=0;i&lt;ali.length;i++)&#123; var node = ali[i]; //鼠标在上面时添加current属性，一二级菜单都有 node.onmouseover = function () &#123; this.className += 'current'; &#125; //鼠标出去时移除current属性 node.onmouseout = function () &#123; this.className = this.className.replace('current',''); &#125; &#125;&#125;window.onload = startList(); 要点 首先让二级菜单隐藏： ul {display: none;}，然后css中写一个有’current’类名的li(第一层)，样式为ul li.current {display: block;},这个属性将通过js添加，即鼠标在上面的时候有这个属性，鼠标移出之后，没有这个属性（当然设置了之后，还得写个清除的句子） 如果按html中的摆放的话，会出现，一级菜单与二级菜单错位的情况，这需要通过设置css.让一级菜单的li为相对定位，二级菜单的ul绝对定位到一级菜单li的右边。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代理服务器在开发时的作用]]></title>
      <url>%2F2017%2F07%2F29%2F%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8%E5%BC%80%E5%8F%91%E6%97%B6%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
      <content type="text"><![CDATA[代理服务器的原理 劫持的效果是，你输入的是a.com的域名，得到的却是b.com的内容 代理服务器在开发时的作用 我们在开发时一般会在本地启一个本地服务器用来放置我们的静态资源，比如localhost:8080，用来处理html、js、image。但我们使用的后端接口一般不和前端服务器放在一起，比如后端接口放在api.happymmall.com上，开发时用localhost的域名请求api.happymmall.com上的接口时，就会造成跨域问题，解决这个问题的一个方法是使用代理服务器：先让所有的请求都通过localhost的域名走到代理服务器上，静态资源就原样的请求到localhost的域名上，然后对后端接口做一个劫持，把接口的地址由localhost改成api.happymmall.com,这样我们请求的所有资源都会是localhost,不会存在跨域的问题。但是接口通过劫持以后已经走到了后端环境上。这样我们即请求了同域下的地址，还能得到其他域下的数据，这样就完美的解决了开发时的跨域问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前后端分离的两种方案]]></title>
      <url>%2F2017%2F07%2F29%2F%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88%2F</url>
      <content type="text"><![CDATA[velocity是在node和java下都可以编译的页面模板，开发时放到前端的目录下，发布把模板发布到后端的模板目录下。这样开发时就做到了完全分离。 这种方式的好处就是就是线上模板还是由Java来做。形成的是带有动态数据的html,比较有利于SEO。但这种方式下，前端的开发环境和系统的复杂度都相对较高。单纯的前端改动也要带着后端一起发布。 这是一种纯静态的前后端分离方案。 纯静态的HTMl模板全放在前边，数据完全通过接口来交互。这样前后端就完全分开了，脱离了后端的模板。 系统复杂度比第一种低。、 缺点在于，所有的页面数据都由JS渲染，没有动态模板，扎样不利于SEO。这样的不足可以使用nodejs的Server Render或着给蜘蛛做一套定制页面来解决。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决a标签链接为空时跳转到页首问题]]></title>
      <url>%2F2017%2F07%2F27%2F%E8%A7%A3%E5%86%B3-a-%E6%A0%87%E7%AD%BE%E9%93%BE%E6%8E%A5%E4%B8%BA%E7%A9%BA%E6%97%B6%E8%B7%B3%E8%BD%AC%E5%88%B0%E9%A1%B5%E9%A6%96%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[一般在写页面的时候，对于链接目的地还未确定的标签，我们一般会在其href属性上添加“#”来表示其为空链接，像下面这样： 1&lt;a href="#"&gt;测试&lt;/a&gt; 但这会导致我们在点击这个链接的时候，页面自动跳转到页面的首部位置，这跟就空着href，不写#的效果是一样的。则很明显不是我们想要的，怎么解决？ 用javascript:void (0)替换#即可。 1&lt;a href="javascript:void (0);"&gt;测试&lt;/a&gt; 这样就页面就不会乱动了，问题解决。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用CSS画三角形]]></title>
      <url>%2F2017%2F07%2F24%2F%E7%94%A8CSS%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
      <content type="text"><![CDATA[想法是：对于一个“div”标签，一般是有宽（width）和高（height）以及边框的，如果我们保持这个div的边框大小不变，逐渐缩小width和height，最终结果会怎么样？，没错变成下面这样，宽高汇成中间一点，边框变成四个三角形，这样我们只要使想要显示的那个三角形有颜色和样式，另外三个设置成透明不就可以了。 上代码： HTML代码： 1&lt;div class="triangle"&gt;&lt;/div&gt; CSS代码： 12345678910111213141516.triangle&#123; width:0; height:0; /* IE6最小高度的问题 */ overflow:hidden; border-width:50px; /*要显示的边设置为想要的颜色，其他边设置成透明*/ border-color:transparent transparent red transparent; /* 将其他边的样式设置成虚线， 解决IE6其他边显示为黑色的问题 */ border-style:dashed dashed solid dashed;&#125; 注意里面的注释 结果为：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo实现文章置顶功能]]></title>
      <url>%2F2017%2F07%2F23%2FHexo%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6%E5%8A%9F%E8%83%BD%2F</url>
      <content type="text"><![CDATA[网上教程还是挺多的，但难免有不清楚的地方，我根据我自身的情况说一下吧，基本上是根据下面这个博文来的。 链接 主要想说明的是，我的hexo版本是3.3.1，在node_modules/hexo-generator-index/lib/generator.js那块，原始代码跟上面博文提供的有出入，要做的是，那下面这段代码直接把原始代码覆盖掉就行了。 123456789101112131415161718192021222324252627282930313233'use strict';var pagination = require('hexo-pagination');module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 保存后，在文章的front-matter中添加top: 1这一样就可以实现文章置顶了，“1”也可以用其他数字替换，数字越大，越前面。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript对象分类]]></title>
      <url>%2F2017%2F07%2F22%2FJavaScript%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[JS中，将对象分为3类： 内部对象 宿主对象 自定义对象 内部对象内部对象包括Arguments(函数参数集合)、Array、Boolean、Date、Function、Global、Math、Number、Object、RegExp、String以及各种错误类对象。 Error EvalError RangeError ReferenceError SyntaxError TypeError 其中Global和Math这两个对象又被称为“内置对象”，这两个对象在脚本程序初始化是被创建，不必实例化这两个对象。 宿主对象宿主对象就是执行JS甲苯的环境提供的对象。 对于嵌入到网页中的JS来说，其宿主对象就是浏览器提供的对象，所以有称为浏览器对象，如：IE、FireFox等浏览器提供的对象。 不同浏览器提供的宿主对象可能不同，即使提供的对象相同，其实现方式也大相径庭。这回带来浏览器兼容问题，增加开发难度。 浏览器对象很多，比如： Window Document Element form image等等 自定义对象顾名思义，就是开发人员自己定义的对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[形参与实参 传值调用和引用调用]]></title>
      <url>%2F2017%2F07%2F22%2F%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82-%E5%BC%95%E7%94%A8%E8%B0%83%E7%94%A8%E5%92%8C%E4%BC%A0%E5%80%BC%E8%B0%83%E7%94%A8%2F</url>
      <content type="text"><![CDATA[形参与实参 形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用。 实参出现在主调函数中，进入被调函数后，实参变量也不能使用 形参和实参的功能是作数据传送。发生函数调用时，主调函数把实参的值传送给被调函数的形参从而实现主调函数向被调函数的数据传送。 形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。 实参可以是常量、变量、表达式、函数等,无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。 实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。 函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。而如果函数的参数是指针类型变量,在调用该函数的过程中，传给函数的是实参的地址，在函数体内部使用的也是实参的地址，即使用的就是实参本身。所以在函数体内部可以改变实参的值。（这涉及到的就是传值调用与引用调用的区别） 传值调用和引用调用传值调用和引用调用指的是用于参数传递过程中的一种机制 传值调用中，只使用了实参的值。传值调用机制里，形参是一个局部变量，其初始值为相应实参的值 引用调用机制里，将实参的地址传递给形参，从表面上看是以实参变量取代形参，因此任何发生在形参上的改变实际上都发生在实参变量上 看一个C语言的例子： 12345678910111213void Modify(int p, int * q)&#123; p = 27; // 按值传递 - p是实参a的副本, 只有p被修改 *q = 27; // q是b的引用，q和b都被修改&#125;int main()&#123; int a = 1; int b = 1; Modify(a, &amp;b); // a 按值传递, b 按引用传递, // a 未变化, b 改变了 return(0);&#125; JavaScript的按值传递和引用传递分别对应传值调用和引用调用，说法不一样而已 JS的基本类型，是按值传递的： 123456var a = 1;function foo(x) &#123; x = 2;&#125;foo(a);console.log(a); // 仍为1, 未受x = 2赋值所影响 值得注意的是JS的对象,下面两个例子： 123456var obj = &#123;x : 1&#125;;function foo(o) &#123; o.x = 3;&#125;foo(obj);console.log(obj.x); // 3, 被修改了! 123456var obj = &#123;x : 1&#125;;function foo(o) &#123; o = 100;&#125;foo(obj);console.log(obj.x); // 仍然是1, obj并未被修改为100. 这是为什么？ 对象的参数传递是按值传递的，只不过由于对象是引用类型，所以他的按值传递看起来就像按引用传递一样。本质上，对象的按值传递就是对象的复制，JavaScript中对象的复制就像C中的指针复制。你可以在函数内部将参数重新赋值new Object()，发现参数会指向这个new Object，而外部的对象的指向不是这个new Object()。所以，对象的参数产地绝对不是按引用传递。 参考地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[响应式Web基础概念]]></title>
      <url>%2F2017%2F07%2F20%2F%E5%93%8D%E5%BA%94%E5%BC%8FWeb%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[响应式Web设计主要包括 流式布局：布局方式以百分比为主，比如Bootstrap移动设备优先的流式栅格系统 媒体查询：查询设备的各种属性值，比如：设备类型、分辨率、屏幕物理尺寸及色彩等 弹性图片：让图片可以根据视窗自适应展示。这里的图片包括：图片、图标、图标及视频等。 基于上述工具进行响应式Web设计，可以采用的设计模式有： 设备优先 移动优先：此模式让我们优先考虑网站最重要的部分，即要展示主要内容。某些时候，移动优先与“内容优先”同义，或者说，移动网站策略就是内容策略。 关键特性如果没有以下这两个特性，响应式Web将不复存在： 媒体查询 断点]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[盒模型]]></title>
      <url>%2F2017%2F07%2F20%2F%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[块级元素的总宽度=左右padding+左右border+内容区width 我们设置的width实际是内容区（content）的width，所以当改变padding、border、width中的任何一项的时候，块元素的总宽度都会发生变化。 关于margin和padding颜色的问题1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body&#123; background-color: yellow; &#125; #contain&#123; vertical-align: middle; width: 100px; height: 100px; margin: 100px auto; padding: 20px; border: solid 5px red; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="contain"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结果为： 可以看出： margin的颜色是父级块的背景颜色 padding的颜色是块本身的背景颜色 同样的道理，块的背景图片是可以延伸到padding区域的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS Sprites简介]]></title>
      <url>%2F2017%2F07%2F17%2FCSS-Sprites%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[简介CSS Sprites在国内很多人叫css精灵，是一种网页图片应用处理方式。它允许将一个页面涉及到的所有零星图片都包含到一张大图中， 利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位， 访问页面时避免图片载入缓慢的现象。 优点 利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字精确的定位出背景图片的位置 利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能，这也是CSS Sprites最大的优点，也是其被广泛传播和应用的主要原因 CSS Sprites能减少图片的字节，曾经比较过多次3张图片合并成1张图片的字节总是小于这3张图片的字节总和 解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名，从而提高了网页的制作效率 更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。维护起来更加方便 缺点 图片合并麻烦：图片合并时，需要把多张图片有序的合理的合并成一张图片，并留好足够的空间防止版块出现不必要的背景 图片适应性差：在高分辨的屏幕下自适应页面，若图片不够宽会出现背景断裂 图片定位繁琐：开发时需要通过工具测量计算每个背景单元的精确位置 可维护性差：页面背景需要少许改动，可能要修改部分或整张已合并的图片，进而要改动css。在避免改动图片的前提下，又只能（最好）往下追加图片，但这样增加了图片字节 使用 通过ps等具有相同功能的工具将图片合理的集合到一张图片上 在给要显示图片的块添加overflow:hidden属性，以及设置好宽高（width和height），这相当于实现了对图片的切割。注意：overflow这个属性是可以继承的，所以在用到一个图片由多个图片块合成的时候，可以直接在最外面的包含块设置overflow:hidden即可 通过上面的那个切割和CSS的定位技术，把大图中的各个小图精准的分散到各个需要的地方去。 可行具体的步骤可以是： 首先定义块的属性，主要有： width height position:absolute overflow:hidden background:url(图片地址) no-repeat 如果采用的包含元素不是块，还应采用display:block来将其转变为块 定位块的位置，即把块移动到页面中要显示图片的那个位置（注意我们上面采用的是absolute绝对定位） top left bottom right 现在图片包含块的属性、用什么背景以及块的位置都已经弄好了，开始移动背景的位置，即确定要显示背景图片的哪些内容 background-position,默认是（左，上），左上角为（0,0），即若定位图片右下角的块，则应为（负值、负值） 该属性的可能值为： 参考地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[call与apply的区别]]></title>
      <url>%2F2017%2F07%2F17%2Fcall%E4%B8%8Eapply%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[call与apply都属于Function.prototype的一个方法，所以每个function实例都有call、apply属性 相同点:两个方法产生的 作用是完全一样的 不同点:方法接收的参数不同 call, apply方法它们除了第一个参数,即执行时上下文对象相同外,call方法的其它参数将依次传递给借用的方法作参数,而apply就两个参数,第二个参数为一个数组传递 示例： 123456function add(c, d)&#123;return this.a + this.b + c + d;&#125;var o = &#123;a:1, b:3&#125;;add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用js跨域获取数据的可行方法]]></title>
      <url>%2F2017%2F07%2F17%2F%E4%BD%BF%E7%94%A8js%E8%B7%A8%E5%9F%9F%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E8%A1%8C%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[CORSCORS（Corss-Origin Resource Sharing,跨资源共享），基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应的成功或失败。即给请求附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部决定是否给予响应。 document.domain将页面的document.domain设置为相同的值，页面间可以互相访问对方的JavaScript对象。 注意： 不能将值设置为URL中不包含的域； 松散的域名不能再设置为紧绷的域名。 图像Ping12345var img=new Image();img.onload=img.onerror=function()&#123;... ...&#125;img.src="url?name=value"; 请求数据通过查询字符串的形式发送，响应可以是任意内容，通常是像素图或204响应。 图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。 缺点： 只能发送GET请求； 无法访问服务器的响应文本，只能用于浏览器与服务器间的单向通信。 Jsonp123var script=document.createElement("script");script.src="url?callback=handleResponse";document.body.insertBefore(script,document.body.firstChild); JSONP由两部分组成：回调函数和数据 回调函数是接收到响应时应该在页面中调用的函数，其名字一般在请求中指定。 数据是传入回调函数中的JSON数据。 优点： 能够直接访问响应文本，可用于浏览器与服务器间的双向通信。 缺点： JSONP从其他域中加载代码执行，其他域可能不安全。 难以确定JSONP请求是否失败。 CometComet可实现服务器向浏览器推送数据。 Comet是实现方式：长轮询和流 短轮询即浏览器定时向服务器发送请求，看有没有数据更新。 长轮询即浏览器向服务器发送一个请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又向服务器发起一个新请求。其优点是所有浏览器都支持，使用XHR对象和setTimeout()即可实现。 流即浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据，页面的整个生命周期内只使用一个HTTP连接。 WebSocketWebSocket可在一个单独的持久连接上提供全双工、双向通信。 WebSocket使用自定义协议，未加密的连接时ws://；加密的链接是wss://。 123456var webSocket=new WebSocket("ws://");webSocket.send(message);webSocket.onmessage=function(event)&#123;var data=event.data;... ....&#125; 注意： 必须给WebSocket构造函数传入绝对URL； WebSocket可以打开任何站点的连接，是否会与某个域中的页面通信，完全取决于服务器； WebSocket只能发送纯文本数据，对于复杂的数据结构，在发送之前必须进行序列化JSON.stringify(message))。 优点： 在客户端和服务器之间发送非常少的数据，减少字节开销。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[static、absolute、fixed、relative的区别]]></title>
      <url>%2F2017%2F07%2F17%2Fstatic%E3%80%81absolute%E3%80%81fixed%E3%80%81relative%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[在html中网页可以看成一个立体的空间，一个完整的页面是由很多个页面堆积形成的，如下图所示 CSS中Position属性的四个可选值：static、absolute、fixed、relative有什么区别？ position:static 无定位 所有元素定位的默认情况，在一般情况下，我们不需要特别的去声明它 但有时候遇到继承的情况，我们不愿意见到元素所继承的属性影响本身，从而可以用position:static取消继承，即还原元素定位的默认值 position:absolute 绝对定位 能够很准确的将元素移动到你想要的位置 position:fixed 相对于窗口的固定定位 元素的定位方式同absolute类似，但它的包含块是视区本身，相对于浏览器窗口进行定位。 在屏幕媒体如WEB浏览器中，元素在文档滚动时不会在浏览器视窗中移动 例如，它允许框架样式布局。在页式媒体如打印输出中，一个固定元素会出现于第一页的相同位置。这一点可用于生成流动标题或脚注 IE6不支持CSS中的position:fixed属性 position:relative 相对定位 相对定位是相对于元素默认的位置的定位 设置不同的值来声明定位在哪里，top、bottom、left、right四个数值配合，来明确元素的位置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js中undefined与null的区别]]></title>
      <url>%2F2017%2F07%2F17%2FJs%E4%B8%ADundefined%E4%B8%8Enull%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[undefined表示变量不含有值null表示变量的值为空，可以通过将变量的值设置为 null 来清空变量 例子： 123456var person;var car="Benz";document.write(person + "&lt;br /&gt;");document.write(car + "&lt;br /&gt;");var car=nulldocument.write(car + "&lt;br /&gt;"); 结果： undefined Benz null]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[笔试题之Js]]></title>
      <url>%2F2017%2F07%2F17%2F%E7%AC%94%E8%AF%95%E9%A2%98%E4%B9%8BJs%2F</url>
      <content type="text"><![CDATA[非读程序题flash和js通过什么类如何交互？Flash提供了ExternalInterface接口与JavaScript通信，ExternalInterface有两个方法，call和addCallback： ExternalInterface.addCallback(“在js里可调用的flash方法名”,flash内方法) //在flash中通过这个方法公开 在js中可调用的flash内的方法; ExternalInterface.call(“js方法”,传给js的参数) //在flash里调用js里的方法 Js中typeof运算符可能的结果 “symbol” typeof Symbol() “boolean” typeof Boolean() “undefined” typeof undefined “string” typeof String() “number” typeof Number() “object” typeof null typeof Object() “function” typeof Function() 不会产生NaN、null、array这样的结果 示例： 读程序题知识点：闭包、堆、栈123456789101112function Foo() &#123; var i = 0; return function() &#123; console.log(i++); &#125;&#125;var f1 = Foo(), f2 = Foo();f1();f1();f2(); 结果： 0 1 0 原因： Function是引用类型：保存在堆中，变量f1,f2是保存在栈中； 闭包：一个函数（产生新的作用域）定义的局部变量、子函数的作用域在函数内，但是一旦离开了这个函数，局部变量就无法访问，所有通过返回子函数到一个变量f1的方法，让f1指向堆中的函数作用域，这样可以使用局部变量i。 过程： 第一次f1() :f1=Foo()中，先执行Foo(): i = 0,return值返回给f1(f1指向子函数 f1()=function(){…..},因为子函数没有 定义i，所以向上找到父函数定义的 i: )并执行子函数 输出i=0,再自加 i =1(覆盖了父函数Foo 的 i值); 第二次f1() : 执行的是子函数 Function(){ ..},输出的是父函数 的 i=1,再自加 i =2; 第一次f2():同第一次f1(),不同的是 f2指向堆中一个新的对象 function(){ …},所有此i非彼i,输出i=0;如果再次f2(),那么和第二次f1(),一样输出i=1; 知识点：作用域 局部变量 全局变量12345(function()&#123; var a=b=5;&#125;)();console.log(b);console.log(a);//结果：5，ReferenceError 这里a是局部变量，b是全局变量，代码可改为： 1234var b=5;(function()&#123; var a=b;&#125;) 知识点：windows变量 全局变量1234if(! "a" in window)&#123; var a=1;&#125;alert(a);//结果弹出： undefined “!”的优先级高于”in” 知识点： setTimeout12windows.setTimeout(checkState,10000);//表示10秒后执行checkState这个函数windows.setTimeout(checkState(),10000);//先执行checkState，然后执行结果作为返回值传递给setTimeout 知识点：运算符 类型转换 对于第二条：第一个“+”2””中的“+”是正负运算，可以将非数字转换为数字 知识点：程序顺序1234567(function()&#123; var x=foo(); var foo=function foo()&#123; return "foobar"; &#125;; return x;&#125;)();//结果：类型错误 函数声明可以被提前，但函数表达式不能被提前，被提前的变量的默认值是undefined splice函数123var a=[1,2,3,4,5];a.splice(1,3,5,2,1,9);console.log(a); 结果：[1, 5, 2, 1, 9, 5] 原因：splice，前面1,3表示从下标为1（第二个）开始，即2开始，删除3个数，注意这里是从2开始删除，2也会被删掉，这样剩下[1,5]，然后将后面的数字从开始删除的位置加入到原数组当中。 零散知识点 var a=0;console.log(a++)=?console.log(++a)=? 结果：第一个为0，第二个为1 “每个对象都有prototype属性”这句话是错的。 比如var boj=Object.create(null),obj的原型是null，所以obj是没有prototype的。 ES6的基本数据类型为：Number、String、Null、Undefined、Symbol、Boolean。 使用typeof可以检测出变量的基本数据类型，但是有个特例，就是null，它的typeof返回的是object，这是javascript的历史bug。 原因请点这里 Null类型和Undefined类型都只有唯一值,分别是null和undefined ES5的基本数据类型有5种：Undefined、Null、String、Number、Boolean，ES6新增了一类数据类型：Symbol。Object是属于复杂数据类型，所以基本数据类型有6个：Number、String、Null、Undefined、Symbol、Boolean。 ECMAScript有5种原始类型（primitive type），即Undefined、Null、Boolean、Number和String 只要协议、域名、端口有任何一个不同, 都被当作是不同的域。 null是一种特殊的object,NaN是一种特殊的number Js没有块级作用域 Js没有函数重载的概念，在其他语言（比如java）中，可以存在同名函数，只要传入的参数数量或者类型不同即可。在Js中，定义了两个同名函数后，后面的函数会覆盖前面定义的函数。 * hasOwnProperty:是用来判断一个对象是否有你给出名称的属性或对象，不过需要注意的是，此方法无法检查该对象的原型链中是否具有该实行，该属性必须是对象本身的一个成员 isPrototypeOf:是用来判断要检查其原型链的对象是否存在于指定对象示例中，是则返回true,否则返回false SQL又称结构化查询语言 Java是强类型语言，JavaScript是弱类型语言 1&lt;&lt;4意思为：1*（2^4）=16，即想左移4位 “^”是异或运算 contextmenu是当浏览者按下鼠标右键出现菜单或者通过键盘的案件出发页面菜单时触发的事件。可以在页面中加入onContentMenu=”return false”就可以禁止使用鼠标右键了 JS声明变量的时候，如果不用var,则声明的是全局变量。 JS中入如果重复声明一个变量，比如：var a=10;var a=100;则a的值为100，如果var 1=100;var a;则a的值为100，var a;无效。 对于null、empty、0、false，Number默认把其转换为0,而对于undefined,Number则会将其转换为NaN JavaScript的保留字有aoto、abstract、implements、super等等，array不是保留字JS保留字 JS中由于变量内容不停，变量被分为基本数据类型和引用数据类型变量。 基本类型变量用8字节内存，存储基本数据类型（数值、布尔值、null和未定义）的值 引用类型变量则值保存对象、数组和函数等引用类型的值的引用（即内存地址） JS中数字是部分类型的，也就是没有byte/int/float/double等类型差异 var t={}; typeof t;返回值是object,注意不是Object typeof 是为了检查数据类型，instanceof是为了看一个变量是否是某个对象的实例。 object与Object的区别–链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[背景图片自适应]]></title>
      <url>%2F2017%2F07%2F16%2F%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
      <content type="text"><![CDATA[一张图拿来做某个块的背景图片。存在的问题是，当块大小发生变化（比如显示设备屏幕大小发生变化，假设块大小按百分比设置的）的时候，背景图片会发生变化，比如被截断什么的。这便是图片自适应的问题。 CSS3中提供了好的解决方法： 12background-image:url(/../);background-size:100% 100%;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[什么是package.json]]></title>
      <url>%2F2017%2F07%2F07%2F%E4%BB%80%E4%B9%88%E6%98%AFpackage-json%2F</url>
      <content type="text"><![CDATA[package.json描述了一个npm包的所有相关信息，包括作者、简介、包依赖、构建等信息。内容格式必须是严格的JSON格式。 通常我们在创建一个npm文件的时候会使用 npm init命令，通过交互式的命令生成一个package.json文件。这个文件的主要作用是记录了你这个项目所要用到的所有包的信息，当移动项目的时候，不需要移动包括的依赖包，这需要拷贝这个package.json就可以了，到时候在执行npm install命令就可以直接下载相应的包下来。 当然，如果你有一个新项目，还没有下载过任何的包，而需要的npm包跟想一个项目差不多，那你可以直接拷贝前一个项目的package.json文件到这个新项目文件夹下，执行npm install就可以了。 可以用npm安装的，安装的根目录都会有package.json这个文件以及依赖包存放的文件夹node_modules，比如grunt、vue、hexo、cnpm等等。因为这就是npm的一部分工作机制。 另外，有的项目的package.json文件里面会有dev这样的字段，是整个项目运行的入口，可以用npm run dev使项目运行起来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初识Vue]]></title>
      <url>%2F2017%2F07%2F06%2F%E5%88%9D%E8%AF%86Vue%2F</url>
      <content type="text"><![CDATA[环境：windows Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据 Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统 结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上 安装其实不需要安装的，想用的话，直接连接CDN或者用script标签引入vue.min.js就行了，这里安装的目的是为了使用Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。 用npm安装。npm版本需要高于3.0，低的可用cnpm install npm -g升级以下 cnpm install --global vue-cli全局安装vue-cli命令行工具 使用 创建一个基于 webpack 模板的新项目(本地不需要安装webpack),可以一路回车，注意目前node版本高于8.0.0的估计会出问题，推荐使用8.0.0版本vue init webpack my-project 进入my-project文件夹 cnpm install安装相关的依赖文件 cnpm run dev启动，这条命令的含义是关于npm run dev和build 浏览器访问localhost:8080就能看到初始界面 异常报空格数量错误初始化一个文件夹后，开始编辑里面的文件，会发现各种报空有关空格个数的错误，这是因为在Webpack 配置中使用了 eslint-loader，找到项目中build文件夹下的webpack.base.conf.js文件，将相关内容注释掉即可，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667var path = require('path')var utils = require('./utils')var config = require('../config')var vueLoaderConfig = require('./vue-loader.conf')function resolve (dir) &#123; return path.join(__dirname, '..', dir)&#125;module.exports = &#123; entry: &#123; app: './src/main.js' &#125;, output: &#123; path: config.build.assetsRoot, filename: '[name].js', publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath &#125;, resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src') &#125; &#125;, module: &#123; rules: [ /*&#123; test: /\.(js|vue)$/, loader: 'eslint-loader', enforce: 'pre', include: [resolve('src'), resolve('test')], options: &#123; formatter: require('eslint-friendly-formatter') &#125; &#125;,*/ &#123; test: /\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123; test: /\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test')] &#125;, &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125; ] &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一场由vue init webpack my-project引发的血案[未填坑]]]></title>
      <url>%2F2017%2F07%2F06%2F%E4%B8%80%E5%9C%BA%E7%94%B1vue-init-webpack-my-project%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88%2F</url>
      <content type="text"><![CDATA[先说一下，用的是windows系统。 最近打算学vue，于是乎，开始了自己的第一个vue项目之路。 首先来个vue init webpack my-project初始化个项目来瞧瞧它的结构，然而……，在project description那一直卡着，初始化失败。就这样踏上了踩坑的路程。 解决问题呗，查来查去，终于查到个有用的–vue搭建环境- vue init webpack my-project无响应。于是乎，知道问题出在哪了，node版本更新太快，而我的node由于换电脑，最近新装的是8.1.0版本的，估计功能还没完善。那就按上面那问题说的，降低node版本呗。 怎么退？那个问题里面回答的人也说了，用nvm。百度了以下，大概知道nvm是什么东西，大概流程就是安装nvm，然后用nvm安装各个版本的node，之后就可以通过nvm的命令随意在几个已经安装的node版本里面切换，听起来好像很爽，开始呗。 为了安全，把原本的node8.1.0卸载了，可是npm装的一些模块却忘了卸，没事，去把那个文件夹删了或者重命名为其它名字不就行了。问我在哪，好吧，一般默认全局安装的再者C:\Users\用户名\AppData\Roaming\npm\node_modules。 使用nvm开始安装呗。网上好吧，试了各种方法： github上的nvm的setup版本、noinstall版本 github上的所谓了中国用的nvmw版本 直接克隆仓库的版本 网上能找到的教程的方法基本上都用了，报错，各种出错，不能用。 用nvmw的时候，碰到下载地址不对的问题，issue那里已经有了解决方法，然而解决了还是没有用，地址是对了，却下不下来，在资源管理器那边眼睁睁的看着那文件夹（比如node8.0.0，那文件夹就是v8.0.0，这文件夹在nvm的文件夹下出现的）刚生成，然后马上又消失，终端提示下载失败。已经指定了淘宝镜像。没指定之前直接接不能下载。 要么是装上了，环境变量也都配了，nvm v查看版本也都没问题。但是下不下来，估计是国外的原因，添加国内镜像了，还是不行 要么下载过程中，不报错，也提示下载成功了，但是其实没有 这是离成功最近的一次，仰仗这哥们的博客链接。一切到好着，想下的node版本也都通过npm下载到本地了，可是，切换不了版本。。。应该是哪出问题了，以后想要填坑估计也得从这篇教程出发。 几近绝望，最后在搜的时候，发现除了nvm还有一个东西可以实现相同的功能，那就是n,好吧，转换阵地。 使用n怎么是使用？Node版本切换n，够简洁，就喜欢这种不拖泥带水的教程。 看得出，需要npm的支持才能安装n,咋办，先装个node的呗（别忘了我电脑原本的node已经被我卸了），装那个版本的，老老实实装8.0.0吧。 装完之后，npm install -g n开始安装，完成之后，输入n,有显示n的一些帮助信息，却没有显示的我已经安装的node版本，很明显我电脑现在是有一个node8.0.0的。没有。要不再试试安装node，运行n latest没用，失败。 弃了弃了能怎么办，很绝望啊。先留个坑吧，既然已经装了node8.0.0了，那运行最开始的vue init webpack my-project应该已经没问题了。直接试试吧。 配置淘宝镜像npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm install vue-cli -g全局安装vue命令行3.执行 vue init webpack my-project,成功了。。。 果然是node版本的问题。前前后后花了快一整天的时间，想一劳永逸来着，结果还是回到原点，卸载原本的node，安装node8.0.0，完成。可能就十几分钟的事。 有什么收获没有 对安装node更轻车熟路了 知道了npm默认模块默然全局安装的位置C:\Users\用户名\AppData\Roaming\npm\node_modules 知道了nvm、n这俩东西 知道了可以通过配置全局变量来省一些操作。比如：set &quot;NVMW_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node&quot;，这样的，可以直接在系统变量添加变量名为NVMW_NODEJS_ORG_MIRROR，值为https://npm.taobao.org/mirrors/node，就不用每次用的时候都set的一遍。 windows权限的问题，略坑，软件安装系统盘之前以该考虑的，不然你可能总会碰到access denied这样的错误，老得以管理员身份运行某些东西才行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML引入CSS的方法]]></title>
      <url>%2F2017%2F06%2F30%2FHTML%E5%BC%95%E5%85%A5CSS%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[行内式1&lt;div style="font-size:12px; text-align:center;"&gt;HTML中引用CSS的行内式方法&lt;/div&gt; 嵌入式1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta name="viewport" content="width=device-width" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; font-size: 12px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;HTML中引用CSS的嵌入式方法&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 链接式1&lt;link href="~/Content/Base.css" rel="stylesheet" type="text/css" /&gt; 导入式123&lt;style type="text/css"&gt; @import "/Content/Base.css"&lt;/style&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP状态码]]></title>
      <url>%2F2017%2F06%2F30%2FHTTP%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
      <content type="text"><![CDATA[百科讲解的挺详细 200 &amp; OK: 请求成功； 204 &amp; No Content: 请求处理成功，但没有资源可以返回； 206 &amp; Partial Content: 对资源某一部分进行请求(比如对于只加载了一般的图片剩余部分的请求)； 301 &amp; Move Permanently: 永久性重定向； 当网页A用301重定向转到网页B时，搜索引擎可以肯定网页A永久的改变位置，或者说实际上不存在了，搜索引擎就会把网页B当作唯一有效目标。 好处是：没有网址规范化问题。网页A的PR网页级别会传到网页B。 302 &amp; Found： 临时性重定向； 302转向可能会有URL规范化及网址劫持的问题。可能被搜索引擎判为可疑转向，甚至认为是作弊。关于通过302临时重定向实现网址劫持 303 &amp; See Other: 请求资源存在另一个URI，应使用get方法请求； 304 &amp; Not Modified: 服务器判断本地缓存未更新，可以直接使用本地的缓存； 307 &amp; Temporary Redirect: 临时重定向； 400 &amp; Bad Request: 请求报文存在语法错误； 401 &amp; Unauthorized: 请求需要通过HTTP认证； 403 &amp; Forbidden: 请求资源被服务器拒绝，访问权限的问题； 403：表示资源不可用。服务器理解客户的请求，但拒绝处理它，通常由于服务器上文件或目录的权限设置导致的WEB访问错误。 404 &amp; Not Found: 服务器上没有请求的资源； 500 &amp; Internal Server Error: 服务器执行请求时出现错误； 502 &amp; Bad Gateway: 错误的网关； 503 &amp; Service Unavailable: 服务器超载或正在维护，无法处理请求； 504 &amp; Gateway timeout: 网关超时； 附录PR网页级别 PR值全称为PageRank，用来表现网页等级的一个标准，级别分别是0到10，是Google用于评测一个网页“重要性”的一种方法。 Google排名运算法则（排名公式）的一部分，用来标识网页的等级/重要性。级别从0到10级，10级为满分。PR值越高说明该网页越受欢迎（越重要）。例如：一个PR值为1的网站表明这个网站不太具有流行度，而PR值为7到10则表明这个网站非常受欢迎（或者说极其重要）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[web工程零散知识点]]></title>
      <url>%2F2017%2F06%2F30%2Fweb%E5%B7%A5%E7%A8%8B%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
      <content type="text"><![CDATA[Servlet是什么？ Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果 架构： 主要任务 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务 SSH框架 struts+spring+hibernate的一个集成框架，是目前比较流行的一种Web应用程序开源框架 集成SSH框架的系统从职责上分为四层：表示层、业务逻辑层、数据持久层和域模块层 使用Struts作为系统的整体基础架构，负责MVC的分离，在Struts框架的模型部分，控制业务跳转 利用Hibernate框架对持久层提供支持，Spring做管理，管理struts和hibernate 具体做法是： 用面向对象的分析方法根据需求提出一些模型，将这些模型实现为基本的Java对象 然后编写基本的DAO(Data Access Objects)接口，并给出Hibernate的DAO实现 采用Hibernate架构实现的DAO类来实现Java类与数据库之间的转换和访问 最后由Spring做管理，管理struts和hibernate 业务流程 在表示层中，首先通过JSP页面实现交互界面，负责接收请求(Request)和传送响应(Response) 然后Struts根据配置文件(struts-config.xml)将ActionServlet接收到的Request委派给相应的Action处理 在业务层中，管理服务组件的Spring IoC容器负责向Action提供业务模型(Model)组件和该组件的协作对象数据处理(DAO)组件完成业务逻辑，并提供事务处理、缓冲池等容器组件以提升系统性能和保证数据的完整性 在持久层中，则依赖于Hibernate的对象化映射和数据库交互，处理DAO组件请求的数据，并返回处理结果 采用上述开发模型，不仅实现了视图、控制器与模型的彻底分离，而且还实现了业务逻辑层与持久层的分离。这样无论前端如何变化，模型层只需很少的改动，并且数据库的变化也不会对前端有所影响，大大提高了系统的可复用性。而且由于不同层之间耦合度小，有利于团队成员并行工作，大大提高了开发效率。 Structs 2 Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互 Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开 Structs与Servlet区别 servlet是javaEE基础的基础 Structs是框架，本质上相当于一个Servlet Hibernate 一个开放源代码的对象关系映射框架 将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用 Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任 Spring框架简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架 MVC Model View Controller，是模型(model)－视图(view)－控制器(controller)，一种软件设计典范 M是指业务模型，V是指用户界面，C则是控制器。C存在的目的则是确保M和V的同步，一旦M改变，V应该同步更新。 JSP 仅能作为表现层（View）技术，作用有两点： 负责收集用户请求参数 将应用的处理结果、状态数据呈现给用户 Servlet 则仅充当控制器（Controller）角色，用户类似于调度员：（所以用户的请求发送给 Servlet , Servlet 调用 Model 来处理用户请求，并调用 JSP 来呈现处理结果;） Model 通常由 JavaBean 来充当，所以业务逻辑、数据访问逻辑都在 Model 中实现 JavaBean JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器 JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，long和class方法获取 MVC中充当model AppletJava Applet 是用Java 语言编写的一些小应用程序，这些程序是直接嵌入到页面中，由支持Java的浏览器(IE 或 Netscape)解释执行能够产生特殊效果的程序。它可以大大提高Web页面的交互能力和动态执行能力。包含Applet的网页被称为Java-powered页，可以称其为Java支持的网页 HTTP状态码200 &amp; OK: 请求成功； 204 &amp; No Content: 请求处理成功，但没有资源可以返回； 206 &amp; Partial Content: 对资源某一部分进行请求(比如对于只加载了一般的图片剩余部分的请求)； 301 &amp; Move Permanently: 永久性重定向； 302 &amp; Found： 临时性重定向； 303 &amp; See Other: 请求资源存在另一个URI，应使用get方法请求； 304 &amp; Not Modified: 服务器判断本地缓存未更新，可以直接使用本地的缓存； 307 &amp; Temporary Redirect: 临时重定向； 400 &amp; Bad Request: 请求报文存在语法错误； 401 &amp; Unauthorized: 请求需要通过HTTP认证； 403 &amp; Forbidden: 请求资源被服务器拒绝，访问权限的问题； 404 &amp; Not Found: 服务器上没有请求的资源； 500 &amp; Internal Server Error: 服务器执行请求时出现错误； 502 &amp; Bad Gateway: 错误的网关； 503 &amp; Service Unavailable: 服务器超载或正在维护，无法处理请求； 504 &amp; Gateway timeout: 网关超时； XML、SOAP、WSDLXML 可扩展标记语言 它非常适合万维网传输，提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。是Internet环境中跨平台的、依赖于内容的技术，也是当今处理分布式结构信息的有效工具 SOAP 简单对象访问协议 是交换数据的一种协议规范，是一种轻量的、简单的、基于XML（标准通用标记语言下的一个子集）的协议，它被设计成在WEB上交换结构化的和固化的信息 WSDL Web Services Description Language 网络服务描述语言是Web Service的描述语言，它包含一系列描述某个web service的定义 WSDL 元素[1] 基于XML语法描述了与服务进行交互的基本元素 XML（标准通用标记语言的子集） webService三要素 SOAP(Simple Object Access Protocol) WSDL(WebServices Description Language) UDDI(Universal Description Discovery and Integration) soap用来描述传递信息的格式， WSDL 用来描述如何访问具体的接口， uddi用来管理，分发，查询webService。 Java Web应用目录结构 structs配置文件在编写在web.xml中]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redis简单入门]]></title>
      <url>%2F2017%2F06%2F23%2FRedis%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[相关使用官网介绍的很详细 简介 运行在内存里面 是一款开源的、高性能的一个第三方软件，就是一个key-value存储系统(即基于KV系统的数据库) redis是一种Nosql数据库，Nosql全称是Not Only SQL，是一种不同于关系型数据库的数据库管理系统设计方式。对NoSQL最普遍的解释是“非关系型的”，强调Key-Value 存储和文档数据库的优点，而不是单纯的反对RDBMS 与传统关系型数据库（例如mysql）不同的是，传统关系型数据库使用sql语句来操纵数据库，而redis是通过命令行来实现的。另一大相比于传统关系型数据库的优势是，由于值可以存放任意的数据类型，所以存储值类型可变动范围更大，更容易进行扩展。 持久化存储redis持久化RDB和AOF 两种存储方式： RDB 记录某一个时刻的数据库当前的状态 适用于当一个值经常被改动的情况下，即命令很多，但操作的一直是一个数，我们想要的只是最终结果 AOF 记录执行的所有的命令 好处是丢失数据的几率会更小 特点Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储，即“键-值”存储关系中的值是可以放置任何数据结构的，包括字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）和 有序集合（sorted sets）等数据类型（当然也可以放置JSON这样的数据）。对于这些数据类型，你可以执行原子操作。例如：对字符串进行附加操作（append）；递增哈希中的值；向列表中增加元素；计算集合的交集、并集与差集等。 Redis支持数据的备份，即master-slave模式的数据备份 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性 与其他key-value存储有什么差异 Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问 可用场合一个网站，底层的静态数据存储可以用关系型数据库，如mysql,缓存系统可以用redis,牛客网就是这么做的 可以用redis来做页面浏览量的记录，验证码存储时间的记录（jedis.setex(“hello2”, 1800, “world”); ），赞/踩的数量， 当遇到短时间内要记录的数量可能发生急剧变化的场合（比如秒杀系统），可以考虑使用redis，因为redis是运行在内存里面的，传统的关系型数据库为了数据安全性，没进行一次操作都会先将数据锁住，然后再进行更改，这在这种场合下容易导致系统性能下降 PV（页面浏览） 点赞 关注 排行榜 验证码 缓存 异步队列 判题队列 简单操作下载安装完redis并配置完系统环境变量之后，打开一个命令行窗口，输入： redis-server 开启服务程序，然后打开另一个命令行（前一个命令行不能关闭），输入： redis-cli 这样就可以开始使用redis了。 当redis 服务器初始化时，会预先分配16个数据库（该数量可以通过配置文件配置），所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中。当我们选择数据库 select number 时，程序直接通过 redisServer.db[number] 来切换数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 redisDb.id 即可。 存值set testKey abc 取值get testKey 查看所有存在的键 keys *]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网站数据安全性]]></title>
      <url>%2F2017%2F06%2F22%2F%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7%2F</url>
      <content type="text"><![CDATA[HTTPS注册页 http的注册页面的话，登录或者注册请求中的用户名及密码在数据发送过程中是以明文的方式发送的，这样在经过路由器等中间点的时候就很有可能被截获，token也一样 公钥加密私钥解密 支付宝的h5支付页面就是这么做的，当页面打开时，服务器就会在这个页面中埋一个公钥（就像未登录跳转中说的那样,用一个hidden属性的文本区），在提交密码时，先用公钥将密码加密了，之后再提交到服务器，服务器收到之后，用本身自己保存的私钥对其进行解密，解密完后就知道密码了 用户密码salt防止破解（CSDN，网易邮箱未加密密码泄漏） 就是给用户密码添加salt之后在进行保存，防止数据库泄露导致用户密码泄露 token有效期 单一平台的单点登陆，登陆IP异常检验 单点登录： 一个平台登录了，另外平台之前登录的token就被设置为无效，这样那一次进入网站时，突然发现得重新登录，那就是可能是被异地登录，账户密码Kenneth已经泄露了 登录IP异常检验： 通过比较两次登录的ip，如果差别的省份比较大，就可以通过拦截器给用户发个站内信什么的，通知用户被异地登录了 用户状态的权限判断 某些页面需要相关的权限才能访问，不要每个页面都随便让人就能访问，容易泄露信息 添加验证码机制，防止爆破和批量注册 防止垃圾信息留在网站上，对网站功能或者正常使用产生伤害]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[session介绍及session共享]]></title>
      <url>%2F2017%2F06%2F22%2Fsession%E4%BB%8B%E7%BB%8D%E5%8F%8Asession%E5%85%B1%E4%BA%AB%2F</url>
      <content type="text"><![CDATA[session字面意思是，服务器与客户端一次有效的通话 同一个用户在没有关闭浏览器状态的情况下，在一个网站访问完一个页面后有访问一个页面，这叫一个session 那网站是怎么知道你是同一个人的？就是通过cookie中这个叫sessionid的东西 大网站的session是共享的（不同服务器之间），实现的方法是sessionid(即这个项目中的ticket（token）)，总之就是一段代码，可以表示这个用户是谁。sessio共享说到底就是有一个公共的服务中心，可以把这个session共享给所有人。 两台机器的session共享可以说两台机器内存中的session都是一样的，或者是都去访问同样的一个地方去查找数据，这个同样的地方，可以是一张表，也有可能是一个服务，这样。 现在市面上的网站都是这样的，包括实现一个端（淘宝）登陆之后，另一个端（支付宝）免登陆的操作，将token及相关的信息放到某个公共的地方（可以用redis存，也可以用数据库或者其它方式存，实现目的就行），所有的服务都可以访问，所有的服务访问之前，就拿这个去访问这个用户是谁。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设备像素密度测试]]></title>
      <url>%2F2017%2F06%2F18%2F%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E5%AF%86%E5%BA%A6%E6%B5%8B%E8%AF%95%2F</url>
      <content type="text"><![CDATA[-min-device-pixel-ratio与resolution 链接 介绍了各手机的像素密度(-webkit-min-device-pixel-ratio)响应式布局 与像素相关的前端基础知识 CSS布局基础之一设备像素，设备独立像素，设备像素比，css像素之间的关系 前端开发 基础知识 dpi 、 dip 、分辨率、屏幕尺寸、px、density 关系以及换算]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[响应式图像]]></title>
      <url>%2F2017%2F06%2F18%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9B%BE%E5%83%8F%2F</url>
      <content type="text"><![CDATA[链接 让图片自适应屏幕大小 把图片写入背景里面 响应式 Web 设计 - 图片(BootStrap教程) 响应式图片的3种解决方案 图片响应式解决方案 CSS解决方案——媒体查询 HTML解决方案——srcset+sizes+w标识符 javascript解决方案]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS级别响应式的弊端]]></title>
      <url>%2F2017%2F06%2F18%2FCSS%E7%BA%A7%E5%88%AB%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%BC%8A%E7%AB%AF%2F</url>
      <content type="text"><![CDATA[弊端概述并不能真正的识别用户客户端。由于 CSS 级别的响应式普遍都是通过 @media 的媒介查询方式根据屏幕尺寸判断手机端还是PC端， 这种做法显然是不科学的，例如，将手机横屏 CSS 可能就认为该客户端为 PC，将PC浏览器窗口缩小，CSS 就认为该客户端是手机。 自然基于这种判断渲染出来的界面并不是真正客户需求的。 2.可能导致样式混乱。由于 CSS @media 存在一个临界点，如@media screen and (max-width:800px)， 如果整站代码存在临界点不一致的情况，当窗口尺寸缩小或放到大这一临界点(800px)附近时， 样式就可能出现混乱了。这是常有的事情，相比不做响应式，可能带给用户的麻烦比便利会更多。 代码冗余量大。从 CSS 级别来做的响应式网站代码冗余量是很大的，一方面需要用大量的 CSS 媒介查询代码处理不同尺寸的样式。 一方面 HTML 也会有大量的容易代码，一般而言响应式网站在 PC端效果会丰富一些，手机端就会简洁一些，在这种动态渲染的HTML，普遍存在 一部分 HTML 只有在 PC端才会显示，反之亦然，这就意味着势必有部分HTML在手机/PC是不会出现的。那么不会出现的元素何必要发送给用户呢？无疑是增加了 代码冗余量，消耗了网络带宽。对于访问量大，传输、渲染要求都很高的网站，这点缺点是不可容忍的。 维护成本高。由于一套HTML要同时考虑 PC端、手机端，每修改一个样式，需要在两种条件下进行测试，特别是对于手机端，还要考虑不同厂商不同手机尺寸的各种复杂情况。 修改了 PC端的样式，又有可能影响了手机的效果展示。总之，维护起来相当麻烦。 响应式网站最佳实践方法不做CSS级别的响应式，而是分别针对手机端、PC端做了两套HTML。 以淘宝为例，桌面端浏览器窗口输入www.taobao.com，毫无疑问，跳转的就是www.taobao.com指向的网站首页，桌面端的。手机呢，可以发现，url重定向成了www.m.taobao.com，没错，这个网址指向的网站的首页是专门为移动端设计的。 怎么实现的呢？很简单， 服务器通过识别用户发送的http请求头 user-agent来识别用户访问的设备信息，根据该值判定设备为PC或移动客户端，并根据结果跳转到与之对应的网址。 通过识别请求头user-agent分流客户，一方面更准确的为客户提供与之对应的服务，节省了带宽资源，增加了网站的个性化，可维护性。另一方面，还对性能有所提升， 这种分流策略类似于 ngnix，还减轻了服务器压力。 响应式现状响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是工作大，维护性难，所以一般都是中小型的门户或者博客类站点会采用响应式的方法从web page到web app直接一步到位，因为这样反而可以节约成本，不用再专门为自己的网站做一个web app的版本。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于响应式布局]]></title>
      <url>%2F2017%2F06%2F18%2F%E5%85%B3%E4%BA%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[什么是响应式布局什么是响应式？响应式的页面在不同的屏幕有不同的布局，换句话说，使用相同的html在不同的分辨率有不同的排版。 响应式布局通俗得讲是：css根据屏幕宽度，自动调整网页div显示和布局，以适应不同尺寸屏幕优化浏览体验，主要就是@media的使用 实现方式 @media 使用 CSS 媒介查询来实现响应式布局 BootStrap框架 十二栅格系统 最核心的几个 class, 还有几个container容器，几个 button 样式等 使用了流布局的方式实现响应式，主要通过宽度百分比，浮动样式 float 实现 flex布局 CSS3新特性 使用全局的rem 先根据屏幕换算1rem等于多少个px，然后设置html标签的font-size为多少个rem，屏幕越大，则font-size越大，然后页面所有的元素的宽高和字体大小都用rem等比例缩放 参考链接 设置viewport进行缩放 &lt;meta name=&quot;viewport&quot; content=&quot;width=320,maximum-scale=1.3,user-scalable=no&quot;&gt; BootStrap框架 官网 在线生成Bootstrap页面-官方]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初学Grunt]]></title>
      <url>%2F2017%2F06%2F18%2F%E5%88%9D%E5%AD%A6Grunt%2F</url>
      <content type="text"><![CDATA[本文使用的是国内镜像，用npm的可以自行把cnpm改为npm，用想用npm的可以参考这个 参考原文地址：Grunt新手一日入门 Grunt依赖Node.js，使用Grunt前请确保已经安装了Node.js 基础步骤 全局安装grunt命令行 cnpm install -g grunt-cli 到项目文件夹下，生成package.json文件，这个文件是Node.js用来描述项目的。 npm init 填写相关配置，不明白的直接跳过也可以 为该项目安装grunt npm install grunt --save-dev 表示安装npm到当前目录，-save-dev参数表示，表示会把刚安装的东西添加到package.json文件中 对于这个项目，假设我们希望grunt帮我们完成的功能有： 检查每个 JS 文件语法 合并两个 JS 文件 将合并后的 JS 文件压缩 将 SCSS 文件编译 新建一个本地服务器监听文件变动自动刷新 HTML 文件 根据以上的需求，grunt有以下的以下插件来满足： 合并文件：grunt-contrib-concat 语法检查：grunt-contrib-jshint Scss 编译：grunt-contrib-sass 压缩文件：grunt-contrib-uglify 监听文件变动：grunt-contrib-watch 建立本地服务器：grunt-contrib-connect 安装上面提到的那些插件 npm install --save-dev grunt-contrib-concat grunt-contrib-jshint grunt-contrib-sass grunt-contrib-uglify grunt-contrib-watch grunt-contrib-connect 安装完后可以看见package.json文件的devDependencies已经添加了那些插件，项目目录下也多出了个node_modules文件夹，里面放的就是刚刚安装的那些插件 配置Gruntfile.js的语法格式为： 12345678910module.exports = function(grunt) &#123; /*所有代码都放在这里面，这是Grunt的格式规范 包括下面的三个部分： */ 任务配置代码 插件加载代码 任务注册代码&#125;; 任务配置代码就是调用插件配置一下要执行的任务和实现的功能。插件加载代码就是把需要用到的插件加载进来，任务注册代码就是注册一个 task，里面包含刚在前面编写的任务配置代码。 这样，就可以用 grunt 来执行注册的一个 task 从而根据任务配置代码调用需要的插件来执行相应的操作 下面为uglify插件任务配置、插件加载及任务注册的代码示例： 任务配置代码123456789101112grunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'), uglify: &#123; options: &#123; banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n' &#125;, build: &#123; src: 'src/&lt;%= pkg.name %&gt;.js', dest: 'build/&lt;%= pkg.name %&gt;.min.js' &#125; &#125;&#125;); 插件加载代码grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;); 任务注册代码grunt.registerTask(&#39;default&#39;, [&#39;uglify&#39;]); 代码意思是，你在 default 上面注册了一个 Uglify 任务，default 就是别名，它是默认的 task，当你在项目目录执行 grunt 的时候，它会执行注册到 default 上面的任务。也就是说，当我们执行 grunt 命令的时候，uglify 的所有代码将会执行。 当然，我们也可注册别的task，例如： grunt.registerTask(&#39;compress&#39;, [&#39;uglify:build&#39;]); 想要执行这个task,不能只输入grunt命令，需要输入 grunt compress 命令来执行这条 task，而这条 task 的任务是 uglify 下面的 build 任务，也就是说，我们只会执行 uglify 里面 build 定义的任务，而不会执行 uglify 里面定义的其他任务。 完整示例代码针对我们之前做的那个想让grunt帮我们完成的任务假设，最终得到的Gruntfile.js代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283module.exports = function(grunt) &#123; var sassStyle = 'expanded'; grunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'), sass: &#123; output : &#123; options: &#123; style: sassStyle &#125;, files: &#123; './style.css': './scss/style.scss' &#125; &#125; &#125;, concat: &#123; dist: &#123; src: ['./src/plugin.js', './src/plugin2.js'], dest: './global.js', &#125;, &#125;, uglify: &#123; compressjs: &#123; files: &#123; './global.min.js': ['./global.js'] &#125; &#125; &#125;, jshint: &#123; all: ['./global.js'] &#125;, watch: &#123; scripts: &#123; files: ['./src/plugin.js','./src/plugin2.js'], tasks: ['concat','jshint','uglify'] &#125;, sass: &#123; files: ['./scss/style.scss'], tasks: ['sass'] &#125;, livereload: &#123; options: &#123; livereload: '&lt;%= connect.options.livereload %&gt;' &#125;, files: [ 'index.html', 'style.css', 'js/global.min.js' ] &#125; &#125;, connect: &#123; options: &#123; port: 9000, open: true, livereload: 35729, // Change this to '0.0.0.0' to access the server from outside hostname: 'localhost' &#125;, server: &#123; options: &#123; port: 9001, base: './' &#125; &#125; &#125; &#125;); grunt.loadNpmTasks('grunt-contrib-sass'); grunt.loadNpmTasks('grunt-contrib-concat'); grunt.loadNpmTasks('grunt-contrib-jshint'); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-watch'); grunt.loadNpmTasks('grunt-contrib-connect'); grunt.registerTask('outputcss',['sass']); grunt.registerTask('concatjs',['concat']); grunt.registerTask('compressjs',['concat','jshint','uglify']); grunt.registerTask('watchit',['sass','concat','jshint','uglify','connect','watch']); grunt.registerTask('default');&#125;; 添加了 connect 任务，用来新建一个本地服务器，以当前目录作为服务器根目录 然后添加 watch 任务 监听 Scss 文件变动，如果变了，执行一下 sass 任务 监听那俩 JS，如果变了，执行 合并、检查、压缩 任务 监听 html、css、js 文件，如果变动，livereload 自动刷新打开的页面 而注册的 watchit task 就是我们的终极 task，第一次执行，先编译 sass、再合并、检查、压缩、开启服务器、监听文件变动。我们执行一下 grunt watchit 就可以看到效果了，可以修改一下 scss 文件，把字体设置大一点，切换到浏览器的时候，就看到了实时刷新效果 多人协作–Github上面步骤完成之后，想要上传到Github上会发现，文件内容多出来十几兆，原因是那个放Grunt插件的node_modules文件夹，然而我们大可以使用git的 .gitignore 文件来过滤掉这个文件，禁止git追踪。 原因是在package.json文件中已经记录了这个项目中依赖的 grunt 插件，只要上传这个文件即可。与你协作的人，下载下来之后，只需要在这个项目文件夹下面，输入命令 npm install，NPM会自动读取 package.json 文件，将grunt和有关插件给你下载下来即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git冲突的产生与解决]]></title>
      <url>%2F2017%2F06%2F15%2FGit%E5%86%B2%E7%AA%81%E7%9A%84%E4%BA%A7%E7%94%9F%E4%B8%8E%E8%A7%A3%E5%86%B3%2F</url>
      <content type="text"><![CDATA[什么情况下会产生冲突？第一种情况你修改了本地的某一份文件里面的内容，准备提交到github仓库上，恰好github仓库上的仓库的这份文件被另外一个人给修改了，即此时你本地对那份文件做了修改，远程仓库的那份文件也被做了修改，这样等你提交远程仓库的时候，冲突就产生了，不管你们修改的是不是那份文件的同一个地方，都会被识认为是冲突。 第二种情况你没有修改原本的文件，但是添加了新的文件，而远程仓库中，部分原本的文件被人更改了，那当你提交的时候也会发生冲突，很好理解，因为你本地文件内容旧了，需要用git pull origin master，拉取远程仓库最新的文件内容到本地，更新本地的文件内容，不用怕，只是更新旧文件的内容，你自己的文件不会被删掉（清楚“ 合并 ”这个概念，两个集合取并集，除非其中两个集合的同一个元素的值发生了异议，才会产生冲突，这时候才需要去解决冲突），更新完本地旧文件后，你就可以安心的提交你想提交的内容了。 值得注意的是，合并远程仓库的新内容到本地时，会自动识别成一次记录，备注默认的是一句“merge ….基本清了，大概意思就是合并远程仓库的内容到本地仓库….”，你可以默认，也可以更改为自己想要的备注。 第一种情况怎么解决？首先拉取远程仓库到本地git pull origin master 此时你用git bash的话，会发现所在的分支提示会变成下面这样的：（master|MERGING） 这说明已经拉取成功，让你解决冲突之后，就可以提交 一般冲突的地方文件内容会以这样的形式提示，让你更改 更改完之后，保存文件，会看到分支的提示有变回（master）了，这时git会认为你已经解决冲突了，可以提交到远程仓库 重新使用add、commit、push命令就能提交成功了 应该注意什么可能你也发现了，在团队合作的情况下，每个人都拥有对某个仓库的读写权限，每个人都在提交，发生像上面说到的冲突是在所难免的。一旦发生冲突，你可以通过拉取远程仓库的内容，借助git，比较内容冲突在哪里并更改完文件后（只要改了冲突的地方就行，不管有没有跟本地的还是跟仓库的一样），就可以提交到远程的仓库。这很可能就会导致别人原本正确的东西被你给弄错了。 具体的引用网上的一段话： 仔细对比,取综合的并集,就是尽量把所有不同的文件保留,共同的只留一份 个人的一点经验:多人协作开发的时候,如果出现了你没有改过的文件跟你冲突了,一定要去找到当事者,说清楚是如何冲突,然后协商解决,千万不要擅自拉别的分支去试图解决冲突,或找文件覆盖.同时记住,解决了之后,要add 和 commit 最后push.为保证万无一失,最后在冲突都解决之后,重启项目,特别是指服务器项目,保证至少不会有立即奔溃的现象发生.然后才去提交,push. 提交的时候,一定要保持清醒,先搞清楚自己要提交的文件之间的关系,然后再提交,这样才不会有文件缺失的问题,造成奔溃. 如果任务比较多,又建议开多个分支,分别进行开发.还是老话,一定要清楚自己在各个分支上做了什么,自己要提交的是什么.最好是能做个详细的笔记.好记性不如烂笔头.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建hexo博客的具体流程]]></title>
      <url>%2F2017%2F06%2F14%2F%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[在本地搭建讲一下搭建hexo博客的具体流程 首先安装git环境 然后安装node环境（node再带的npm版本据说比较老旧，可以使用npm install npm -g来重装（更新）一下npm版本，不过我弄之后版本还是一样的，可能现在node和npm更新已经同步了吧） 搭建前先说一下，最近国内npm源号好像有问题，可以使用镜像来解决：npm install -g cnpm --registry=https://registry.npm.taobao.org镜像指定完之后，后面使用的npm命令都可以用cnpm代替。可以理解为npm是直接调用官方的资源，cnpm是调用国内镜像站的资源。（这几天npm命令老是出问题，估计又出什么事了，还是先用用cnpm吧，速度比较快也比较稳定） 开始搭建hexo博客 命令行中执行cnpm install hexo-cli -g用全局模式安装hexo命令行，全局模式安装意味着你在电脑的任何文件位置都可以使用 cnpm install hexo -g，也是采用全局模式安装hexo博客框架 到你想放置博客的地方，比如想在D:\hexo 放置，那就把路径移动到该目录下，执行hexo init blog，这样会自动从github上下载hexo博客框架到本地的blog文件夹（如果命令不加那个blog,则直接放在hexo文件夹下） 完成之后，如果npm命令没出问题，会自动执行命令（npm instll）安装依赖文件，但还是那个问题，最近国内npm源貌似有问题，所以自己得再手动安装一下，执行cnpm install即可 这样就都弄完了，执行hexo generate生成博客的静态页面，然后执行hexo server，就可在本地浏览器中的http://localhost/4000 地址内看到生成的默认博客页面了，默认是4000，也可能是其他的具体看运行hexo server后它的提示。当然也可以通过hexo serer -p 3000直接指定页面显示的端口，即此时访问应是http://localhost/3000 换电脑怎么办很简单，直接将整个blog文件夹拷贝到那台电脑上就可以，前提是目标电脑也有node、git环境。 之后就都可以使用了，无论是本地的hexo操作还是提交到github上，都是可以操作了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网站登陆与登出的实现--token]]></title>
      <url>%2F2017%2F06%2F11%2F%E7%BD%91%E7%AB%99%E7%99%BB%E9%99%86%E4%B8%8E%E7%99%BB%E5%87%BA%E7%9A%84%E5%AE%9E%E7%8E%B0--token%2F</url>
      <content type="text"><![CDATA[登陆 登录时提交用户名和密码 服务器先验证用户名和密码是否正确（包括自身登陆以及三方登陆） 服务器生成并下发一个token(不一定生成，如果你本身带了一个sessionid,那它就会拿你那个sessionid和userid关联起来)，总之它会记下来说你提交给我的某一个而唯一的东西要跟你的userid关联起来，这样你下次再提交过来的时候，我就去那个关联的表里查一查，看你是否已经被关联过了，如果你已经关联过了，那服务器就能知道这个人是你。客户端收到这个信息以后会把这东西存起来，浏览器是存在cookie里面的，如果是app,则存在本地(个人理解为可以实现网站记住登录的这样一种状态，以及其它一些需要身份认证的请求等等)。总之你就会一个东西来表明你的身份，这个东西是服务器给你的，或者是你自己提交给服务器认证的这样一个东西。 有了这个东西（token）以后，服务器那边记下这个token,并设置有效期（因为token不可能永久有效，那样如果泄露了，一次泄露变成永久泄露，那就不行了），服务器和客户端都会有一个有效期的设置，比如说：如果你记住登录，那有效期可能及时三个月或者怎样，如果没记住登陆，那你的有效期就将是一个session(所谓session就是你浏览器关了以后就无效了)。 所这个token可以是一个seesionid也可以是cookie里面的一个key。 登出 服务端和客户端都把token删除，这样这个token就无效了 session清理 token就是下面的那个t,黑客可以通过窃取这个t来达到假装你进行登录网站的操作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[forward和redirect的区别]]></title>
      <url>%2F2017%2F06%2F11%2Fforward%E5%92%8Credirect%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[forward内部跳转和redirect重定向跳转的区别 从地址栏显示来说 forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址 redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL 从数据共享来说 forward:转发页面和转发到的页面可以共享request里面的数据 redirect:不能共享数据. 从运用地方来说 forward:一般用于用户登陆的时候,根据角色转发到相应的模块 redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等 从效率来说 forward:高 redirect:低]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git学习]]></title>
      <url>%2F2017%2F06%2F09%2FGit%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[业界大佬廖雪峰的教程已经足够牛逼了，直接跳转吧：Git教程 没错这页面就是拿来放链接的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016年电脑cpu天梯图]]></title>
      <url>%2F2017%2F06%2F09%2F2016%E5%B9%B4%E7%94%B5%E8%84%91cpu%E5%A4%A9%E6%A2%AF%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[一张截止2016年，很全的cpu性能的天梯图，放上来以便想看的时候随时随地能看。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MyBatis框架介绍]]></title>
      <url>%2F2017%2F06%2F09%2FMyBatis%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[官方网站其实已经介绍的挺详细的了，而且还支持中文版。 MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录 说一下比较流行的Spring框架如何集成Mybatis的： 先了解下JDBC的数据库操作步骤： 先将一下代码复制到application.properties文件中（用户名和密码根据数据库账户的实际情况添加），目的是为application.properties增加spring配置数据库链接地址 spring.datasource.url=jdbc:mysql://localhost:3306/wenda? useUnicode=true&characterEncoding=utf8&useSSL=false spring.datasource.username=用户名 spring.datasource.password=密码 mybatis.config-location=classpath:mybatis-config.xml 在pom.xml中声明要添加的连接mysql数据库和MyBatis框架的Java包，即pom.xml引入mybatis-spring-boot-starter和mysql-connector-java &lt;!-- 导入mysql连接的java包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 导入mybatis框架的java包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; 在resources文件夹下添加mybatis-config.xml文件。有没有注意到，第一步中的最后一行代码，它的意思就是导入mybatis-config.xml这个文件，这是mybatis的配置文件。我们现在做的就是导入这个文件。这可以从官网上抄过来，不用记。（这些官网上都讲得很清楚） 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- Globally enables or disables any caches configured in any mapper under this configuration --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;!-- 是否缓存（让数据跑得更快） --&gt; &lt;!-- Sets the number of seconds the driver will wait for a response from the database --&gt; &lt;setting name="defaultStatementTimeout" value="3000"/&gt; &lt;!-- 请求超时 --&gt; &lt;!-- Enables automatic mapping from classic database column names A_COLUMN to camel case classic Java property names aColumn --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;!-- 驼峰式命名 --&gt; &lt;!-- Allows JDBC support for generated keys. A compatible driver is required. This setting forces generated keys to be used if set to true, as some drivers deny compatibility but still work --&gt; &lt;setting name="useGeneratedKeys" value="true"/&gt; &lt;!-- 生成之后要不要返回 --&gt; &lt;/settings&gt; &lt;!-- Continue going here --&gt;&lt;/configuration&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Request与Response]]></title>
      <url>%2F2017%2F06%2F08%2FRequest%E4%B8%8EResponse%2F</url>
      <content type="text"><![CDATA[推荐阅读：#HTTP协议学习# （一）request 和response 解析 Request 参数解析 cookie读取 http请求字段 文件上传 Response 页面内容返回 cookie下发 http字段设置，headers]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Velocity介绍]]></title>
      <url>%2F2017%2F06%2F08%2FVelocity%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[概述 Velocity是一个基于java的模板引擎（template engine）。它允许任何人仅仅简单的使用模板语言（template language）来引用由java代码定义的对象。 当Velocity应用于web开发时，界面设计人员可以和java程序开发人员同步开发一个遵循MVC架构的web站点，也就是说，页面设计人员可以只关注页面的显示效果，而由java程序开发人员关注业务逻辑编码。 Velocity将java代码从web页面中分离出来（Java里面语法怎么写，模板里面就也能怎么写），这样为web站点的长期维护提供了便利，同时也为我们在JSP和PHP之外又提供了一种可选的方案。 Velocity的能力远不止web站点开发这个领域，例如 它可以从模板（template）产生SQL和PostScript、XML 可以被当作一个独立工具来产生源代码和报告，或者作为其他系统的集成组件使用 可以为Turbine web开发架构提供模板服务（template service）。Velocity+Turbine提供一个模板服务的方式允许一个web应用以一个真正的MVC模型进行开发。 该模板引擎生成文件的默认后缀名为“vm” 在哪里使用？在html页面中，直接写入Velocity引擎的代码，具体代码怎么写、有什么规范，下面会有介绍。 脚本语法详解直接看：Velocity快速入门教程-脚本语法详解 疑问最近两年网上能收到的有关Velocity的消息很少，估计这引擎也够呛了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP请求的方法]]></title>
      <url>%2F2017%2F06%2F08%2FHTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[推荐阅读：#HTTP协议学习# （一）request 和response 解析 介绍HTTP请求到现在一共有8中方法，来表明Request-URL指定的资源不同的操作方式。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法 GET 请求指定的页面信息，并返回实体主体 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url GET提交的请求信息会显示的出现在url中，所以想要隐藏提交的（比如密码等）信息不能用GET来提交请求，应用POST。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form 像GET中说的那样，POST的请求信息是隐藏着的，url不会有变化，可用来提交不想展示出来的信息。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 向指定资源位置上传其最新内容 DELETE 请求服务器删除指定的页面。 请求服务器删除Request-URL所标识的资源 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能 返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性 TRACE 回显服务器收到的请求，主要用于测试或诊断。 什么是Loadrunner 是一款专业级别的应用负载测试工具 可以模拟上千万用户对企业应用进行真实的负载测试，通过大量实时监测器和精确的分析来得到最真实的数据，并且支持自动重复测试，以确保数值稳定和准确 通过使用LoadRunner，企业能最大限度地缩短测试时间，优化产品性能和加速应用系统的发布周期。* 适用于各种体系架构，它从用户关注的“响应时间”、“点击次数”或是工业层面的“吞吐量”和“请求数”等方面衡量系统的性能表现，进行评测和总结，并辅助用户优化系统性能 注意 方法名称是区分大小写的，当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Mothod Not Allowed） 当服务器不认识或者不支持对应的请求方法时，应返回状态码501（Not Implemented） HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法，特定的HTTP服务器支持扩展自定义的方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring框架介绍]]></title>
      <url>%2F2017%2F06%2F05%2FSpring%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[Spring官网 Spring项目初始化 官方文档 Spring是通过注解的方式来表明相应对象的作用的，例如：@Controller 什么是Spring?它有哪些好处？spring是一个轻量级控制反转（IOC）和面向切面（AOP）的容器框架 它主要是为了解决企业应用开发的复杂性而诞生的 目的：解决企业级应用开发的复杂性 功能：使用基本的JavaBean代替EJB（什么是EJB） 范围：任何Java应用 就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置内部通过反射去动态的组装对象） Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。内部最核心的就是IOC了,动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，根据xml Spring的配置文件来动态的创建对象，和调用对象里的方法的。 Spring是潜在一站式解决方案。 Spring本身存在的优点 低侵入式设计，代码污染极低 Write Once,Run Anywhere DI有效的降低了耦合度 AOP提供了通用的任务的集中管理 ORM和DAO简化了对数据库的访问 高度开放性，并不强制（贯穿于变现层，业务层，持久层） Spring的优点给开发带来的好处 可以有效组织中间层对象 使用同一的配置文件 促进良好的编程习惯，减少编程代价 易于单元测试。（一Spring基本组就是JavaBean,二提供了对Juit的支持） 使EJB成为一种备选 为数据存取提供了一致性的框架 理解AOP Aspect Oriented Programming:面向切面编程 一个组件A,不关心其他常用的服务组件B,但是这个组件A使用B的时候，不是组件A自身去调用，而是通过配置等其他方式，列如Spring中可以通过XML配置文件。这样就使得A压根就不需要知道服务组件B是怎么样的，爱存在不存在，爱怎么样存在都与Ａ无关。A只需要关心自己的业务逻辑，具体A使用B的时候，配置文件去做，与具体的A组件无关。 继续探讨AOP切面编程 理解IOC Inversion of Control：控制反转 IOC（控制反转）：说的是创建对象实例的控制权从代码控制剥离到IOC容器控制，实际就是你在xml文件控制，侧重于原理。 DI（依赖注入）：说的是创建对象实例时，为这个对象注入属性值或其他对象实例后，侧重于实现。 继续探讨IOC依赖注入 所有变量的初始化不是通过自己来负责的，而是通过依赖注入的概念。Spring框架只要你定义好了一些service,它自己就能把这些处理出来。 在service文件夹下定义好相应的service类，用@Service注释 在其他地方，比如controller文件夹中的类声明service中弄好的类的对象时，就可以直接采用“类名+对象名”的方式来生成对象，而不用new操作。用@Autowired注释。 即在service中声明类。在要用的地方依赖注入就可以了。 这样做有什么好处？ 如果大家在一起写代码，你可以跟一个人说你给我写个什么样的service，然后我需要什么接口，等他写完后，我只要在我想用的地方直接使用就行了，不用担心怎么初始化，直接在用的地方依赖注入就可以了（直接就拥有了相关对象的句柄）。即该方式的最大好处就是：无需关心变量的初始化，只需要通过注解的方式来表示说这是来自一个秉持（不知道是什么）的对象的初始化就可以了。 总结它的核心是轻量级的IOC容器，它的目标是为J2EE应用提供了全方位的整合框架，在Spring框架下实现多个子框架的组合，这些子框架之间可以彼此独立，也可以使用其他的框架方案加以代替。Spring希望为企业应用提供一站式的解决方案（建议：如果是高并发大型项目，慎重使用，因为项目大量使用反射机制，必定会影响性能。） 采用MVC模式时的目录结构模型(model)－视图(view)－控制器(controller) 下图是依赖于Spring框架的项目大概的树形结构： model文件夹用来存放模型 controller文件夹用来存放控制器 视图则存放在templates模板文件夹中 Spring Boot参考这篇文章Spring Boot 入门 Spring Boot并不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式。 从最根本上来讲，Spring Boot就是一些库的集合，它能够被任意项目的构建系统所使用 Spring Boot特点： 创建独立的Spring应用程序 嵌入的Tomcat，无需部署WAR文件 简化Maven配置 自动配置Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成和对XML没有要求配置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之输入与输出]]></title>
      <url>%2F2017%2F05%2F31%2FJava%E4%B9%8B%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%2F</url>
      <content type="text"><![CDATA[过程中发生的所有异常都是IOException的子类。 字节流文件输入流1234567891011121314151617181920212223242526import java.io.*;public class ByteReader &#123; public static void main(String[] arguments) &#123; try ( FileInputStream file = new FileInputStream("save.gif") ) &#123; boolean eof = false; int count = 0; while (!eof) &#123; int input = file.read(); System.out.print(input + " "); if (input == -1) eof = true; else count++; &#125; file.close(); System.out.println("\nBytes read: " + count); &#125; catch (IOException e) &#123; System.out.println("Error -- " + e.toString()); &#125; &#125;&#125; 文件输出流12345678910111213141516171819202122import java.io.*;public class ByteWriter &#123; public static void main(String[] arguments) &#123; int[] data = &#123; 71, 73, 70, 56, 57, 97, 13, 0, 12, 0, 145, 0, 0, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 0, 13, 0, 12, 0, 0, 2, 38, 132, 45, 121, 11, 25, 175, 150, 120, 20, 162, 132, 51, 110, 106, 239, 22, 8, 160, 56, 137, 96, 72, 77, 33, 130, 86, 37, 219, 182, 230, 137, 89, 82, 181, 50, 220, 103, 20, 0, 59 &#125;; try (FileOutputStream file = new FileOutputStream("pic.gif")) &#123; for (int i = 0; i &lt; data.length; i++) &#123; file.write(data[i]); &#125; file.close(); &#125; catch (IOException e) &#123; System.out.println("Error -- " + e.toString()); &#125; &#125;&#125; 字符流读取文本文件例一： 12345678910111213import java.io.*;public class FileCopy &#123; public static void main(String args[]) throws IOException&#123; FileReader f1; FileWriter f2; f1=new FileReader("FileCopy.java"); f2=new FileWriter("acopy_of_java_file.java"); int temp; while((temp=f1.read())!=-1); f2.write(temp); f1.close(); f2.close(); &#125; public FileCopy() &#123; &#125;&#125; 例二： 12345678910111213141516171819202122232425import java.io.*;public class SourceReader &#123; public static void main(String[] arguments) &#123; try ( FileReader file = new FileReader("SourceReader.java"); BufferedReader buff = new //这是讲读取的字符存储到缓冲区，以提高效率。 BufferedReader(file)) &#123; boolean eof = false; while (!eof) &#123; String line = buff.readLine(); if (line == null) &#123; eof = true; &#125; else &#123; System.out.println(line); &#125; &#125; buff.close(); &#125; catch (IOException e) &#123; System.out.println("Error -- " + e.toString()); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之C/S通信]]></title>
      <url>%2F2017%2F05%2F31%2FJava%E4%B9%8BC-S%E9%80%9A%E4%BF%A1%2F</url>
      <content type="text"><![CDATA[客户端使用BufferedReader从Socket上读取数据 建立对服务器的Socket连接 Socket chatSocket=new Socket(&quot;127.0.0.1&quot;,5000); 建立连接到Socket上底层输入串六的InputStreamReader InputStreamReader stream=new InputStreamReader(chatSocket.getInputStream()); 建立BufferedReader来读取 12BufferedReader reader=new BufferedReader(stream);String message=reader.readLine(); 用PrintWriter写数据到Socket 对服务器建立Socket连接 Socket chatSocket=new Socket(&quot;127.0.0.1&quot;,5000); 建立链接到Socket的PrintWriter PrintWriter=new PrintWriter(chatSocket.getOutputStream()); 写入数据 12writer.printIn("message to send");writer.print("another message"); 示例代码DailyAdviceClient客户端程序 12345678910111213141516171819202122232425import java.io.*;import java.net.*;public class DailyAdviceClient &#123; public void go()&#123; try &#123; Socket s = new Socket("127.0.0.1",4242); InputStreamReader streamReader = new InputStreamReader(s.getInputStream()); BufferedReader reader = new BufferedReader(streamReader); String advice = reader.readLine(); System.out.println("Today you should: " + advice); reader.close(); &#125; catch(IOException ex)&#123; ex.printStackTrace(); &#125; &#125; public static void main(String[] arg)&#123; DailyAdviceClient client = new DailyAdviceClient(); client.go(); &#125;&#125; 服务端工作方式 服务器应用程序对特定端口创建出ServerSocket ServerSocket serverSock=new ServerSocket(4242); 客户端对服务器应用程序建立Socket连接 Socket sock=new Socket(&quot;190.165.1.103&quot;,4242); 服务器创建出与客户端通信的新Socket Socket sock=serverSock.accept(); 示例代码DailyAdviceServer程序代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.*;import java.net.*;public class DailyAdviceServer &#123; String[] adviceList = &#123; "Take smaller bites", "Go for the tight jeans,No they do NOT make you look fat.", "One word: inappropriate", "Just for today, be honest. Tell your boss what you *really* think", "YOu might want to rethink that haircut" &#125;; public void go()&#123; try&#123; //ServerSocket会家庭客户端对这台机器在4242端口上的请求 ServerSocket serverSock = new ServerSocket(4242); //服务器进入无穷循环等待服务客户端的请求 while(true)&#123; Socket sock = serverSock.accept(); //这个方法会停下来等待要求到达后才会继续 PrintWriter writer = new PrintWriter(sock.getOutputStream()); String advice = getAdvice(); writer.println(advice); writer.close(); System.out.println(advice); &#125; &#125;catch(IOException ex)&#123; ex.printStackTrace(); &#125; &#125; private String getAdvice()&#123; int random = (int) (Math.random() * adviceList.length); return adviceList[random]; &#125; public static void main(String[] args)&#123; DailyAdviceServer server = new DailyAdviceServer(); server.go(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之序列化]]></title>
      <url>%2F2017%2F05%2F30%2FJava%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
      <content type="text"><![CDATA[简介序列化(serialize) 先回答这几个问题： 序列化是干什么的？ 简单说就是为了保存在内存中的各种对象的状态，并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存Object States，但是Java给你提供一种应该比你自己好的保存对象状态的机制,那就是序列化。 什么情况下需要序列化? 当你想把的内存中的对象保存到一个文件中或者数据库中时候； 当你想用套接字在网络上传送对象的时候； 当你想通过RMI传输对象的时候； 什么是实现对象序列化？ 对象序列化可以将一个对象保存到一个文件，可以将通过流的方式在网络上传输，可以将文件的内容读取转化为一个对象。所谓对象流也就是将对象的内容流化，可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对象流进行读写操作时引发的问题 如何实现对象序列化？ 将需要被序列化的类实现serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流（如FileOutputStream)来构造一个ObjectOutputStream（对象流）对象，接着使用ObjectOutputStream对象的writeObject（Object obj）方法就可以将参数obj的对象写出，要恢复的话则用输入流 实现序列化（保存到一个文件）的步骤 Make a FileOutputStream FileOutputStream fs = new FileOutputStream(&quot;foo.ser&quot;); Make a ObjectOutputStream ObjectOutputStream os = new ObjectOutputStream(fs); write the object os.writeObject(myObject1); os.writeObject(myObject2); os.writeObject(myObject3); close the ObjectOutputStream os.close(); 例子123456789101112131415161718192021222324252627282930import java.io.*;public class Box implements Serializable &#123; private int width; private int height; public void setWidth(int width) &#123; this.width = width; &#125; public void setHeight(int height) &#123; this.height = height; &#125; public static void main(String[] args) &#123; Box myBox = new Box(); myBox.setWidth(50); myBox.setHeight(30); try &#123; FileOutputStream fs = new FileOutputStream("foo.ser"); ObjectOutputStream os = new ObjectOutputStream(fs); os.writeObject(myBox); os.close(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; 注意事项 当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口； 当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化； 并非所有的对象都可以序列化，,至于为什么不可以，有很多原因了,比如： 安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输 等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。 资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且也是没有必要这样实现把一个对象完全转成字节序列，方便传输。 就像你寄一箱饼干，因为体积太大，就全压成粉末紧紧地一包寄出去，这就是序列化的作用。 只不过JAVA的序列化是可以完全还原的。 所谓序列化其实就是将程序中的数据(对象)通过某种方式，保存到本地中。然后把Java对象转换为字节序列的过程称为对象的序列化。 本文主要内容转载于：java 中的序列化是什么意思?有什么好处? 详细了解序列化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之AWT编程]]></title>
      <url>%2F2017%2F05%2F30%2FJava%E4%B9%8BAWT%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[简介AWTAWT 是Java基本类库的一部分,它在你的Java程序中提供了图形化用户界面,并且能够接收来自键盘,鼠标和其他输入设备的用户输入。 使用AWT包，则需要import java.awt.;（用于支持GUI的包还有java.swing.。这里直接用java.awt.*导入，其实主要是两个包：java.awt和java.awt.event） SwingSwing是AWT的一个扩展。使用Swing包，则需要import Javax.swing.*; Swing容器是java.awt.Container的子类，包含用于在容器中添加或产出组件、使用布局管理器来排列组件以及设置容器边框的方法。容器通常可放置到其他容器中。对象类层次结构如下 界面介绍注意窗口和面板的区别 创建窗口通过AWT12345678910111213141516171819202122import java.awt.*;class MyFirstFrame extends Frame &#123; private static final int FRAME_WIDTH = 300; private static final int FRAME_HEIGHT = 200; private static final int FRAME_X_ORIGIN = 150; private static final int FRAME_Y_ORIGIN = 250; public MyFirstFrame() &#123; setSize(FRAME_WIDTH, FRAME_HEIGHT); setResizable(false); setTitle("Program MyFirstFrame"); setLocation(FRAME_X_ORIGIN, FRAME_Y_ORIGIN); &#125;&#125;class TestMyFirstFrame &#123; public static void main(String args[]) &#123; MyFirstFrame frame = new MyFirstFrame(); frame.setVisible(true); &#125;&#125; 通过Swing1234567891011121314151617181920212223242526import javax.swing.*;public class SimpleFrame extends JFrame &#123;//继承JFrame框架类 public SimpleFrame() &#123; //创建构造方法 super("Frame Title"); setSize(300, 100); //设置框架大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setLookAndFeel(); setVisible(true); //刚创建时框架是不可见的，可使用该方法使框架可见 &#125; private static void setLookAndFeel() &#123; try &#123; UIManager.setLookAndFeel( "com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel" ); &#125; catch (Exception exc) &#123; // ignore error &#125; &#125; public static void main(String[] arguments) &#123; setLookAndFeel(); SimpleFrame sf = new SimpleFrame(); &#125;&#125; 添加组件通过AWT123456789101112131415161718192021222324252627282930313233import java.awt.*;class MyFirstFrame extends Frame &#123; private static final int FRAME_WIDTH = 300; private static final int FRAME_HEIGHT = 200; private static final int FRAME_X_ORIGIN = 150; private static final int FRAME_Y_ORIGIN = 250; private static final int BUTTON_WIDTH = 60; private static final int BUTTON_HEIGHT = 30; Button cancelButton, okButton;//添加两个按钮 public MyFirstFrame() &#123; setSize(FRAME_WIDTH, FRAME_HEIGHT); setResizable(false); setTitle("Program MyFirstFrame"); setLocation(FRAME_X_ORIGIN, FRAME_Y_ORIGIN); // add ok button okButton = new Button("OK"); okButton.setBounds(100, 150, BUTTON_WIDTH, BUTTON_HEIGHT); add(okButton); // add cancel button cancelButton = new Button("Cancel"); cancelButton.setBounds(170, 150, BUTTON_WIDTH, BUTTON_HEIGHT); add(cancelButton); &#125;&#125;class TestMyFirstFrame &#123; public static void main(String args[]) &#123; MyFirstFrame frame = new MyFirstFrame(); frame.setVisible(true); &#125;&#125; 通过Swing添加按钮12345678910111213141516171819202122232425262728293031323334import javax.swing.*;public class ButtonFrame extends JFrame &#123; JButton load = new JButton("Load"); JButton save = new JButton("Save"); JButton unsubscribe = new JButton("Unsubscribe"); public ButtonFrame() &#123; super("Button Frame"); setSize(340, 170); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel pane = new JPanel(); pane.add(load); pane.add(save); pane.add(unsubscribe); add(pane); setVisible(true); &#125; private static void setLookAndFeel() &#123; try &#123; UIManager.setLookAndFeel( "com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel" ); &#125; catch (Exception exc) &#123; System.out.println(exc.getMessage()); &#125; &#125; public static void main(String[] arguments) &#123; setLookAndFeel(); ButtonFrame bf = new ButtonFrame(); &#125;&#125; 创建一个登陆界面页面包含组件有：标签（JLabel）、文本框（JTextField、JPasswordField）、文本区域（JTextArea）、按钮（JButton） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import javax.swing.*;public class Authenticator extends javax.swing.JFrame &#123; JTextField username = new JTextField(15); JPasswordField password = new JPasswordField(15); JTextArea comments = new JTextArea(4, 15); JButton ok = new JButton("OK"); JButton cancel = new JButton("Cancel"); public Authenticator() &#123; super("Account Information"); setSize(300, 220); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel pane = new JPanel(); JLabel usernameLabel = new JLabel("Username: "); JLabel passwordLabel = new JLabel("Password: "); JLabel commentsLabel = new JLabel("Comments: "); comments.setLineWrap(true); comments.setWrapStyleWord(true); pane.add(usernameLabel); pane.add(username); pane.add(passwordLabel); pane.add(password); pane.add(commentsLabel); pane.add(comments); pane.add(ok); pane.add(cancel); add(pane); setVisible(true); &#125; private static void setLookAndFeel() &#123; try &#123; UIManager.setLookAndFeel( "com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel" ); &#125; catch (Exception exc) &#123; System.out.println(exc.getMessage()); &#125; &#125; public static void main(String[] arguments) &#123; Authenticator.setLookAndFeel(); Authenticator auth = new Authenticator(); &#125;&#125; 运行结果： 添加单选框或复选框 单选框： JRadioButton 复选框： JCheckBox 1234567891011121314151617181920212223242526272829303132333435363738394041import javax.swing.*;public class FormatFrame extends JFrame &#123; JRadioButton[] teams = new JRadioButton[4]; public FormatFrame() &#123; super("Choose an Output Format"); setSize(320, 120); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); teams[0] = new JRadioButton("Atom"); teams[1] = new JRadioButton("RSS 0.92"); teams[2] = new JRadioButton("RSS 1.0"); teams[3] = new JRadioButton("RSS 2.0", true); JPanel panel = new JPanel(); JLabel chooseLabel = new JLabel( "Choose an output format for syndicated news items."); panel.add(chooseLabel); ButtonGroup group = new ButtonGroup(); for (JRadioButton team : teams) &#123; group.add(team); panel.add(team); &#125; add(panel); setVisible(true); &#125; private static void setLookAndFeel() &#123; try &#123; UIManager.setLookAndFeel( "com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel" ); &#125; catch (Exception exc) &#123; System.out.println(exc.getMessage()); &#125; &#125; public static void main(String[] arguments) &#123; FormatFrame.setLookAndFeel(); FormatFrame ff = new FormatFrame(); &#125;&#125; 运行结果： 事件当用户移动鼠标、单击按钮时，一个事件就产生了 一个对象既可以是事件源对象，也可以是事件侦听对象，或二种角色兼有 如果界面使用Swing实现，则若要进行界面的事件操作，应该引入三个包： import java.awt.event.*; import javax.swing.*; import java.awt.*; 设置组件将类用作时间监听器是，必须首先设置它要监听的时间类型。如果不进行第二步操作——将匹配的监听器加入到GUI组建中，这种情况将不会发生。组件被使用时，该监听器将激发相应的事件。、 创建组件后，可以调用组件的下述方法之一将监听器与组件关联起来。 addActionListener()、addFocusListener()…其实就是在上面所给图中的接口的前面加一个”add”就行了。 事件处理方法将接口与类关联起来是，这个类必须处理接口包含的所有方法。 以接口ActionListener为例，其只有一个方法actionPerformed()。所有实现ActionListener的类都必须有一个结构与下面类似的方法： 123public void actionPerformed(ActionEvent event)&#123; //handle event here&#125; 事件创建举例各个事件的操作都差不多，这里只先提供焦点事件操作的过程。其它的时间操作先留个坑，以后再补。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.awt.event.*;import javax.swing.*;import java.awt.*;public class Calculator extends JFrame implements FocusListener &#123; JTextField value1, value2, sum; JLabel plus, equals; public Calculator() &#123; super("Add Two Numbers"); setSize(350, 90); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setLookAndFeel(); FlowLayout flow = new FlowLayout(FlowLayout.CENTER); setLayout(flow); //设置框架展示在什么位置 // create components value1 = new JTextField("0", 5); plus = new JLabel("+"); value2 = new JTextField("0", 5); equals = new JLabel("="); sum = new JTextField("0", 5); // add listeners value1.addFocusListener(this);//表示当前类就是事件监听器 value2.addFocusListener(this); // set up sum field sum.setEditable(false); // add components add(value1); add(plus); add(value2); add(equals); add(sum); setVisible(true); &#125; public void focusGained(FocusEvent event) &#123; try &#123; float total = Float.parseFloat(value1.getText()) + Float.parseFloat(value2.getText()); sum.setText("" + total); &#125; catch (NumberFormatException nfe) &#123; value1.setText("0"); value2.setText("0"); sum.setText("0"); &#125; &#125; public void focusLost(FocusEvent event) &#123; focusGained(event); &#125; private void setLookAndFeel() &#123; try &#123; UIManager.setLookAndFeel( "com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel" ); SwingUtilities.updateComponentTreeUI(this); &#125; catch (Exception exc) &#123; System.err.println("Couldn't use the system " + "look and feel: " + exc); &#125; &#125; public static void main(String[] arguments) &#123; Calculator frame = new Calculator(); &#125;&#125; 运行结果：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之JDBC语句对象]]></title>
      <url>%2F2017%2F05%2F30%2FJava%E4%B9%8BJDBC%E8%AF%AD%E5%8F%A5%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[JDBC 提供三种类型的语句对象： Statement ， PreparedStatement ， CallableStatement 其中 PreparedStatement 是 Statement 的子类， CallableStatement 是 PreparedStatement 的子类。每一种语句对象用来运行特定类型的 SQL 语句 Statement 对象用来运行简单类型的 SQL 语句，语句中无需指定参数 PreparedStatement 对象用来运行包含（或不包含） IN 类型参数的预编译 SQL 语句 CallableStatement 对象用来调用数据库存储过程 Statement概述Statement 对象用于将 SQL 语句发送到数据库服务器 创建 Statement 对象建立连接后， Statement 对象用 Connection 对象的 createStatement 方法创建，以下代码创建 Statement 对象： 12Connection con = DriverManager.getConnection(url, SYSDBA, SYSDBA);Statement stmt = con.createStatement(); 使用 Statement 对象执行语句tatement 接口提供了三种执行 SQL 语句的方法： executeQuery 、 executeUpdate 和 execute 方法 executeQuery 用于产生单个结果集的语句，例如 SELECT 语句 方法 executeUpdate 用于执行 INSERT 、 UPDATE 或 DELETE 语句以及 SQL DDL 语句，如 CREATE TABLE 和 DROP TABLE 。 INSERT 、 UPDATE 或 DELETE 语句的效果是修改表中零行或多行中的一列或多列。 executeUpdate 的返回值是一个整数，表示受影响的行数。对于 CREATE TABLE 或 DROP TABLE 等 DDL 语句， executeUpdate 的返回值总为零 方法 execute 用于执行返回多个结果集、多个更新元组数或二者组合的语句 执行语句的三种方法都将关闭所调用的 Statement 对象的当前打开结果集（如果存在）。这意味着在重新执行 Statement 对象之前，需要完成对当前 ResultSet 对象的处理。 关闭 Statement 对象Statement 对象可由 Java 垃圾收集程序自动关闭。但作为一种好的编程风格，应在不需要 Statement 对象时显式地关闭它们。这将立即释放数据库服务器资源，有助于避免潜在的内存问题 PreparedStatement概述PreparedStatement 继承 Statement ，并与之在两方面有所不同： PreparedStatement 对象包含已编译的 SQL 语句，语句已经 “ 准备好 ” 包含于 PreparedStatement 对象中的 SQL 语句可具有一个或多个 IN 参数。 IN 参数的值在 SQL 语句创建时未被指定。相反，该语句为每个 IN 参数保留一个问号（ “ ？ ” ）作为占位符。每个问号所对应的值必须在该语句执行之前，通过适当的 setXXX 方法来提供。 由于PreparedStatement 对象已预编译过，所以其执行速度要快于 Statement 对象。因此，需要多次重复执行的 SQL 语句经常创建为 PreparedStatement 对象，以提高效率。 作为 Statement 的子类， PreparedStatement 继承了 Statement 的所有功能。另外它还添加了一整套方法，用于设置发送给数据库以取代 IN 参数占位符的值。同时，三种方法 execute 、 executeQuery 和 executeUpdate 能执行设置好参数的语句对象 创建 PreparedStatement 对象以下的代码段（其中 con 是 Connection 对象）创建一个 PreparedStatement 对象： 1PreparedStatement pstmt = con.prepareStatement( UPDATE 厂商登记 SET 厂商名 = ? WHERE 厂商编号 = ?); 对象 pstmt 包含语句 UPDATE 厂商登记 SET 厂商名 = ? WHERE 厂商编号 = ? ，该语句带两个 IN 参数占位符，它已发送给数据库，并由服务器为其执行作好了准备。 CallableStatement概述CallableStatement 用来运行 SQL 存储过程。存储过程是数据库中已经存在的 SQL 语句，它通过名字调用 CallableStatement 是 PreparedStatement 的子类。 CallableStatement 中定义的方法用于处理 OUT 参数或 INOUT 参数的输出部分：注册 OUT 参数的 JDBC 类型（一般 SQL 类型）、从这些参数中检索结果，或者检查所返回的值是否为 JDBC NULL。 创建 CallableStatement 对象CallableStatement 对象是用 Connection.prepareCall 创建的。 以下代码创建 CallableStatement 对象，其中含有对存储过程 p1 的调用， con 为连接对象： 1CallableStatement cstmt = con.prepareCall(call p1(?, ?)); 其中 ? 占位符为 IN 、 OUT 还是 INOUT 参数，取决于存储过程 p1 。 详细介绍地址——JDBC语句对象 示例12345678910111213141516171819202122232425262728improt java.sql.*;public class JDBCExample&#123;public static void main(String args[])&#123;try&#123;Statement stmt;ResultSet rs;Class.forName(“com.mysql.jdbc.Driver”);String url = “jdbc:mysql://localhost:3306/db”;Connection con = DriverManager.getConnection(url,“root”,“1234”);stmt = con.createStatement();rs = stmt.executeQuery(“select name from empt whereage=‘25’”);while(rs.next())&#123;String name = rs.getString (“name”);&#125;rs.close(); //关闭结果集对象stmt.close(); //关闭SQL语句对象con.close(); //关闭连接对象&#125;catch(Exception ex)&#123;ex.printStackTrace();&#125;&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之初识JDBC]]></title>
      <url>%2F2017%2F05%2F30%2FJava%E4%B9%8B%E5%88%9D%E8%AF%86JDBC%2F</url>
      <content type="text"><![CDATA[简介JDBC：（Java Database Connectivity,Java数据库连接）是一组类。通过JDBC，可以在Java程序中使用相容的类和方法来读写记录以及执行其他是数据库访问操作。被称为驱动程序的类是连接到数据源的桥梁——对于每种流行的数据库（Oracle、Mysql等），都有相应的驱动程序。 对于每种常见的数据库使用任务，JDBC库中都有相应的类： 连接到数据库 使用SQL创建语句 在数据库中执行SQL查询 查看结果 这些JDBC类都位于java.sql包中 通过示例学习基本操作本示例用的是Mysql数据库 先来规定一个环境123456789101112131415161718192021222324252627282930313233343536373839404142434445static class Student &#123; private String Id; private String Name; private String Sex; private String Age; Student(String Name, String Sex, String Age) &#123; this.Id = null; //default this.Name = Name; this.Sex = Sex; this.Age = Age; &#125; public String getId() &#123; return Id; &#125; public void setId(String Id) &#123; this.Id = Id; &#125; public String getName() &#123; return Name; &#125; public void setName(String Name) &#123; this.Name = Name; &#125; public String getSex() &#123; return Sex; &#125; public void setSex(String Sex) &#123; this.Sex = Sex; &#125; public String getAge() &#123; return Age; &#125; public void setage(String Age) &#123; this.Age = Age; &#125;&#125; 连接数据库123456789101112131415161718 private static Connection getConn() &#123; String driver = "com.mysql.jdbc.Driver"; String url = "jdbc:mysql://localhost:3306/samp_db"; String username = "root"; String password = ""; Connection conn = null; try &#123; Class.forName(driver); //classLoader,加载对应驱动 conn = (Connection) DriverManager.getConnection(url, username, password);//也可以写成： Connection conn =DriverManager.getConnection(url, username, password); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; 开始操作数据库insert(增)123456789101112131415161718private static int insert(Student student) &#123; Connection conn = getConn(); int i = 0; String sql = "insert into students (Name,Sex,Age) values(?,?,?)"; PreparedStatement pstmt; try &#123; pstmt = (PreparedStatement) conn.prepareStatement(sql); pstmt.setString(1, student.getName()); pstmt.setString(2, student.getSex()); pstmt.setString(3, student.getAge()); i = pstmt.executeUpdate(); pstmt.close(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i;&#125; update(改)12345678910111213141516private static int update(Student student) &#123; Connection conn = getConn(); int i = 0; String sql = "update students set Age='" + student.getAge() + "' where Name='" + student.getName() + "'"; PreparedStatement pstmt; try &#123; pstmt = (PreparedStatement) conn.prepareStatement(sql); i = pstmt.executeUpdate(); System.out.println("resutl: " + i); pstmt.close(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i;&#125; select(查)123456789101112131415161718192021222324private static Integer getAll() &#123; Connection conn = getConn(); String sql = "select * from students"; PreparedStatement pstmt; try &#123; pstmt = (PreparedStatement)conn.prepareStatement(sql); ResultSet rs = pstmt.executeQuery(); int col = rs.getMetaData().getColumnCount(); System.out.println("============================"); while (rs.next()) &#123; for (int i = 1; i &lt;= col; i++) &#123; System.out.print(rs.getString(i) + "\t"); if ((i == 2) &amp;&amp; (rs.getString(i).length() &lt; 8)) &#123; System.out.print("\t"); &#125; &#125; System.out.println(""); &#125; System.out.println("============================"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null;&#125; delete(删)12345678910111213141516private static int delete(String name) &#123; Connection conn = getConn(); int i = 0; String sql = "delete from students where Name='" + name + "'"; PreparedStatement pstmt; try &#123; pstmt = (PreparedStatement) conn.prepareStatement(sql); i = pstmt.executeUpdate(); System.out.println("resutl: " + i); pstmt.close(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i;&#125; 调用运行12345678public static void main(String args[]) &#123; JDBCOperation.getAll(); JDBCOperation.insert(new Student("Achilles", "Male", "14")); JDBCOperation.getAll(); JDBCOperation.update(new Student("Bean", "", "7")); JDBCOperation.delete("Achilles"); JDBCOperation.getAll();&#125; 分析通过以上代码可以看出，JDBC的操作有通用的流程： 创建Connection对象、SQL查询命令字符串 对Connection对象传入SQL查询命令，获得PreparedStatement对象 对PreparedStatement对象执行executeUpdate()或executeQurey()获得结果 先后关闭PreparedStatement对象和Connection对象 可见，使用JDBC时，最常打交道的是Connection、PreparedStatement这两个类，以及select中的ResultSet类。 本文主要内容转载于：通过JDBC进行简单的增删改查（以MySQL为例）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之线程]]></title>
      <url>%2F2017%2F05%2F30%2FJava%E4%B9%8B%E7%BA%BF%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[创建线程有两种方法可以创建线程： 需要从Java.lang.Thread类派生一个新的线程类，重载它的run()方法 实现Runnable接口，重载Runnable接口中的run()方法 为什么要提供两种方法来创建线程呢？ 在Java中，类仅支持单继承，也就是说，当定义一个新的类的时候，它只能扩展一个外部类.这样，如果创建自定义线程类的时候是通过扩展 Thread类的方法来实现的，那么这个自定义类就不能再去扩展其他的类，也就无法实现更加复杂的功能。因此，如果自定义类必须扩展其他的类，那么就可以使用实现Runnable接口的方法来定义该类为线程类，这样就可以避免Java单继承所带来的局限性。另外，使用实现Runnable接口的方式创建的线程可以处理同一资源，从而实现资源的共享。 Runnable这个接口只有一个方法：public void run(); 通过Runnable接口创建线程 建立Runnable对象 Runnable threaJob=new MyRunnable(); 建立Thread对象并赋值Runnable任务 Thread就像一个工人，需要一个任务才能进行工作，而这个任务就在Runnable()的run()方法中 Thread myThread new Thread(threadJob); 启动Thread 工人有了任务滞后，就可以让他去工作了 myThread.start(); 例子： 12345678910111213141516171819202122232425262728//每个任务都是Runable接口的一个实例，任务是可运行对象，线程是便于任务执行的对象。必须创建任务类，重写run方法定义任务public class ThreadDemo1 implements Runnable &#123; private int countDown = 10; @Override //重写run方法，定义任务 public void run() &#123; while(countDown-- &gt;0) &#123; System.out.println("$" + Thread.currentThread().getName() + "(" + countDown + ")");//该方法若要访问当前线程，应使用Thread.currentThread() &#125; &#125; //调用start方法会启动一个线程，导致任务中的run方法被调用，run方法执行完毕则线程终止 public static void main(String[] args) &#123; Runnable demo1 = new ThreadDemo1(); Thread thread1 = new Thread(demo1); Thread thread2 = new Thread(demo1); thread1.start(); thread2.start(); System.out.println("火箭发射倒计时:"); &#125;&#125; 运行结果： 火箭发射倒计时: $Thread-0(9) $Thread-0(8) $Thread-0(7) $Thread-0(6) $Thread-0(5) $Thread-0(4) $Thread-0(3) $Thread-0(2) $Thread-0(1) $Thread-0(0) 如果同时运行两个任务对象，体会其不同的之处： 123456789101112public static void main(String[] args) &#123; Runnable demo1 = new ThreadDemo1(); Runnable demo2 = new ThreadDemo1(); Thread thread1 = new Thread(demo1); Thread thread2 = new Thread(demo2); thread1.start(); thread2.start(); System.out.println("火箭发射倒计时:"); &#125; 运行结果： 火箭发射倒计时: $Thread-0(9) $Thread-0(8) $Thread-0(7) $Thread-0(6) $Thread-1(9) $Thread-0(5) $Thread-1(8) $Thread-0(4) $Thread-1(7) $Thread-0(3) $Thread-1(6) $Thread-1(5) $Thread-0(2) $Thread-1(4) $Thread-1(3) $Thread-1(2) $Thread-1(1) $Thread-1(0) $Thread-0(1) $Thread-0(0) 继承Thread类来创建线程 首先创建一个任务类extends Thread类，因为Thread类实现了Runnable接口，所以自定义的任务类也实现了Runnable接口，重写run()方法，其中定义具体的任务代码或处理逻辑 创建一个任务类对象，可以用Thread或者Runnable作为自定义的变量类型 调用自定义对象的start()方法，启动一个线程 例子： 123456789101112131415161718192021222324252627//每个任务都是Runable接口的一个实例，任务是可运行对象，线程即可运行对象。必须创建任务类，重写run方法定义任务public class ExtendFromThread extends Thread &#123; private int countDown = 10; @Override //重写run方法，定义任务 public void run() &#123; while(countDown-- &gt;0) &#123; System.out.println("$" + this.getName() + "(" + countDown + ")"); &#125; &#125; //调用start方法会启动一个线程，导致任务中的run方法被调用，run方法执行完毕则线程终止 public static void main(String[] args) &#123; ExtendFromThread thread1 = new ExtendFromThread(); ExtendFromThread thread2 = new ExtendFromThread(); thread1.start(); thread2.start(); System.out.println("火箭发射倒计时:"); &#125;&#125; 运行结果： 火箭发射倒计时: $Thread-0(9) $Thread-0(8) $Thread-0(7) $Thread-0(6) $Thread-0(5) $Thread-0(4) $Thread-0(3) $Thread-0(2) $Thread-0(1) $Thread-0(0) $Thread-1(9) $Thread-1(8) $Thread-1(7) $Thread-1(6) $Thread-1(5) $Thread-1(4) $Thread-1(3) $Thread-1(2) $Thread-1(1) $Thread-1(0) 两种创建方法的比较 使用实现Runnable接口方式创建线程可以共享同一个目标对象，实现了多个相同线程处理同一份资源，即一个线程对资源的操作会影响到另一个进程的操作 而继承Thread创建线程的方式，new出了两个任务类对象，有各自的成员变量，相互之间不干扰。 各自的优缺点 采用继承Thread类方式： 优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程 缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类 采用实现Runnable接口方式： 优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想 缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法 本文以上主要内容转载于：java多线程总结一：线程的两种创建方式及比较 线程睡眠直接上代码： 1234567891011121314151617181920212223242526272829303132public class MyRunnable implements Runnable &#123; public void run()&#123; go(); &#125; public void go()&#123; //线程睡眠代码块 try&#123; Thread.sleep(2000); &#125;catch(InterruptedException ex)&#123; ex.printStackTrace(); &#125;//代码块结束 doMore(); &#125; public void doMore()&#123; System.out.println("top 0' the stack"); &#125;&#125;class ThreadTestDrive&#123; public static void main(String[] args)&#123; Runnable threadJob=new MyRunnable(); Thread mythread=new Thread(threadJob); mythread.start(); System.out.println("back in main"); &#125;&#125; 线程同步机制为什么要线程同步？我们现在知道，可以实现多个线程共享同一个资源（变量或者对象）的情况，如果这些线程都对需要对资源进行读或者写操作，由于线程之间的调度等其它问题，会导致资源的状态出现紊乱，导致程序异常。举个例子：如果一个银行账户同时被两个线程操作，一个取100块，一个存钱100块。假设账户原本有0块，如果取钱线程和存钱线程同时发生，会出现什么结果呢？取钱不成功，账户余额是100.取钱成功了，账户余额是0.那到底是哪个呢？由于是同时发生的两件事，很难说清楚。因此多线程同步就是要解决这个问题。 Java的同步机制是通过对象锁来实现的： 一段synchronized的代码被一个线程执行之前，他要先拿到执行这段代码的权限，在 Java里边就是拿到某个同步对象的锁（一个对象只有一把锁）； 如果这个时候同步对象的锁被其他线程拿走了，他（这个线程）就只能等了（线程阻塞在锁池 等待队列中）。 取到锁后，他就开始执行同步代码(被synchronized修饰的代码）；线程执行完同步代码后马上就把锁还给同步对象，其他在锁池中 等待的某个线程就可以拿到锁执行同步代码了。这样就保证了同步代码在统一时刻只有一个线程在执行。 例子： 1234567891011121314151617181920public class ThreadTest2 extends Thread &#123; private int threadNo; private String lock; public ThreadTest2(int threadNo, String lock) &#123; this.threadNo = threadNo; this.lock = lock; &#125; public static void main(String[] args) throws Exception &#123; String lock = new String("lock"); for (int i = 1; i &lt; 10; i++) &#123; new ThreadTest2(i, lock).start(); Thread.sleep(1); &#125; &#125; public void run() &#123; synchronized (lock) &#123; //原子单位 for (int i = 1; i &lt; 10000; i++) &#123; System.out.println("No." + threadNo + ":" + i); &#125; &#125; &#125; &#125; 该程序通过在main方法启动10个线程之前，创建了一个String类型的对象。并通过ThreadTest2的构造函数，将这个对象赋值 给每一个ThreadTest2线程对象中的私有变量lock。根据Java方法的传值特点，我们知道，这些线程的lock变量实际上指向的是堆内存中的 同一个区域，即存放main函数中的lock变量的区域。run方法加一个synchronized块来实现。这个同步块的对象锁，就是 main方法中创建的那个String对象。换句话说，他们指向的是同一个String类型的对象，对象锁是共享且唯一的！ 于是，我们看到了预期的效果：10个线程不再是争先恐后的报数了，而是一个接一个的报数。 同步的实现方式可分为： 同步方法 同步代码块 使用特殊域变量(volatile)实现线程同步 使用重入锁实现线程同步 详细介绍链接 多线程的使用场景 为了不阻塞主线程，启动其他线程来做耗时的事情。比如app开发中耗时的操作都不在UI主线程中做。 实现响应更快的应用程序， 即主线程专门监听用户请求，子线程用来处理用户请求。以获得大的吞吐量。感觉这种情况下，多线程的效率未必高。 这种情况下的多线程是为了不必等待， 可以并行处理多条数据。比如JavaWeb的就是主线程专门监听用户的HTTP请求，然后启动子线程去处理用户的HTTP请求。 某种优先级虽然很低的服务，但是却要不定时去做。比如Jvm的垃圾回收。 某种任务，虽然耗时，但是不耗CPU的操作时，开启多个线程，效率会有显著提高。比如读取文件，然后处理。 磁盘IO是个很耗费时间，但是不耗CPU计算的工作。 所以可以一个线程读取数据，一个线程处理数据。肯定比一个线程读取数据，然后处理效率高。 因为两个线程的时候充分利用了CPU等待磁盘IO的空闲时间。曾几何时想过使用多线程读取磁盘数据， 但是读取磁盘数据的性能瓶颈是IO，而不是CPU。 使用多线程的目的是为了不让CPU闲下来，明显不适合用于读取磁盘数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之异常]]></title>
      <url>%2F2017%2F05%2F29%2FJava%E4%B9%8B%E5%BC%82%E5%B8%B8%2F</url>
      <content type="text"><![CDATA[简介Java的异常处理依赖于你已经知道所调用的方法是有风险的（也就是方法可能产生异常），因此你可编写出处理此可能性的代码，如果你知道调用某个方法可能会有异常状况，你就可以与预先准备好对问题的处理程序，或者是从错误中恢复。 在Java中最好将有风险的程序代码包含在try/catch块中，这样才能对异常进行捕获和处理。 异常是一种Exception类型的对象。 格式： 12345try&#123; //危险动作&#125;catch(Exception ex)&#123;//因为异常是对象，所以你catch住的也是对象。 //尝试恢复&#125; 创建和抛出异常没错，我们不仅能写处理异常的程序，也可以自己创建和抛出异常，具体方式请往下看。 创建有风险、会抛出异常的程序代码： 12345public void takeRisk() throws BadException &#123;//必须声明它会抛出BadException if(abandonAllHope)&#123; throw new BadException();//创建Exception对象并抛出 &#125;&#125; 调用该方法的程序代码 12345678public void crossFingers()&#123; try&#123; anObject.takeRisk(); &#125;catch(BadException ex)&#123; System.out.printIn("Aaargh!"); ex.printStackTrace();//如果无法从异常中恢复，至少也使用printStackTrace()列出有用的信息 &#125;&#125; 如果你有抛出异常，则一定要使用throw来声明这件事。 注意： 编译器不会注意RuntimeException类型的异常。RuntimeExcetion不需要声明或被包含在try/catch的块中（然而你还是可以这样做）。编译器所关心的是成为检查异常（checked exception）的异常，程序必须要认识有以上可能的存在。 方法可以用trow关键系抛出异常对象： throw new FileIsTooSmallException(); 可能会抛出异常的方法必须声明成throws Exception try/catch块的流程控制当你调用有风险的方法时，发生的事有两种可能的情况： 成功的把try块完成 把异常丢回调用方的方法 finally:无论如何都要执行的部分打个比方，你做菜，得把火打开，然后会有两种情况，一种是全程没问题，你顺利把菜炒完，另一种是出现状况了，比如锅漏了这种异常导致你做菜大业失败，但是不管哪种情况，发生之后都必须执行的是把炉子关掉，而关炉子这个流程就是放在finally块中的。 很明显，finally块是用来存放不管有没有异常都得执行的程序。 格式： 12345678try&#123; turnOvenOn(); x.bake();&#125;catch(BakingException ex)&#123; ex.printStackTrace();&#125;finally&#123; turnOvenOff();&#125; 值得注意的是，就酸try或catch块中有return子凌，finally还是会执行，流程调到finally然后在回到return指令，就是这么厉害。 举个栗子： 123456789101112131415161718192021222324252627public class TestExceptions &#123; public static void main(String[] args) &#123; String test = "no"; //String test = "yes"; try&#123; System.out.println("start try"); doRisky(test); System.out.println("end try"); &#125; catch (ScaryException se) &#123; System.out.println("scary exception"); &#125; finally &#123; System.out.println("finally"); &#125; System.out.println("end of main"); &#125; //(API中没有此类)因此要自己写ScaryException类 static void doRisky(String test) throws ScaryException &#123; System.out.println("start risky"); if("yes".equals(test))&#123; throw new ScaryException(); &#125; System.out.println("end risky"); return; &#125;&#125; 运行结果为： start try start risky end risky end try finally end of main 若第三行改为“String test = "no";”则结果应为： start try start risky scary exception finally end of main 多重异常如果有必要，方法可以排除多个异常。但该方法的声明必须要有含有全部可能的检查异常（若两个或两个以上的异常有共同的父类是，可以只声明该父类就行） 格式： 123456789101112131415161718public class Laundry&#123; public void doLaundry() throws PantsException,LingerieException&#123; //有可能抛出两个异常的程序代码 &#125;&#125;public class Foo&#123; public void go()&#123; Laundry laundry=new Laundry(); try&#123; laundry.doLaundry(); &#125;catch(PantsException pex)&#123; //恢复程序代码 &#125;catch(LingerieException pex)&#123; //恢复程序代码 &#125; &#125;&#125; 异常具有多态性是基于类的继承关系得来的，父类或者子类的异常可以直接catch父类的异常来包含所有异常，catch子类的异常则只能用来处理子类的异常，对父类的不起作用。但是这也不意味着就可以都直接catch父类的异常来省去catch子类异常的步骤，因为直接catch父类的异常会导致不知道是哪个子类发生的异常，你会搞不清到底哪里出错了。 有多个catch块时要从大到小排列“从大到小”指的是按照类的继承关系，从最下面的子类放第一个位置，最开始的父类放最下面。兄弟之间次序不重要，可以随便放。 duck异常没错，不想处理的异常可以duck（躲避）掉。 方法时让调用的方法抛出异常，让调用那个方法的方法也抛出异常，就像踢皮球一样，不去管那个异常，只管抛出去，自己不管。既然都不管，这样踢来踢去最后只能落到Java虚拟机上，而Java虚拟机并不在意异常，所以程序就能编译通过。 123456789101112public class Test &#123; Laundry laundry=new Laundry(); public void foo() throws ClothingException&#123; laundry.doLaundry(); &#125; public static void main(String[] args) throws ClothingException&#123; Washer a=new Washer(); a.foo(); &#125;&#125; 以上代码如果将main函数里的throws ClothingException去掉，即没有duck掉异常，则无法通过编译，还会出现“unzepozted eception”的错误信息。如果不想duck掉，就老老实实用try/catch块将a.foo()这一危险操作包起来。 异常处理的结构规则 catch与finally不能没有try try与catch之间不能有程序 try一定要有catch或finally 只带有finally的try必须要声明异常 栗子： 12345void go() throws FooException&#123;//只带有finally的try try&#123; x.doStuff(); &#125;finally&#123; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java入门（五）]]></title>
      <url>%2F2017%2F05%2F29%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
      <content type="text"><![CDATA[继承 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。 多个类可以称为子类，单独这个类称为父类、超类或者基类。 子类可以直接访问父类中的非私有的属性和行为。 通过 extends 关键字让类与类之间产生继承关系。 具体实现为，通过extends关键字让类与类之间产生继承关系： class SubDemo extends Demo{} //SubDemo是子类，Demo是父类 继承提高了代码的复用性，让类与类之间产生关系，是多态的前提。 super和this的区别super是一个关键字，代表父类的存储空间标识。(可以理解为父亲的引用) this代表对象的引用(谁调用就代表谁)； super代表当前子类对父类的引用。 使用场景 当子父类出现同名成员时，可以用super进行区分 子类要调用父类构造函数时，可以使用super语句 具体用法 成员变量 构造方法 成员方法 注意： super();和this();都是在构造函数的第一行，不能同时出现（this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过） this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块 举个栗子： 123456789101112131415161718192021222324252627282930313233343536373839class Person &#123; public static void prt(String s) &#123; System.out.println(s); &#125; Person() &#123; prt("父类·无参数构造方法： "+"A Person."); &#125;//构造方法(1) Person(String name) &#123; prt("父类·含一个参数的构造方法： "+"A person's name is " + name); &#125;//构造方法(2) &#125; public class Chinese extends Person &#123; Chinese() &#123; super(); // 调用父类构造方法（1） prt("子类·调用父类”无参数构造方法“： "+"A chinese coder."); &#125; Chinese(String name) &#123; super(name);// 调用父类具有相同形参的构造方法（2） prt("子类·调用父类”含一个参数的构造方法“： "+"his name is " + name); &#125; Chinese(String name, int age) &#123; this(name);// 调用具有相同形参的构造方法（3） prt("子类：调用子类具有相同形参的构造方法：his age is " + age); &#125; public static void main(String[] args) &#123; System.out.println("第一条语句执行结果为："); Chinese cn = new Chinese(); System.out.println("第二条语句执行结果为："); cn = new Chinese("codersai"); System.out.println("第三条语句执行结果为："); cn = new Chinese("codersai", 18); &#125; &#125; 运行结果为： 抽象类 Java中可以定义没有方法体的方法，该方法的具体实现由子类完成，该方法称为抽象方法，包含抽象方法的类就是抽象类 抽象方法和抽象类都必须被abstract关键字修饰 抽象类不可以用new创建对象，因为调用抽象方法没意义 抽象类中的抽象方法要被使用，必须由子类复写其所有的抽象方法后，建立子类对象调用； 如果子类只覆盖了部分的抽象方法，那么该子类还是一个抽象类 抽象类中可以有抽象方法，也可以有非抽象方法，抽象方法用于子类实例化 如果一个类是抽象类，那么，继承它的子类，要么是抽象类，要么重写所有抽象方法。特殊：抽象类中可以不定义抽象方法，这样做仅仅是不让该类建立对象 栗子： 123456789101112131415161718192021222324abstract class 葵花宝典 &#123; public abstract void 自宫();&#125;class 岳不群 extends 葵花宝典 &#123; public void 自宫()&#123; System.out.println("剪刀"); &#125;&#125;class 林平之 extends 葵花宝典&#123; public void 自宫()&#123; System.out.println("指甲刀"); &#125;&#125;class AbstractTest &#123; public static void main(String[] args) &#123; 岳不群 岳 = new 岳不群(); 岳.自宫(); 林平之 林 = new 林平之(); 林.自宫(); &#125;&#125; 抽象类不能被实例化，为什么还有构造函数？ 只要是class定义的类里面就肯定有构造函数。抽象类中的函数是给子类实例化的。 一个类没有抽象方法，为什么定义为抽象类? 不想被继承，还不想被实例化。 抽象关键字abstract不可以和哪些关键字共存？ final：如果方法被抽象，就需要被覆盖，而final是不可以被覆盖，所以冲突。 private：如果函数被私有了，子类无法直接访问，怎么覆盖呢？ static：不需要对象，类名就可以调用抽象方法。而调用抽象方法没有意义。 接口接口是抽象方法和常量值的集合。从本质上讲，接口是一种特殊的抽象类，这种抽象类只包含常量和方法的定义，而没有变量和方法的实现。 格式：interface 接口名{}（注意没有“class”） 实现：class 类名 implements 接口名 {} 接口的成员特点： 成员常量：public static final，接口里定义的变量是全局常量，而且修饰符只能是这三个关键字，都可以省略，常量名要大写 成员方法：public abstract，接口里定义的方法都是抽象的，两个修饰符关键字可省略 推荐：永远手动给出修饰符 抽象类与接口的区别 成员变量： 抽象类能有变量也可以有常量 接口只能有常量 成员方法： 抽象类可以有非抽象的方法,也可以有抽象的方法 接口只能有抽象的方法 构造方法： 抽象类有构造方法 接口没有构造方法 类与抽象类和接口的关系： 类与抽象类的关系是继承 extends 类与接口的关系是实现 implements 一个类可以实现多个接口吗？答案是肯定可以的，接口本身就是解决多重继承衍生的产物，如果不能实现多个接口那接口姐没有什么意义了。 例子： 1234567891011121314151617//A接口interface A&#123; public int getA();&#125;//B接口interface B&#123; public int getB();&#125;//实现了某个接口必须实现其全部的方法public class ImpAB implements A,B&#123; public int getA() &#123; return 0; &#125; public int getB() &#123; return 0; &#125;&#125; 内部类将一个类定义在另一个类里面，里面的那个类就称为内部类 内部类可以直接访问外部类的成员，包括私有成员 外部类要访问内部类的成员，必须要建立内部类的对象 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 内部类不能用普通的方式访问。内部类是外部类的一个成员，因此内部类可以自由地访问外部类的成员变量，无论是否是private的 成员内部类 静态内部类 局部内部类 匿名内部类 本文主要内容转载于：Java 继承详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java入门（四）]]></title>
      <url>%2F2017%2F05%2F28%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
      <content type="text"><![CDATA[equals()与====比较的是两个值是否相等，这里的值分为两种情况： 基本类型的值，即float、double、byte、short、int、long、char、boolean这八种java的基本数据类型，这里比较的就是值本身，举个例子： 123int a=2;int b=2;System.out.printIn(a==b);//结果:true 而对于非基本数据类型（或者说引用类型）的变量，比较的就不是“值”本身，因为引用类型的变量存储的并不是“值”本身，而是预期关联对象在内存中的地址，举个例子： 123456789String str = new String("hello"); String str1 = new String("hello"); String str2 = new String("hello"); System.out.println(str1==str2);//结果为: false，因为str1和str2声明的是两个不同的对象，存储地址自然不同 str1 = str; str2 = str; System.out.println(str1==str2);//结果: true，因为此时str1和str2都指向了同一个对象，存储的地址相同了 equals()equals方法是基类Object中的方法，因此对于所有的继承于Object的类都会有该方法。equals比较的是两个对象的引用是否相等，即是否指向同一个对象，不过看下下面的代码： 1234567891011121314public class Main &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub String str1 = new String("hello"); String str2 = new String("hello"); System.out.println(str1.equals(str2)); &#125;&#125;//结果：true 之所以会变成这样是因为Java的equals方法在用来比较String、Double，Date，Integer等对象时，其内部对equals方法进行了重写（可以直接去看自己JDK的中String.java的源代码，确实是对equals方法进行了重写），使其用来比较指向对象所处的内容是否相等。 小结 对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等,如果作用于引用类型的变量，则比较的是所指向的对象的地址。 对于equals方法，注意：equals方法不能作用于基本数据类型的变量如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址，诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。 本节内容转载于:浅谈Java中的equals和== static、final和static finalfinal final类不能被继承，没有子类，final类中的方法默认是final的 在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会再被扩展，那么就设计为final类 final方法不能被子类的方法覆盖，但可以被继承 如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法 把方法锁定，防止任何继承类修改它的意义和实现 高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率 final成员变量表示常量，只能被赋值一次，赋值后值不再改变 final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量 final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征 final不能用于修饰构造方法 父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的 当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值 例子 1234567891011121314151617181920212223242526272829303132//关于用final修饰方法的情况public class Test1 &#123; public static void main(String[] args) &#123; // TODO 自动生成方法存根 &#125; public void f1() &#123; System.out.println("f1"); &#125; //无法被子类覆盖的方法 public final void f2() &#123; System.out.println("f2"); &#125; public void f3() &#123; System.out.println("f3"); &#125; private void f4() &#123; System.out.println("f4"); &#125; &#125; public class Test2 extends Test1 &#123; public void f1()&#123; System.out.println("Test1父类方法f1被覆盖!"); &#125; public static void main(String[] args) &#123; Test2 t=new Test2(); t.f1(); t.f2(); //调用从父类继承过来的final方法 t.f3(); //调用从父类继承过来的方法 //t.f4(); //调用失败，无法从父类继承获得 &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//关于final修饰成员变量的情况public class Test3 &#123; private final String S = "final实例变量S"; private final int A = 100; public final int B = 90; public static final int C = 80; private static final int D = 70; public final int E; //final空白,必须在初始化对象的时候赋初值 public Test3(int x) &#123; E = x; &#125; /** * @param args */ public static void main(String[] args) &#123; Test3 t = new Test3(2); //t.A=101; //出错,final变量的值一旦给定就无法改变 //t.B=91; //出错,final变量的值一旦给定就无法改变 //t.C=81; //出错,final变量的值一旦给定就无法改变 //t.D=71; //出错,final变量的值一旦给定就无法改变 System.out.println(t.A); System.out.println(t.B); System.out.println(t.C); //不推荐用对象方式访问静态字段 System.out.println(t.D); //不推荐用对象方式访问静态字段 System.out.println(Test3.C); System.out.println(Test3.D); //System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. System.out.println(t.E); Test3 t1 = new Test3(3); System.out.println(t1.E); //final空白变量E依据对象的不同而不同 &#125; private void test() &#123; System.out.println(new Test3(1).A); System.out.println(Test3.C); System.out.println(Test3.D); &#125; public void test2() &#123; final int a; //final空白,在需要的时候才赋值 final int b = 4; //局部常量--final用于局部变量的情形 final int c; //final空白,一直没有给赋值. a = 3; //a=4; 出错,已经给赋过值了. //b=2; 出错,已经给赋过值了. &#125; &#125; 1234567891011//关于final修饰函数参数的情况public class Test4 &#123; public static void main(String[] args) &#123; new Test4().f1(2); &#125; public void f1(final int i) &#123; //i++; //i是final类型的,值不允许改变的. System.out.print(i); &#125; &#125; static static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法 被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享 static对象可以在它的任何对象创建之前访问，无需引用任何对象 用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量 static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用，但是不能在其他类中通过类名来直接引用。原因是private是访问权限限定，static表示不要实例化就可以使用 static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问 用法为： 类名.静态方法名(参数列表…) 类名.静态变量名 static变量 静态变量或类变量 被static修饰的变量 在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的） 实例变量 没有被static修饰的变量 每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活） 静态方法 静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！ 因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract static代码块 也叫静态代码块 是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次 1234567891011121314151617181920212223242526272829303132333435363738//static代码块的例子public class Test5 &#123; private static int a; private int b; static &#123; Test5.a = 3; System.out.println(a); Test5 t = new Test5(); t.f(); t.b = 1000; System.out.println(t.b); &#125; static &#123; Test5.a = 4; System.out.println(a); &#125; public static void main(String[] args) &#123; // TODO 自动生成方法存根 &#125; static &#123; Test5.a = 5; System.out.println(a); &#125; public void f() &#123; System.out.println("hhahhahah"); &#125; &#125;//结果：//3//hhahhahah//1000//4//5 static final static final用来修饰成员变量和成员方法，可简单理解为“全局常量” 对于变量，表示一旦给值就不可修改，并且通过类名可以访问 对于方法，表示不可覆盖，并且可以通过类名直接访问 对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多 例子123456789101112131415161718192021222324252627282930313233343536373839public class TestStaticFinal &#123; private static final String strStaticFinalVar = "aaa"; private static String strStaticVar = null; private final String strFinalVar = null; private static final int intStaticFinalVar = 0; private static final Integer integerStaticFinalVar = new Integer(8); private static final ArrayList&lt;String&gt; alStaticFinalVar = new ArrayList&lt;String&gt;(); private void test() &#123; System.out.println("-------------值处理前----------\r\n"); System.out.println("strStaticFinalVar=" + strStaticFinalVar + "\r\n"); System.out.println("strStaticVar=" + strStaticVar + "\r\n"); System.out.println("strFinalVar=" + strFinalVar + "\r\n"); System.out.println("intStaticFinalVar=" + intStaticFinalVar + "\r\n"); System.out.println("integerStaticFinalVar=" + integerStaticFinalVar + "\r\n"); System.out.println("alStaticFinalVar=" + alStaticFinalVar + "\r\n"); //strStaticFinalVar="哈哈哈哈"; //错误，final表示终态,不可以改变变量本身. strStaticVar = "哈哈哈哈"; //正确，static表示类变量,值可以改变. //strFinalVar="呵呵呵呵"; //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 //intStaticFinalVar=2; //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 //integerStaticFinalVar=new Integer(8); //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 alStaticFinalVar.add("aaa"); //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 alStaticFinalVar.add("bbb"); //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 System.out.println("-------------值处理后----------\r\n"); System.out.println("strStaticFinalVar=" + strStaticFinalVar + "\r\n"); System.out.println("strStaticVar=" + strStaticVar + "\r\n"); System.out.println("strFinalVar=" + strFinalVar + "\r\n"); System.out.println("intStaticFinalVar=" + intStaticFinalVar + "\r\n"); System.out.println("integerStaticFinalVar=" + integerStaticFinalVar + "\r\n"); System.out.println("alStaticFinalVar=" + alStaticFinalVar + "\r\n"); &#125; public static void main(String args[]) &#123; new TestStaticFinal().test(); &#125; &#125; 运行结果如下： -------------值处理前---------- strStaticFinalVar=aaa strStaticVar=null strFinalVar=null intStaticFinalVar=0 integerStaticFinalVar=8 alStaticFinalVar=[] -------------值处理后---------- strStaticFinalVar=aaa strStaticVar=哈哈哈哈 strFinalVar=null intStaticFinalVar=0 integerStaticFinalVar=8 alStaticFinalVar=[aaa, bbb] Process finished with exit code 0 通过static final修饰的容器类型变量中所“装”的对象是可改变的。这是和一般基本类型和类类型变量差别很大的地方 本节内容转载于：Java关键字final、static使用总结 对象和对象句柄的区别12345678910class value&#123; int i;&#125;public class EqualsMethod&#123; public static void main(string[] args)&#123; value v1=new value(); value v2=new value(); vl.i=v2.i=100; &#125;&#125; 如以上代码： value v1和value v2声明了两个value类型的句柄 然后通过new操作符实例化了v1、v2这两个对象 注意：经过上面的操作，对象是确实已经被声明且实例化出来了，但是我们并不能直接的去操纵对象实例，你可能会问，v1和v2不就是对象了吗？不是的，v1和v2只是两个标识符，代表的是两个指向对象实例的句柄，我们通过句柄访问对象实例，使用v1.i时对v1执行的对象的i进行赋值就是这个道理。它们指向的对象我们实际上是看不到的。 举个比较贴近生活的浅显易懂的例子：就好比遥控器和电视的关系，电视是对象实例，而遥控器就是这个对象的句柄，我们通过遥控器来控制电视的音量或者换台等等，电视一直摆在那，我们直接控制不了（不要钻牛角尖），而遥控器我们可以随意拿来拿去，通过它来控制电视的相关内容。另外，遥控器可以独立于电视机而存在，即句柄可以被声明出来，只是没有连接对象而已，比如：String str;，这就是声明了一个还未连接任何对象的String类型的句柄。 这样解释应该就懂了，value v1和value v2是声明了两个value类型的变量（句柄），还没有与任何对象关联，new value()则真正的产生了一个value类型的对象，使用value v1=new value();是将句柄与对象进行了绑定操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux常用命令介绍]]></title>
      <url>%2F2017%2F05%2F14%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[Git Bash的一些命令是Linux的命令，虽然使用的是windows系统，但因为使用git bash，所以还是得了解一些常用的Linux命令操作 删除文件夹rm -rf 目录名 r表示向下递归不管多少级，一并删除；f表示直接强行删除，不说任何提示的意思 查看文件内容cat 文件名 新建文件夹mkdir 文件夹名 新建文件touch 文件名.格式后缀 查看文件夹下所有文件ls -al]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[什么是wiki]]></title>
      <url>%2F2017%2F05%2F14%2F%E4%BB%80%E4%B9%88%E6%98%AFwiki%2F</url>
      <content type="text"><![CDATA[github如何使用wiki，github上每个仓库偶有自己的wiki，用github自己的帮助文档中的话来说就是： 每个GitHub存储库都配备了一个托管文档的部分，称为wiki。GitHub Wiki是您的存储库中的一个地方，您可以在其中分享关于您的项目的长形内容，例如如何使用它，如何设计，阐述其核心原则等。而README旨在使读者快速了解您的项目可以做什么，wiki可用于提供其他文档 简单介绍wiki它其实是一种新技术，一种超文本系统。这种超文本系统支持面向社群的协作式写作，同时也包括一组支持这种写作的辅助工具。也就是说，这是多人协作的写作工具。而参与创作的人，也被称为维客。 从技术角度看，Wiki是一种超文本系统，是任何人都可以编辑网页的社会性软件。Wiki包含一套能简易创造、改变HTML网页的系统，再加上一套纪录以及编目所有改变的系统，以提供还原改变的功能。利用Wiki系统构建的网站称为Wiki网站，称之为维基主页；“客”隐含人的意思，所以使用Wiki的用户称之为维客（Wikier）。 从使用者角度看，Wiki是一种多人协作的写作工具系统，属于一种人类知识的网络管理系统。Wiki站点可以有多人（甚至任何访问者）维护，每个人都可以发表自己的意见，或者对共同的主题进行扩展或者探讨。 在维客页面上，每个人都可浏览、创建、更改文本，系统可以对不同版本内容进行有效控制管理，所有的修改记录都保存下来，不但可事后查验，也能追踪、回复至本来面目。这也就意味着每个人都可以方便地对共同的主题进行写作、修改、扩展或者探讨。同一维客网站的写作者自然构成了一个社群，维客系统为这个社群提供简单的交流工具。 Wiki的特点 使用方便 维护快捷：快速创建、存取、更改超文本页面（这也是为什麼叫作 “wiki wiki” 的原因）。 格式简单：用简单的格式标记来取代 HTML 的复杂格式标记。（类似所见即所得的风格） 链接方便：通过简单标记，直接以关键字名来建立链接（页面、外部连接、图像等）。 命名平易：关键字名就是页面名称，并且被置於一个单层、平直的名空间中。 可增长：页面的链接目标可以尚未存在，通过点击链接，我们可以创建这些页面，从而使系统得以增长。 修订历史：记录页面的修订历史，页面的各个版本都可以被获取。 开放的：社群内的成员可以任意创建、修改、或删除页面。 可观察：系统内页面的变动可以被来访者清楚观察得到。 补充Wiki也指一种超文本系统，支持面向社群的协作式写作，也就是每个人都可以改这个网站的数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Wampserver3.0局域网访问设置方法]]></title>
      <url>%2F2017%2F05%2F14%2FWampserver3.0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在wampserver3.0上跑起来的站点怎么设置才能让局域网中的设备访问到，各个步骤网上都有教程，我就直接帖网址了 首先应该设置wampserver使其本身支持局域网访问,方法如下： WampServer3.0.4 允许外网访问配置教程。注意要将wampserver调成在线模式 这样下来，有的时候还是不能访问，那是因为你电脑的防火墙把你站点的端口的外部接入响应阻止了，最简单的方法是关掉防火墙，另外也可以设置防火墙开放你网站的端口号，方法如下： win7系统如何在防火墙里开放端口。win10设置方法也一样，大同小异。 设置完后，就可以通过局域网设备访问了，方法是在想连接的设备上搜索url：“http://电脑（服务器主机）的IP地址：端口号”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端行业的你需要哪些网站]]></title>
      <url>%2F2017%2F05%2F11%2F%E5%89%8D%E7%AB%AF%E8%A1%8C%E4%B8%9A%E7%9A%84%E4%BD%A0%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E7%BD%91%E7%AB%99%2F</url>
      <content type="text"><![CDATA[除了肯定会逛的掘金、CSDN、知乎等技术论坛。 技术社区Stackoverflow是一个与程序相关的IT技术问答网站。用户可以在网站免费提交问题，浏览问题，索引相关内容，在创建主页的时候使用简单的HTML。在问题页面，不会弹出任何广告，销售信息，JavaScript 窗口等。有这么一个说法：“作为一名程序员，如果没有听过 Stackoverflow，那么你最好去面壁思过一下。” Segmentfault是一家中文的开发者社区及媒体。最初的产品原型来自于国外最大的程序员问答社区 Stackoverflow，但其产品形态经过一年多的发展，已经有问答、博客、活动等，它还是多个黑客马拉松活动的组织方 提高开发效率teambition是一个简单,高效的项目协作工具,你可以在这里管理项目,跟踪任务进度,存储项目文件,让你的团队协作更高效 tower功能与teambition差不多 Travis CI自动测试系统,CI意思为持续集成，Travis可以将你github上的项目自动编译，有人提交即可执行编译让你第一时间知道提交是否OK Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。具体介绍看官方文档 社交类领英全球最大的职业社交网站，是一家面向商业客户的社交网络（SNS） Github全球最大的男性交友平台，毫无疑问，不需要解释 设计灵感UI中国前身为 iconfans,是专业的 UI 设计师交流、学习与展示的平台。会员均为职业 UI 设计师,覆盖全国互联网公司。 Behance著名设计社区，在上面，创意设计人士可以展示自己的作品，发现别人分享的创意作品（上面有许多质量上乘的设计作品），相互还可以进行互动（评论、关注、站内短信等） 乐乎国内优质图片社交平台 管理百度脑图画思维导图的，有棵树在那帮你保存总比放脑子里忘了好，百度脑图简单方便，还是在线的，还算不错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysql数据库基本使用]]></title>
      <url>%2F2017%2F05%2F10%2FMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[太久没有用命令行操作Mysql,今天有个项目想用下都不知道怎么用了，都是些最近本的东西，把这些坑记下来吧。 记得本地的Mysql数据库服务（当然下面要将的第一条是要求不能启动，我说的是正常操作的情况下，的启动Mysql服务才行），启动方法是，win+R代开运行窗口之后输入services.msc，打开服务功能视图，找到MySQL那个选项，将它启动就可以了。 忘记登录密码怎么办直接看这里吧，挺好的一个教程 教程中是还要进到mysql安装目录的bin文件夹下，运行mysql.exe，这是没有添加系统环境变量的缘故，把bin文件夹的目录路径添加到环境变量的path中就行，具体过程就不多说了，自己百度。添加了之后，就能在cmd的任意地方输入mysql登陆命令直接登陆mysql而不用一定得在bin目录下才可以。 教程最后还讲了绕过用户认证登陆后进行更改密码的操作，这也不失为一种更改密码的方法，不过更改完后必须重新启动数据库服务才能生效，记住是services.msc里面的数据库服务，而不是简单地把cmd窗口打开再关掉。 注意，mysql数据库初始状态有个示例账户，是不需要账户名和密码就能登陆的，但是数据库却只有示例的数据库，并不是真正的账户里面的数据库信息。所以不要在命令行输入mysql后出现mysql欢迎信息就以为自己已经成功登陆了，其实只是个让你来看看mysql示例数据库的账号而已。虽然也可以用，但是还是自己的账号好，毕竟自己的账号有用户名和密码，你用个没名没分的账号来操作数据库心里也难免有种不安全感。 怎么登陆在命令窗口输入：mysql -u用户名 -p密码 这样就能登陆了，在此之前记得像最开始说的先启动mysql服务，另外注意-u和用户名之间没有空格，-p和密码之间也没有空格 更改用户密码mysqladmin -u用户名 -p旧密码 password 新密码 查看mysql版本方法一命令窗口下：mysql –version 方法二登录mysql后输入：status;或者输入：select version(); 查看端口号登录mysql后输入：show global variables like ‘port’; 基本命令查看当前用户下的数据库show databases; 选中某个数据库（决定对某个数据库进行操作）use 数据库名; 查看数据库中都有什么表show tables;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github团队协作基础教程]]></title>
      <url>%2F2017%2F05%2F08%2FGithub%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[创建组织既然是团队项目，说明该项目是属于某个组织的，应该先建立一个组织，如下图： 进入组织的创建页面，填好组织名称和接收的消息的邮箱，这里我们将组织名称命名为TestWebTeam，选免费的方案，如果是真正的公司，则就会付费去创建一个组织，因为有些内容不能公开。点击create organization即完成组织的创建。（注意组织名称不能重复，接收邮箱必须添加） 点击创建后会进入成员邀请页 ，我们先直接点击finish跳过，只有再进行邀请。 这样组织就创建完成了。 创建小组组织就是现实意义上的组织，一个组织内部可以有很多个小组，他们之间可以共享一些仓库，拥有对不同仓库不同的控制权限，我们下面来创建一个小组，比如说这小组叫Designer，即设计小组。点击team,r然后点击create new team 进入小组创建页，填写小组名称Team name和小组描述Description,Team visibility是用户显示的内容，英语都看得懂就不说了，默认选第一个。然后点击create创建。 这就小组创建成功了，可以通过addmember来搜索github用户添加组员 创建和配置代码仓库权限组织有了，组织内部的开发小组也有了，需要的就是代码仓库了，一个组织可以有多个代码仓库，下面先创建一个，组织主页，点击创建新的仓库。（另外也可以像建个人仓库一样点击右上角的加号创建仓库，只是到时候将所属对象从个人改成目的组织就行了） 跟创建个人仓库没什么区别，只是owner变了，仓库名字命名为TestRepository 创建成功，点击setting给这个仓库指定哪些小组可以使用，并规定访问权限 中途会让你输入用户密码，输入就是了。然后左边选择Collaborators&amp;team、右边选择team，选择select team添加可以操作该仓库的小组。 添加完后，可以编辑该小组使用该仓库时的权限，三个权限，既然是想让小组来用这个代码仓库，则选择write即可，admin权限将使所有小组成员变成该项目管理员，可以随意编辑该仓库的设置，慎重选择。 下面的collaborators是添加该仓库的个人协作者（区别于小组），可自行扩展 为小组创建Pull Request组织通过Pull Request进行代码检查，当你对代码进行更改时可以邀请你的小组审核你的更改并提供反馈。下面来创建一个小的Pull Request，主要是对我们之前创建的代码仓库TestRepository的README文件进行更改。 移到最下面，添加主要提交的描述以及选择创建一个新的分支，因为我们要使用pull request，如果选第一个选项就直接合并到主分支去了 点击propose file change,进入open a pull prequest界面，这个页面是让你来更加详细的描述这次更改的原因，以及更改了什么地方，另外还可以用“@”来通知全体组员（就像QQ的@全体成员），让他们知道你的这次pull request 然后点击create pull request,这样小组的所有成员就都将知道你创建了一个pull request Pull Request的作用鉴于有些人可能不大清楚Pull Request的作用，下面来讲一下。 要打开一个pull request必须先拥有一个带有更改的分支，所以pull request适合团队工作，因为个人的话一般会一直工作在主分支上。 Pull Request用于提出对项目的更改，是一个开始提交讨论的方式，经常用于代码审查当中，如果是 一个人工作，则可能用Pull Request比较少，因为个人可以通过git命令推送更改到主分支中，并不 存在其他的分支，但如果在公司项目或者开源项目这种团队工作的情况下，就必须使用Pull Request了。 Pull Request是在开发者在创建一个区别于master的分支并进行相应的更改之后，想仓库管理者提出的将自己的分支（即更改内容）合并到主分支的一个请求，发出的这个请求可以被可访问这个仓库的所有人看见，并进行讨论，看是否合并、更改是否合理等等。即Pull Request用于对正在更改的代码仓库的讨论。 拿上面创建的pull request为例： 有三个视图，conversation视图用来讨论这次的更改 commit 提交视图包含了有关谁对这个文件进行更改的信息，每个提交都被记录到这个视图中，让我们知道提交前后发生了什么变化 files changed 文件更改视图，用来查看文件的更改记录。绿色表示已经添加的内容，红色表示内容被删除 那如何合并分支，对于公司，一般会有人来签署更改，但如果是个人在自己仓库的操作，则自己就可以进行合并操作，在coversation视图点击merge pull request就可以将这个提交合并到主分支了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现console.log不换行输出的方法]]></title>
      <url>%2F2017%2F05%2F06%2F%E5%AE%9E%E7%8E%B0console-log%E4%B8%8D%E6%8D%A2%E8%A1%8C%E8%BE%93%E5%87%BA%2F</url>
      <content type="text"><![CDATA[有点标题党的感觉，因为console.log()是无法实现不换行输出的，每执行一次console.log()都会自动占据一行。不过我们可以改变我们的输出思路。 用数组以及其方法：toString(),join(),reverse()来解决。 例子： 1234for(var i=0;i&lt;3;i++)&#123; console.log(i);&#125; 结果将是： 0 1 2 但我们想在一行内输出：0,1,2或者0–&gt;1–&gt;2或者2,1,0该怎么办？相信看来最开始我说的用数组及其方法的应该已经想到了。 先用一个数组把想输出的内容存储下来，之后再用相关的数组方法将其打印就可以了。 例子： 12345678910var A=[],k=0;for(var i=0;i&lt;3;i++)&#123; A[k]=i; k++;&#125;console.log(A.toString());console.log(A.reverse().join('--&gt;')); 很明显，结果将是： 0,1,2 2–&gt;1–&gt;0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js实现简单排序算法]]></title>
      <url>%2F2017%2F04%2F29%2FJs%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[这里用JavaScript实现冒泡排序、选择排序、插入排序、归并排序以及快速排序这些基本的排序算法 首先我们给本文约定一个实现的框架：定义一个ArrayList类里面包含排序数组声明、数组元素添加、排序算法实现以及数组输出的方法。 代码框架： 123456789101112131415161718192021222324function ArrayList()&#123; var array=[]; this.inputArraymember=function()&#123; //将10个大小在1~15的随机数添加到数组中 var ins=0; for(var i=0;i&lt;10;i++)&#123; ins=Math.floor(Math.random()*15+1); array.push(ins); &#125; &#125;; this.相应的排序算法=function()&#123;...算法的具体实现代码...&#125;; //代码块替换部分 this.toString=function(separator)&#123; //将数组按指定分隔符生成字符串方便输出 return array.join(separator); &#125;;&#125;var a = new ArrayList();a.inputArraymember();console.log("随机生成的原始数组为："+a.toString('-'));a.bubbleSort();console.log("排序后数组为："+a.toString('-')); 冒泡排序用两层循环，第一层用来记录剩余的还未排序的数的个数，第二层用来在剩下的未排序的数中找到最大的数并将其放到未排序数的最后面（冒泡）。 代码实现： 12345678910this.bubbleSort=function()&#123; var length=array.length; for(var i=0;i&lt;length;i++)&#123; for(var j=0;j&lt;length-1-i;j++)&#123; if(array[j]&gt;array[j+1])&#123; var t=array[j]; array[j]=array[j+1];array[j+1]=t; &#125; &#125; &#125;&#125;; 冒泡排序的时间复杂度是O(n&sup2;)。将以上代码替换文章开始约定的代码框架中的“代码块替换部分”即可用于在调试工具中运行查看代码运行结果。 选择排序思路很简单，每次都找出未排序的数当中最小的数并放在开头，直到所有数的位置确定下来。说清楚点就是从所有序列中先找到最小的，然后放到第一个位置。之后再看剩余元素中最小的，放到第二个位置……以此类推。 代码实现： 1234567891011121314151617this.selectsort=function()&#123; var length=array.length,currentMin; for(var i=0;i&lt;length-1;i++)&#123; //每循环一趟就会有一个数得到排序 currentMin=i; //用来记录最小数的下标，默认为最开始的未排序的元素下标 for(var j=i;j&lt;length;j++)&#123; if(array[currentMin]&gt;array[j])&#123; currentMin=j; &#125; &#125; if(i!==currentMin)&#123; //若下标不是未排序的最开始的那个元素的下标，则将两者的值交换 var t=array[currentMin]; array[currentMin]=array[i]; array[i]=t; &#125; &#125;&#125;; 可看出，选择排序也用了两个嵌套着的循环，所以时间复杂度也是O(n&sup2;)，是一种原址排序。 插入排序从第二个数开始（因为第一个数只有一个，前面没得比。），与前面的数挨个比较，直到找到前一个数比当前值小，后一个数比当前值大的位置，让后将当前值置于此处，以此类推。 代码实现： 12345678910111213this.insertsort=function()&#123; var length=array.length, j,temp; for(var i=1;i&lt;length;i++)&#123; j=i; temp=array[i]; //先存储待比较的数 while(j&gt;0&amp;&amp;array[j-1]&gt;temp)&#123; //如果这个数比上一个数小，则让上一个数占据现在这个数的位置（右移每个比当前数小的数） array[j]=array[j-1]; j-- &#125; array[j]=temp; //直到这个数不比上一个数小的时候，将这个数放在当前的位置 &#125;&#125;; 归并排序时间复杂度为O(nlogn)。归并用的是分治的思想，将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着讲小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142 this.mergeSort=function() &#123; array = mergeSortRec(array); &#125;;//建堆函数，将数组一直拆分成两部分，直到各部分数组长度都为1的时候停止，然后进行merge操作 var mergeSortRec = function(array)&#123; var length = array.length; if (length === 1) &#123; return array; &#125; var mid = Math.floor(length / 2), left = array.slice(0, mid),//slice() 方法可从已有的数组中返回选定的元素,语法 arrayObject.slice(start,end) right = array.slice(mid, length); return merge(mergeSortRec(left), mergeSortRec(right)); &#125;;//将各部分进行归并 var merge = function(left, right) &#123; var result = [], il = 0, ir = 0; while(il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; if (left[il] &lt; right[ir]) &#123; result.push(left[il++]); &#125; else &#123; result.push(right[ir++]); &#125; &#125; //如果il数组还有剩余，则将其剩余部分添加到结果数组中 while (il &lt; left.length) &#123; result.push(left[il++]); &#125; //如果ir数组还有剩余，则将其剩余部分添加到结果数组中 while (ir &lt; right.length) &#123; result.push(right[ir++]); &#125; return result; &#125;; 快速排序时间复杂度为O(logn)。用的是分治的思想。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 this.quickSort = function()&#123; quick(array, 0, array.length - 1); &#125;; var partition = function(array, left, right) &#123; //划分过程//主元的选择方法最好是随机选择一个数组想或是选择中间项，这里选择中间项 var pivot = array[Math.floor((right + left) / 2)], i = left, j = right; console.log('pivot is ' + pivot + '; left is ' + left + '; right is ' + right); while (i &lt;= j) &#123; while (array[i] &lt; pivot) &#123; i++; console.log('i = ' + i); &#125; while (array[j] &gt; pivot) &#123; j--; console.log('j = ' + j); &#125; if (i &lt;= j) &#123; console.log('swap ' + array[i] + ' with ' + array[j]); swapQuickStort(array, i, j); i++; j--; &#125; &#125; return i; &#125;; var swapQuickStort = function(array, index1, index2)&#123; var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux; &#125;; var quick = function(array, left, right)&#123;//将子数组分离为较小值数组和较大值数组 var index; if (array.length &gt; 1) &#123; index = partition(array, left, right); if (left &lt; index - 1) &#123; quick(array, left, index - 1); &#125; if (index &lt; right) &#123; quick(array, index, right); &#125; &#125; return array; &#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript数组介绍]]></title>
      <url>%2F2017%2F04%2F27%2FJavaScript%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[JavaScript的数组中的元素可以具有不同的类型，即var a=[&#39;hello&#39;,12,&#39;kk&#39;];是合法的。 对于一维数组，可直接用console.log(数组名)来输出数组内容，若是多维数组则需要自行构建函数来输出 创建和初始化数组123456var everyday=new Array();var everyday=new Array();var everyday=new Array('hello','world',123,'china');var evaryday=[];var evaryday=['hello','world',123,'china']; 可使用everyday.length来获得数组的长度 添加和删除数组元素添加到数组末尾123everyday[everyday.length]='新元素';或everyday.push('新元素1','新元素2'); 添加到数组首部1eveday.unshit('新元素1','新元素2'); 删除最靠后元素1everyday.pop(); 用push()和pop()可以用数组来模拟栈 删除第一个元素1everyday.shift(); 用shift()和unshift()可以用数组模拟队列 删除任意位置的元素1everyday.splice(2,3); 注解：表示删除了从下标2的元素开始往后的两个元素（包括下标为2的），即everyday[2]、everyday[3]、everyday[4]。 插入任意为位置 任意值1everyday.splice(2,0,5,3,6) 注释：这才是splice()函数的完整用法。第一个参数是要执行删除操作的开始下标，第二个是要删除的个数，咱现在目的是为了添加，所以写0，第三个参数及以后则是要新添加的元素，此例执行后everyday[2]值变成5，以此类推。 二维和多维数组JavaScript只支持一维数组，但由于JavaScript数组对元素类型的宽容性，我们可以采用数组套数组的方法来实现多维数组。 12345678var a1=[];a1[0]=['hello',23,'world'];a1[2]=['china','england'];或var a2=[];a2[0]=[];a2[0][0]='hello';a2[0][1]='woeld'; 此时用console.log(a2)将不能输出数组内容，因为console.log()之只能用来输出具体的元素，应该自行创建一个函数来简化输出 123456789function printfMatrix(myMatrix)&#123;for(var i=0;i&lt;myMatrix.length;i++)&#123; for(var j=0;j&lt;myMatrix[i].length;j++)&#123; console.log(myMatrix[i][j]); &#125; &#125;&#125;printfMatrix(数组名); 操作数组的方法（函数）数组合并–concat方法 按照指定的顺序连接起来，很好理解 迭代器函数every方法every会迭代数组中的每一个元素，直到返回false 注释：给每个元素迭代执行zhengshu这个方法（是小于0则继续迭代，直到遇到正数，返回false） some方法every会迭代数组中的每一个元素，直到返回true 注释：给每个元素迭代执行zhengshu这个方法（是大于0则继续迭代，直达遇到负数，返回true） forEach方法foreach会迭代整个数组的元素 map方法map会生成一个数组，用来保存迭代所有元素时产生的结果 filter方法filter会生成一个新数组，用来保存迭代所有元素时时函数返回true的元素 reduce方法reduce接收一个函数作为参数，这个函数有四个参数：prevousValue、currentValue、index和array。这个函数会返回一个将被叠加到累加器的值，reduce方法停止执行后返回这个累加器。如果要对一个数组中的所有元素求和，这就很有用。 搜索和排序数组反序–reverse方法就是将原本数组元素的排列顺序颠倒 数组自动排序–sort方法sort在排序的时候，是默认把元素当成字符串来比较。比如底下这样用就会出错： 那应该怎么办？ 自己写比较函数 123var a=[2,6,18,19,1];console.log(a.sort(function(a,b)&#123;return a-b;&#125;)); 主要的是代码a.sort(function(a,b){return a-b;})，此代码表示当a小于b时返回负数，当a大于b时返回正数，相等时放回0，这样sort方法就会根据返回值的情况给数组排序，当然这行代码额可以改写成比较好理解的以下以下代码： 注意比较函数的调用方法（没有传参） 自定义排序可以创建任何对象类型的数组排序，也可以创建compareFunction来比较元素： 12345678910111213var person=[&#123;name:'小明',age:15&#125;,&#123;name:'小王',age:14&#125;,&#123;name:'小东',age:18&#125;];function comparePerson(a,b)&#123; if(a.age&lt;b.age)&#123; return -1; &#125; if(a.age&gt;b.age)&#123; return 1; &#125; return 0;&#125;console.log(person.sort(comparePerson)); 结果: 字符串排序对于字符创的比较，sort是根据ASCII值来比较的，比如： 即Jmn会排在apple的前面，如果我们想让它排序正确，则需要自己写一个忽略大小写的比较函数： 搜索 indexOf()方法：返回与参数匹配的第一个元素的索引 lastIndexOf()方法：返回与参数匹配的最后一个元素的索引。 例子： 结果分析，前两个没什么好说的，第三个查找10，因为没有这个元素，所以返回-1 输出数组为字符串及指定分隔符 toString()将数组里的所有元素输出为一个字符串 join()用一个不同的分隔符把元素隔开 例子： 是否改变原数组及操作后返回值 本题需要将数组a=[1,2,3]变成[1,2,3,4],需要改变原数组a。 Array对象常用方法中： 不改变原数组： 1、 concat() 连接两个或多个数组 不改变原数组 返回被连接数组的一个副本 2、join() 把数组中所有元素放入一个字符串 不改变原数组 返回字符串 3、 slice() 从已有的数组中返回选定的元素 不改变原数组 返回一个新数组 4、 toString() 把数组转为字符串 不改变原数组 返回数组的字符串形式 改变原数组： 5、 pop() 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined 改变原数组 返回被删除的元素 6、 push() 向数组末尾添加一个或多个元素 改变原数组 返回新数组的长度 7、 reverse() 颠倒数组中元素的顺序 改变原数组 返回该数组 8、 shift() 把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined 改变原数组 返回第一个元素的值 9、 sort() 对数组元素进行排序(ascii) 改变原数组 返回该数组 10、 splice() 从数组中添加/删除项目 改变原数组 返回被删除的元素 11、 unshift() 向数组的开头添加一个或多个元素 改变原数组 返回新数组的长度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 Canvas入门]]></title>
      <url>%2F2017%2F04%2F26%2FHTML5-Canvas%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Canvas元素本身没有绘图能力，所有的绘图工作必须在JavaScript内部完成。拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 直接上代码。 绘制2d线条 先在html页面下添加Canvas元素。设定画布的id和宽高。 1&lt;canvas id="myCanvas" width="200" height="100" style="border:1px solid #000;"&gt;&lt;/canvas&gt; 用JavaScript在画布上面绘制图像 123456789 // 获得画布 var c=document.getElementById("huabu"); // 创建基于所获得画布的2d画笔 var pan= c.getContext("2d"); pan.moveTo(10,10);//移动画笔 pan.lineTo(40,40);//从源点绘制到指定点（30,40）pan.lineTo(50,100);//从源点绘制到指定点（50,100） pan.lineTo(150,20); pan.stroke();//之前是在构建，这里是把构思正式画到画布上，一定要这一步 结果 注意 如果想绘制两条线，不能想当然的moveTo(),然后再lineTo()，应该再声明一支画笔 12345var pan2= c.getContext("2d"); pan2.moveTo(40,10);pan2.lineTo(30,60); pan2.lineTo(188,170); pan2.stroke(); 结果：（绘制两条线） 绘制圆形 先在html页面下添加Canvas元素。设定画布的id和宽高。 1&lt;canvas id="myCanvas" width="200" height="100" style="border:1px solid #000;"&gt;&lt;/canvas&gt; 用JavaScript在画布上面绘制图像 12345678910111213 //获得画布var c=document.getElementById("huabu");var pan= c.getContext("2d");//设置图形填充的颜色pan.fillStyle='#00f';//开始绘制图形pan.beginPath();//arc是圆的英文前几个字母//括号内指定（圆心x轴坐标、圆心y轴坐标、圆半径、开始角度、结束角度、顺时针(false)还是逆时针(true)）pan.arc(100,100,50,0,Math.PI/2,true);//结束绘图pan.closePath();pan.fill();//一定要有，将构建好的图形正式填充到画布上去 学习以下代码 获得2d画笔后，用beginPath()方法绘制新路径 用strokeStyle指定路径颜色 arc()设置圆的属性 stroke()绘制弧线 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;HTML5 Canvas绘制弧线入门示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 添加canvas标签，并加上红色边框以便于在页面上查看 --&gt;&lt;canvas id="myCanvas" width="400px" height="300px" style="border: 1px solid red;"&gt;您的浏览器不支持canvas标签。&lt;/canvas&gt;&lt;script type="text/javascript"&gt;//获取Canvas对象(画布)var canvas = document.getElementById("myCanvas");//简单地检测当前浏览器是否支持Canvas对象，以免在一些不支持html5的浏览器中提示语法错误if(canvas.getContext)&#123; //获取对应的CanvasRenderingContext2D对象(画笔) var ctx = canvas.getContext("2d"); //开始一个新的绘制路径 ctx.beginPath(); //设置弧线的颜色为蓝色 ctx.strokeStyle = "blue"; var circle = &#123; x : 100, //圆心的x轴坐标值 y : 100, //圆心的y轴坐标值 r : 50 //圆的半径 &#125;; //沿着坐标点(100,100)为圆心、半径为50px的圆的顺时针方向绘制弧线 ctx.arc(circle.x, circle.y, circle.r, 0, Math.PI / 2, false); //按照指定的路径绘制弧线 ctx.stroke();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 给画布添加图像1234567891011&lt;script type="text/javascript"&gt;var c=document.getElementById("myCanvas");var cxt=c.getContext("2d");var img=new Image()img.src="image.png"//drawImage(图像元素，左上角顶点x轴坐标，左上角顶点y轴坐标)cxt.drawImage(img,0,0);&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS动画入门]]></title>
      <url>%2F2017%2F04%2F26%2FCSS%E5%8A%A8%E7%94%BB%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[css3常用动画+动画库 transitionCSS过渡 介绍俗称“过渡”，是指某元素从一种样式逐渐转变为另一种样式的过程。即用于转换元素两个不同的状态，这个转换过程（或者说触发过程）可以是伪类比如:hover, :active 或者是通过 javascript 动态设定。IE10+支持 transitionz是简写，主要包含的是一下属性。 用法必须规定了两个属性 要添加过渡效果的属性 效果转换的持续时间 多个属性转换用逗号隔开 例子12345678910111213141516171819&lt;!--HTML--&gt; &lt;div id="zi"&gt;&lt;/div&gt;&lt;!--CSS--&gt;#zi&#123; height:100px; width: 100px; background-color: yellow; transition: width 2s,height 2s,color 2s;&lt;!--不同属性效果用逗号隔开--&gt; -webkit-transition: width 2s,height 2s,background-color 2s;-o-transition: width 2s,height 2s,background-color 2s; -moz-transition: width 2s,height 2s,background-color 2s;&#125;#zi:hover&#123; background-color: red; height: 150px; width: 200px;&#125; animationCSS动画 介绍animation属性结合@keyframes规则,能创建由当前样式逐渐改为新样式的动画效果。Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。 用法@keyframes创建动画并制定动画的名字（随便起，主要是用来给animation选择），animation中选择相应的动画名字来使用对应的动画，还要设置动画执行的持续时间，还可设置所选动画的执行方式。即： @keyframes 用于创建动画 用法： 规定动画名，内容为from某种样式to某种样式，还要设置不同浏览器的前缀。也可以不用from-to而是直接用百分比来划分时间，进而规定特定时间内的动画样式。 “from” 和 “to”，等同于 0% 和 100%，0% 是动画的开始，100% 是动画的完成 例1： 例2： animation 用于选择动画并规定动画的执行方式 用法： 必须固定的有动画名称和动画时长 另外还可以添加其他规定项： 例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:100px;height:100px;background:red;position:relative;animation-name:myfirst;animation-duration:5s;animation-timing-function:linear;/*表示变换速度，linear表示从头到尾匀速*/animation-delay:2s;animation-iteration-count:infinite;/*表示动画无限次循环，可改为常数来规定执行次数*/animation-direction:alternate;animation-play-state:running;/* Firefox: */-moz-animation-name:myfirst;-moz-animation-duration:5s;-moz-animation-timing-function:linear;-moz-animation-delay:2s;-moz-animation-iteration-count:infinite;-moz-animation-direction:alternate;-moz-animation-play-state:running;/* Safari and Chrome: */-webkit-animation-name:myfirst;-webkit-animation-duration:5s;-webkit-animation-timing-function:linear;-webkit-animation-delay:2s;-webkit-animation-iteration-count:infinite;-webkit-animation-direction:alternate;-webkit-animation-play-state:running;/* Opera: */-o-animation-name:myfirst;-o-animation-duration:5s;-o-animation-timing-function:linear;-o-animation-delay:2s;-o-animation-iteration-count:infinite;-o-animation-direction:alternate;-o-animation-play-state:running;&#125;@keyframes myfirst&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 也可以将animation简写成： animation：动画名称 持续时间 执行速度变化 动画延迟 循环次数 是否下一周期逆向播放 div { width:100px; height:100px; background:red; position:relative; animation:myfirst 5s linear 2s infinite alternate; /* Firefox: */ -moz-animation:myfirst 5s linear 2s infinite alternate; /* Safari and Chrome: */ -webkit-animation:myfirst 5s linear 2s infinite alternate; /* Opera: */ -o-animation:myfirst 5s linear 2s infinite alternate; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Powershell基本命令]]></title>
      <url>%2F2017%2F04%2F26%2FPowershell%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[Powershell是微软在cmd基础上改进后推出的励志于提高用户开发体验的命令行程序，可以这么说，cmd有的Powershell全都有，Powershell有的cmd不全有，而且Powershell还比cmd漂亮，为什么不用呢。稍微讲下Powershell的基本命令。 Powershell用的时候会出现中文乱码，用以下命令把Encoding改成UTF8即可：$OutputEncoding = New-Object -typename System.Text.UTF8Encoding 注意命令中的空格,。以下命令均默认在要进行操作的文件夹下进行，如果不是在要操作的文件目录下，请自行在操作项目前添加文件路径。 创建文件夹mkdir Folder 创建文件dir &gt; a.txt 向文件内写入内容echo 内容 &gt; a.txt 这种方法会覆盖掉文件原有内容，如果是追加，应用： echo 内容 &gt;&gt; c.txt 这种方法，每次写入内容后面都会自动换行 图形化编辑txt文件notepad a.txt 这会直接以记事本的形式打开指定的文件 读取文件内容cat a.txt 此命令只能在操作当前目录的文件时可用 type a.txt 此命令可跨目录使用，即可添加路径 打开doc文件路径没错的情况下，直接输入文件名，然后回车，即可用相应的软件将其打开 指定用某软件打开某文件 将要使用的软件的exe文件所在的目录添加到系统环境变量里面 之后就可以用该软件打开想要打开的文件了 软件名或软件名.exe 文件名.文件后缀 删除文件del a.txt 删除文件夹del 文件夹 重命名文件ren a.txt b.txt 将文件a,txt重命名为b.txt 重命名文件夹ren 文件夹名1 文件夹名2 将文件夹名1改为文件夹名2 复制文件copy b.txt 文件夹1 将当前文件夹下的b.txt文件拷贝到当前文件夹下的文件夹1里面，其他操作可自行添加路径解决。 移动（剪切）文件move 路径\文件名 路径\ 查看文件夹的目录结构 tree 可以查看当前目录及以下各级的目录结构，但是查看不了文件 tree /f可以查看对当前目录及以下各级的目录结构以及相应的文件 tree /f &gt;123.txt将查询到的文件目录结构保存在123.txt（新建）文件中 关闭某个软件 taskkill /im 软件名.exe 先输入tasklist 获取改进程的PID，假设PID号为3502， 再输入 taskkill /f /pid 3502 从命令行模式打开文件夹窗口start 文件夹的绝对路径]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js相等操作符]]></title>
      <url>%2F2017%2F04%2F25%2FJs%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[对于有其他编程语言编程经验的人来说，在判断两个值是否相等时，会用“==”，但是此方法用于Js，特别是用Webstorm等前端IDE编写Js程序时，会发现此方法会报错，并提示应该更改为“===”，这到底是怎么回事，下面我们就来区别一下Js这两个相等操作符——“==”和“===” 总的一句：==不管类型相不相同，只要进行转化后条件符合（具体怎么转化请往下看），就会判定为相等；===必须比较的两个值类型和值相等时才相等，即===要比==严格。 “===”先说简单的，===。 用于比较的两个值，类型不相等则不相等，类型相等且值相等，则相等。 例子例一： 12console.log('test'===true); //结果为：false，以为类型不相等，一个字符串一个布尔值console.log('test'==='test'); //结果为：true，因为类型相等且值相等 值得注意的一点是，关于对象，就算是分别定义的两个对象的内容一样，用’===’进行比较也是不相等的，因为存储的位置不同，除非是用引用的方式将一个对象的值赋给另一个对象，这才返回true。（什么是对象的引用可以看这篇文章：对象引用问题上Java和Js是相通的–Java入门） 例二： 123456789var person1=&#123;a:'xiao'&#125;;var person2=&#123;a:'xiao'&#125;;console.log(person1===person2);//结果为：false，因为person1和person2的存储位置不一样，所以是不同的对象var person1=&#123;a:'xiao'&#125;;var person2=person1;console.log(person1===person2);//结果为：true，因为person2是对person1的引用，它们指向的是用一个内存块，所以相等 “==” null与undefined在与其他数相等运算时步进行类型转换 使用==时，不同类型的值也可以被看做相等，不过Js会对其进行一定的转化后再惊醒比较，下面来看看如果对不同类型的值使用“==”进行比较，Js会进行怎样的转化： 若x和y类型相同，Js会比较它们的值或者对向值。如果不同，则按上面的形式进行转化后再比较。其他没有列在表格中的情况都会返回false。 toNumber和toPrimitive的转化结果toNumber toPrimitive 例子例一： 1console.log('test'?true:false);//结果为:true 原因：这里是判断test字符串变成布尔值后是什么，因为字符串的长度大于一。这里涉及到Js中true和false的问题，稍微说下Js中true和false是怎么转换的： 例二： 1console.log('test'==true); //结果为：false 原因：进行比较的时候，布尔值true被toNumber变成数字1；而字符串test则被toNumber转换成NaN，进而表达式转换成判断NaN==1，结果自然为false。 例三： 1console.log('test'==false); //结果为：false 原因：同例二一样的道理，结果表达式被转换成判断NaN==0,结果仍然为false。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[远方]]></title>
      <url>%2F2017%2F04%2F23%2F%E8%BF%9C%E6%96%B9%2F</url>
      <content type="text"><![CDATA[“当你发现日子特别艰难的时候 可能这次的收获特别巨大”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github Pages托管静态页面]]></title>
      <url>%2F2017%2F04%2F22%2FGithub-Pages%E6%89%98%E7%AE%A1%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[什么是 Github Pages？ Github Pages 是 Github 的静态页面托管服务。它设计的初衷是为了用户能够直接通过 Github仓库来托管用户个人、组织或是项目的专属页面。 我们可以利用 Github 的静态页面托管服务 Github Pages 来帮助我们做页面展示。见得最多的就是把它拿来托管自己的博客，当然博客是静态的，不过，不止博客，我们github账户上的所有仓库只要把Github Pages的功能代开，就都能拥有自己的展示主页。 托管博客github提供的博客托管仓库只有一个，那就是username.github.io，下面说一下具体怎么弄： 创建一个名为username.github.io的仓库，其中username是你的github用户名，其他的默认即可 进入username.github.io这个仓库，点击setting选项进行设置 本地git关联和上传到这个仓库的步骤我就不说了，也就是git init、git add、git commit、git remote add origin https://仓库地址、git push origin master这些基本步骤，相信能来看这个的对git的基本操作都已经掌握了。 进入到setting里面，左边学则Options这一栏,右边滑到GitHub Pages那一栏，将Source的Node改成你放博客文件的分支名字，一般是直接用master分支，然后Save Theme chooser那一个选项是给你的这个主页设置显示的主题的，咱们是自己创建的博客不需要它的东西，直接跳过就行了 此时访问在浏览器搜索框输入username.github.io其实已经可以访问，只是会提示404，因为咱们没有放页面 此时只要上传本地的博客文件到这个仓库就可以了 注意：博客的首页必须命名为index.html且放在这个仓库的最外面，不能放在某某文件夹里面，不然访问username.github.io还是会找不到页面 上面的工作都做完后，就能通过输入username.github.io(记住，这里提到的username都得改成自己的用户名)访问自己托管的静态博客了 如果不喜欢github提供的这个username.github.io域名怎么办，也可以绑定到自己注册的域名，详情请看我的这篇博客：挂载Hexo主题的Github绑定自己的域名,博主用的是Hexo的Next主题，不过不影响，操作都差不多 到服务商购买域名 username.github.io仓库添加最外面添加一个CNAME文件，里面写上自己购买的域名 解析购买的域名到github的域名和IP地址，等待一会儿就能通过自己的域名访问了 生成项目的展示主页这才是Github Pages这功能开放的真正目的，为的是让托管在github上的仓库都能有直接进行展示的机会 步骤跟托管博客的步骤一样，随便一个仓库，Setting-&gt;Options-&gt;GitHub Pages-&gt;Source-&gt;分支名这样就成功了，通过http://博客域名/仓库名，就可也访问了，同样该仓库需要一个放在最外面的index.html页面来做首页 Github Pages的限制好东西还是有限制的： 仓库存储的所有文件不能超过 1 GB 页面的带宽限制是低于每月 100 GB 或是每月 100,000 次请求。 每小时最多只能部署 10 个静态网站。不够对于托管个博客应该是绰绰有余了，如果真的不小心超了，Github 那边不会采取什么强制措施，而是会发一份邮件提醒你应该找一个更适合你的托管对象的服务。 至于仓库的存储的文件大小限度是各个仓库的总和还是自己有自己的1GB，这我没研究过，毕竟Github还没给我发过提醒邮件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[“百花齐放”的前端时代]]></title>
      <url>%2F2017%2F04%2F21%2F%E2%80%9C%E7%99%BE%E8%8A%B1%E9%BD%90%E6%94%BE%E2%80%9D%E7%9A%84%E5%89%8D%E7%AB%AF%E6%97%B6%E4%BB%A3%2F</url>
      <content type="text"><![CDATA[笼统的前端 现在前端领域各种框架、库并行，新技术层出不穷，暂且称它为“繁荣”吧。 对一个刚刚走进这个江湖的菜鸟来说，jQuery、Angular、React、Vue、Bootstrap、Node这些经常在各大公司招聘要求以及各大前端论坛信息中的看到词到底是什么，有什么作用，一会儿框架，一会儿库的，还有MVC、MVVM以及npm、gulp、webpack等，就像各大帮派一样，搞得人一头雾水。 链接 我眼中的前端框架jQuery，Angular，React，Vue——以及我看前端架构 浅析angular，react，vue.js，jQuery使用区别 Gulp和webpack的区别，是一种工具吗？ nodejs+gulp+webpack基础实战篇 各路英雄的见解关于框架 前端框架天下三分：Angular、React 和 Vue 按照时代出场顺序排序：jQuery、Angular、React、Vue jQuery肯定要学的，Angular、React 和 Vue三个先学一个，三个都是比较类似的 React，Angular,Vue三个也是没有关联相互独立的框架。使用这三个框架搭建的网站主要特点就是动态刷新，路由控制不通过后端，全是JS完成，每次跳转页面都是动态替换index.html页面root节点的内容 Angular、React、Vue是Js框架，本身都是用js原生写的，就是别人把一些js的代码封装了，你调用之后就能用别人写好的方法，会方便很多，也被局限在别人的框架内部了 Bootstrap是UI框架 vue是国人弄出来的，官方文档都是中文，学起来比较不麻烦 分清楚 库，框架，构建工具、 插件的作用 需要引用或者调用，就可以直接用，并不会对你做太多约束。那么这种大部分都称之为库。如jQuery 需要按照他的标准构建文件结构或者文件夹结构或者代码书写方式那么这东西可以称之为框架，一般框架都是多种组合在一起的，如React+gulp 或者 jQuery mobile 解决开发过程中重复或者需要自动化智能化完成事情，也就是构建工具，如grunt和gulp 基于 库，框架，工具，提供的补充优化的模块就叫做插件 关于工具 gulp是工具链、构建工具，可以配合各种插件做js压缩，css压缩，less编译 替代手工实现自动化工作 webpack是文件打包工具，可以把项目的各种js文、css文件等打包合并成一个或多个文件，主要用于模块化方案，预编译模块的方案 关于node一个让我笑半天的回答 node到底是什么？ 让Js也可以做后端 Node.js 通过用单线程取代多线程，事件驱动 I/O 来解决了高并发，取代了Java 平台的标准 一个运行JavaScript的平台，可以操作文件、创建网络服务等，并用JavaScript来编写后端服务 事件驱动 非阻塞I/O模型 2009年 Ryan Dahl 开发并开源 ，目的是构建高性能服务器，基于Chrome V8 结合Express实现高可扩展的动态Web服务 示例： 123456var fs = require("fs");fs.readFile("./testfile", "utf8", function(error, file) &#123; if (error) throw error; console.log("我读完文件了！");&#125;);console.log("我不会被阻塞！"); 上面代码的输出是： 我不会被阻塞！ 我读完文件了！ 这个输出显然不符合传统的程序执行顺序，这便是Node.js的非阻塞I/O了。即I/O操作不会阻塞程序的执行，也就是在I/O操作的同时，继续执行其他代码（这得益于Node的事件循环机制）。 ExpressNode.js的Web框架 Express是一个简洁、灵活的Node.js Web应用开发框架, 它提供一系列强大的功能，比如：模板解析、静态文件服务、中间件、路由控制等。 本质上是一个npm包，所以安装：npm install express]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[定义和声明的区别]]></title>
      <url>%2F2017%2F04%2F20%2F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[声明就是指给除了当前变量或者函数，或者类什么的名字，不给其中的内容，就是先告诉你有这样一个什么类型的变量或者函数，但是这个变量或者函数的具体信息却是不知道的。就好比跟你介绍一个人的时候，声明就是只告诉你这个人叫什么，但是缺不给你说这个人到底怎么样，他有哪些优点，缺点，喜好问题是什么的 定义就不一样了，定义直接告诉你了所有的东西，这个变量是什么，这个函数是什么功能，这个类里面包含了什么东西。很具体的说明 当然一般对于变量来说，我们不怎么区分声明或者定义之类的，一般没有人去说我要声明一个变量，然后定义这个变量什么的。要说都是直接说定义变量 声明一般都是对函数或者类来说的，声明在前，定义在后 int a;可以说是声明，广泛的说是定义一个变量a，也不算错 例子：123456789int a; //等价于 声明一个人：小张int a = 3; //等价于 定义一个人 ：小张 年龄为三岁。//定义是带有初始化的//函数的声明和定义void My(); // 这个是声明//这个是定义void My()&#123;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[挂载Hexo主题的Github绑定自己的域名]]></title>
      <url>%2F2017%2F04%2F19%2F%E6%8C%82%E8%BD%BDHexo%E4%B8%BB%E9%A2%98%E7%9A%84Github%E7%BB%91%E5%AE%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%2F</url>
      <content type="text"><![CDATA[用的Hexo的博客框架，本地生成并托管到github上之后，通过“username.github.io”便能访问自己的博客了，但是如何将url改成自己想要的域名，需要如下一些步骤。 到域名提供商那注册自己想要的域名，国内比较大的有阿里云、百度云等等、国外有godaddy、bluehost等，bluehost还支持支付宝，还不错，其实一个域名也不用纠结太多，毕竟域名不管在国内还是国外买的，只要服务器是国外的就不用走中国内地的备案套路，比如本篇文章讲的博客在github上就不用担心什么备案，不过要注意的是如果买的是.cn这种中国域名，就需要购买人提供身份证电子照片进行验证，政府部门通过后才能用。 到github的username.github.io目录下，创建新文件CNAME（一定要大写，而且不加任何后缀）,其中包含你注册的域名，注意要填的是顶级域名，比如roderic.cn 第二步是告诉github你要将该博客地址转到你CNAME文件中指定的域名。现在到你购买域名的服务商那为你购买的域名添加三条解析记录，如下： 前两条记录是指定该域名跳转的IP（github pages的，固定的，照抄，不用管）地址，第三条是指定该域名跳转到username.github.io（注意这里的username都得用你github的用户名替换） 这样经过短时间的等待，你就可以用你注册的域名访问你的博客了，当然此时用username。github.io也还是能访问博客的。 本例讲的是Hexo的博客框架，都知道Hexo每次都要重新生成静态文件再上传，这样每次CNAME都得重新创建很麻烦，解决方法是把CNAME文件放在source文件夹下，这样生成静态文件的时候，就会自动添加CNAME这个文件了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java入门（三）]]></title>
      <url>%2F2017%2F04%2F17%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[有关读取用户输入的问题首先导入包import java.util.Scanner;这里面有处理用户输入的方法。 输入数字情况123456789101112public static void main(String[] args) &#123; //创建输入对象 Scanner sc=new Scanner(System.in); //获取用户输入的数字 System.out.print("请输入任意数字:"); int str=sc.nextInt(); //用来获取数字 System.out.println("你输入的数字为:"+str); &#125; 输入字符串12345678910111213public static void main(String[] args) &#123; //创建输入对象 Scanner sc=new Scanner(System.in); //获取用户输入的字符串 String str=null; System.out.print("请输入任意字符:"); str=sc.nextLine(); //用来获取字符串 System.out.println("你输入的字符为:"+str); &#125; 若要输入字符数组思路：先用输入字符串的方法读入字符串，然后再将其转换为字符数组 注经过测试，一个输入对象只能接受一种数据类型，要想输入不同的数据对象，就得现创建不同的输入对象1234567Scanner in1=new Scanner(System.in); //接受数字输入int x1=in1.nextInt(); int x2=in1.nextInt(); //同种类型不必再new输入对象Scanner sc2=new Scanner(System.in); //接受字符串输入，不同类型得创新new输入对象，而且不同名String str=sc2.nextLine(); String str=sc2.nextLine();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java入门（二）]]></title>
      <url>%2F2017%2F04%2F15%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[注： 同一个包下，不同java文件中的类名不能相同，因为同一包下，不同java文件中的类是可以相互继承的！ 不同java类文件中的内部类（一个类中还包含着另外一个类）可以同名，但是同一文件下的public或者是默认范围的java类是不可以同名的。 当类中方法的访问权限修饰符为private时，该方法只能被自己的类访问，不能被外部的类访问 初始化时，若没有赋值则为默认值，具体时：数字为0、对象为null、布尔值为false、字符值为’\0’ 对象的引用 引用是一个地址，它指明了对象的变量和方法的存储位置 将对象赋给变量或将其作为参数传递给方法时，实际上并没有使用对象，甚至没有使用对象的拷贝，使用的是对象的引用 例子：123456789101112131415package Mypackage;import java.awt.Point;class RefTester&#123;public static void main(String[] args)&#123; Point pt1,pt2; pt1=new Point(100,100); pt2=pt1; pt1.x=200; pt1.y=200; System.out.println("Point1:"+pt1.x+","+pt1.y); System.out.println("Point2:"+pt2.x+","+pt2.y);&#125;&#125; 执行结果： 可以发现，pt2的值也被改变了，这是pt2=pt1是让pt2引用pt1，而不是将pt1的拷贝纸给pt2，pt1和pt2现在是指向同一个对象 如果改成：12pt1=new Point(100,100);pt2=new Point(100,100); 结果就将是： 注：(不想重写代码，假设pt1和pt2现在是String类型) 若pt2=pt1，此时用“==”来判断pt1和pt2是否相等，得到的结果是“true”,因为指向同一个对象，用“pt2.equals(pt1)”得到的结果也将是“true”，因为两个字符串值相同 若pt1=new Point(100,100);pt2=new Point(100,100);，此时用“==”来判断pt1和pt2是否相等，得到的结果是“false”,因为它们现在在内存中不是同一个对象，用“pt2.equals(pt1)”得到的结果也将是“true”，因为两个字符串值相同 方法重写与方法重载方法重写 子类可以定义新的特征，当子类需要修改父类的一些方法进行扩展，增大功能，程序设计者常常把这样的一种操作方法称为重写，也叫称为覆写或覆盖，重写是建立在继承关系上 所谓方法的重写是指子类中的方法与父类中继承的方法有完全相同的返回值类型、方法名、参数个数以及参数类型。这样，就可以实现对父类方法的覆盖 例子： 1234567891011121314151617class Person//定义父类&#123;public void print()&#123;//父类中的方法System.out.println( 父类Person的print方法! );&#125;&#125;class Student extends Person//定义子类继承Person类&#123;public void print()&#123;//方法的重写System.out.println( 子类Student的print方法! );&#125;&#125;public class 0verrideExampleO1&#123;public static void main(String args[])&#123;Student s=new Student();S.print();&#125;&#125; 运行结果：子类Student的print方法! 可见当子类重写了父类中的print()方法后，使用S调用的是子类的print()方法，如果一定要调用父类中的方法，可以用super关键字，super关键字可以从子类访问父类中的内容，如果要访问被重写过的方法，使用“super.方法名(参数列表)”的形式调用 例子： 1234567891011121314151617class Person2&#123;public void print () &#123;System.out.println( "父类Person的print方法! ");&#125;&#125;class Student2 extends Person2&#123;public void print () &#123;super.print();//访问父类中被子类覆写过的方法System.out.println(" 子类Student的print方法!" );&#125;&#125;public class OverrideExample02&#123;public static void main(String args[])&#123;Student2 s=new Student2();s.print();&#125;&#125; 运行结果： 被子类重写的方法不能拥有比父类方法更加严格的访问权限 当父类中方法的访问权限修饰符为private时，该方法只能被自己的类访问，不能被外部的类访问，在子类是不能被重写的。如果定义父类的方法为public，在子类定义为private，程序运行时就会报错 在继承过程中如果父类当中的方法抛出异常，那么在子类中重写父类的该方法时，也要抛出异常，而且抛出的异常不能多于父类中抛出的异常(可以等于父类中抛出的异常)。换句话说，重写方法一定不能抛出新的检查异常，或者比被重写方法声明更加宽泛的检查型异常。例如，父类的一个方法申明了一个检查异常IOException，在重写这个方法时就不能抛出Exception，只能抛出IOException的子类异常，可以抛出非检查异常 方法重载 方法重载是让类以统一的方式处理不同类型数据的一种手段。调用方法时通过传递给它们的不同个数和类型的参数来决定具体使用哪个方法，这就是多态性 所谓方法重载是指在一个类中，多个方法的方法名相同，但是参数列表不同，参数列表不同指的是参数个数、参数类型或者参数的顺序不同 不仅是一般的方法，构造方法也可以重载 例子： 1234567891011121314151617181920212223242526 Class Person &#123;&#123;String name; int age;void print()&#123; System.out.println("姓名：" +name+"年龄：" +age); &#125;void print(String a，int b)&#123; System.out.println("姓名：" +a+"年龄："+b); void print(String a，int b，intC)&#123; System.out.println("姓名："+a+"年龄：" +b+"ID号：" +c); &#125;void print(String a，int b，doubleC)&#123; System.out.println("姓名："+a+"年龄：" +b+"ID号："+c); &#125; &#125;public class OverLoadExampleOL &#123;public static void main(String[] args) &#123;Personpl=new Person();p1.name="李明";p1.age=22;p1.print(); p1.print("王小早",19); p1.print("金波",18,100325); p1.print("婉宁",25,110903); &#125; &#125; 在上面的程序中，可以看到Person类中有多个名为 void print的方法，这就是方法的重载。执行程序，运行结果如下： 每个重载方法可以有不同的返回类型,只要参数列表不同就可以了 可以有不同的访问修饰符 可以抛出不同的异常 总结 在面向对象程序设计的思想中，类的继承和多态性主要就是体现在子类重写父类的方法。而构造方法的重载作为方法重载的一个典型特例，可以通过重载构造方法来表达对象的多种初始化行为。灵活的运用方法重写与方法重载，不仅能减少编码的工作量，也能大大提高程序的可维护性及可扩展性 参考文章链接 注意以下这个方法重载的例子，实例方法可以用类名来作为返回类型创建！！ 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.awt.Point;//该类定义了一个矩形class Box &#123; int x1 = 0; int y1 = 0; int x2 = 0; int y2 = 0; Box buildBox(int x1, int y1, int x2, int y2) &#123; this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2; return this; &#125; Box buildBox(Point topLeft, Point bottomRight) &#123; x1 = topLeft.x; y1 = topLeft.y; x2 = bottomRight.x; y2 = bottomRight.y; return this; &#125; Box buildBox(Point topLeft, int w, int h) &#123; x1 = topLeft.x; y1 = topLeft.y; x2 = (x1 + w); y2 = (y1 + h); return this; &#125; void printBox()&#123; System.out.print("Box: &lt;" + x1 + ", " + y1); System.out.println(", " + x2 + ", " + y2 + "&gt;"); &#125; public static void main(String[] arguments) &#123; Box rect = new Box(); System.out.println("Calling buildBox with " + "coordinates (25,25) and (50,50):"); rect.buildBox(25, 25, 50, 50); rect.printBox(); System.out.println("\nCalling buildBox with " + "points (10,10) and (20,20):"); rect.buildBox(new Point(10, 10), new Point(20, 20)); rect.printBox(); System.out.println("\nCalling buildBox with " + "point (10,10), width 50 and height 50:"); rect.buildBox(new Point(10, 10), 50, 50); rect.printBox(); &#125;&#125; 结果为：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java入门（一）]]></title>
      <url>%2F2017%2F04%2F15%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Java作为一种面向对象语言。支持以下基本概念： 多态 继承 封装 抽象 类 对象 实例 方法 重载 成员变量包括：实例变量、类变量 成员方法包括：实例方法、类方法、构造方法 基本数据类型包括：byte、short、int、long、float、double、boolean、char 指针问题：不能说Java没有指针，它只是没有显示指针。对象引用实际上就是指针 Java中工程（项目）、包、类区别 项目就是project，包就是package，而class就是类了，项目里面包括所有的包，包是用来便于管理类，防止命名冲突，类是代码的容器，它们的关系就是上级与下级的关系，项目的下一级就是包，包的下级就是类 工程相当于一个软件，包相当于模块，类相当于模块下各个功能的实现 类下再有各种自己具体完成任务需要的成员变量和实现方法。主方法也在某一个public类中 包(package)相当于姓名中的“姓”，类(class)相当于“名”。所以在调用某类方法的时候，不仅需要指明方法所在的“名”，即类，还要指明方法类所在的“姓”，即类。这样编译器才知道你调用的方法是哪一个。 包类具体使用： 注意： 类名和文件名相同，一个Java文件中最好仅定义一个类，多类不方便管理。 如果多类定义，则仅有一个类可以被public修饰，这个类且必须和文件同名，其他类则不能被其他包里类所引用。此外，若存在主方法main函数，public的main方法只能存放在这个public类当中。 由于main方法是静态的，所以不可以直接调用类中非静态成员变量或方法。但是可以在main函数中创建实体（对象）再调用方法和变量。(即用new) 包建议小写字母开头，而类以大写字母开头。 问题 包用来解决什么问题？ 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类 java.awt.*是什么 java.awt包，即java抽象窗口工具包（Abstract Window Toolkit,AWT)提供了许多用来设计GUI（Graphics User Interface,图形用户界面）组件类。 友好变量、友好方法、友好类 友好变量、友好方法 所谓友好即 不被public、protected、private关键修饰的变量和方法区别在于 比public低一级，用于只能在同一包下访问的变量 Java一共有四种权限，private (私有)，public（公有）。Protected（受保护）还有友好型。这些语句都可以修饰类中的成员变量和方法，但是只有public和友好型可以修饰类。 类、实例、对象区别 类是对一项事物的抽象概括，是一个模板，可以包含该事物的一些属性定义，以及操作属性的方法 实例简单理解，就是new，就是对类的实例化，创建这个类对应的实际对象，类只是对事物的描述，而实例化就相当于为这个描述新开辟了一块内存，可以改变这块区域里的各种属性（成员变量），当然，也可以实例化多块区域，只是不同的对象而已。 类跟对象 可以这么说，对象就是实例，new的过程就是对象实例化的过程 例：1234567891011121314//ps就是对象的一个**引用**，要对这个对象进行操作的时候，就可以通过这个引用public class Peason &#123; String name; String sex; int age; public static void main(String [] args) &#123; Peason ps=new Peason(); ps.name=”张三”; ps.sex=”男”; ps.age=10; &#125; &#125; 构造方法（即构造函数） 是一种特殊的方法，它是一个与类同名且没有返回值类型的方法 对象的创建就是通过构造方法来完成，其功能主要是完成对象的初始化 满足如下语法规则： 方法名与类名相同 不要声明返回类型 不能被static、final、synchronized、abstract和native修饰。构造方法不能被子类继承，所以用final和abstract修饰没有意义 不能使用return语句来返回一个值 例子：一个类可以有多个构造方法！ 12345678910111213141516//以下Sample类中，具有int返回类型的Sample(int x)方法只是个普通的实例方法，不能作为构造方法public class Sample &#123;private int x; public Sample() &#123; // 不带参数的构造方法 this(1); &#125; public Sample(int x) &#123; //带参数的构造方法 this.x=x; &#125; public int Sample(int x) &#123; //不是构造方法 return x++; &#125; &#125; 如果构造函数的部分行为与已有的构造函数相同，可以在该构造函数中调用已有的构造函数。 例子： 123456789101112131415//第二个构造函数只接受x和y的坐标作为参数，由于没有定义半径，//因此使用默认值1——调用第一个构造函数，并将xPoint、yPoint、1作为参数传递给它 class Circle&#123; int x,y,radius; Circle(int xPoint,int yPoint,int rediusLength)&#123; this.x=xPoint; this.y=yPoint; this.radius=rediusLength; &#125; Circle(int xPoint,int yPoint)&#123; this(xPoint,yPoint,1); &#125;&#125; 注意： 构造方法可以重载，以参数的数目，类型，顺序 如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造器，这个构造器不执行任何代码。 构造方法不能被继承： 子类只继承父类的默认(缺省)构造函数（即无形参构造函数），如果父类没有默认构造函数，那子类不能从父类继承默认构造函数。 子类从父类处继承来的父类默认构造函数，不能成为子类的默认构造函数。 在创建对象时，先调用父类默认构造函数对对象进行初始化，然后调用子类自身自己定义的构造函数。 如果子类想调用父类的非默认构造函数，则必须使用super来实现 内存管理不同于其他面向对象语言，Java在内存管理是动态的、自动的，当你创建对象时，Java自动分配相应的内存，当使用完对象后，Java虚拟机自动查找未用的对象并回收这些对象占用的内存 权限问题 Java类的访问控制 Java中不同控制符对应的权限java中的访问修饰符讲解 实例变量与类变量的区别，实例方法和类方法的区别详细链接一详细链接二 类变量：静态域，静态字段，或叫静态变量，它属于该类所有实例共有的属性，在内存中只有一个地方存储这个变量 类变量、类方法就是类中的变量、方法，必须是静态的，要加static；故其又称静态变量、静态方法。 实例变量：实例域，实例字段，或叫成员变量。 实例方法：或叫成员方法，必须先有实例，然后才能通过实例调用该实例方法 类变量和实例变量都必须在方法和语句块之外，区别在于类变量static而实例变量不是，类方法和实例方法的区别也是在有没有static上 类方法是属于整个类，而不属于某个对象 类方法的调用可以通过类名.类方法和对象.类方法，而实例方法只能通过对象.实例方法访问 类方法只能访问类方法，而实例方法可以访问类方法和实例方法。 类方法不能被覆盖，实例方法可以被覆盖（待验证） 每个实例都将有一个实例变量的一个副本，他们可以修改实例变量的值，而不会影响其他的示例；类变量只有一个副本，修改它的值将影响所有的实例 类方法与类变量一样，适用于整个类，而不是某个实例。类方法通常用作通用的工具方法，然不是直接操作某个对象，而是整个类。 类方法还可以用来将通用的方法集中起来，放在一个地方（即类中）。例如：在java.lang包中定义的类Math,将大量的数学运算作为类方法。不能创建Math对象，但可以只用它的类方法，并将数字和布尔值作为参数 使用方法： 类方法可以直接调用类变量和类方法 类方法不可以直接调用实例变量和实例方法 类方法中没有this，因为没有实例，this不知道调用哪个实例(只能在实力方法的定义体内使用this)，super也不行 类方法可以从类里面直接访问类成员 实例方法可以调用类方法，访问类变量，但是不提倡这样做，会把类方法和类变量混淆成实例方法和实例变量 例子： 12345678910111213141516171819202122232425262728293031 package Mypackage; class AnIntegerNamedX &#123; static int x; // 这里写成static，结果就变成全是2了，因为类变量是被实例所共享的， //包括myX和anotherX调用anotherX时所有的实例都改变了。 public int x() &#123; return x; &#125; public void setX(int newX) &#123; x = newX; &#125;&#125;public class Practice &#123;public static void main(String args[]) &#123; AnIntegerNamedX myX = new AnIntegerNamedX(); AnIntegerNamedX anotherX = new AnIntegerNamedX(); myX.setX(1); anotherX.x = 2; // 这里把X的值改成2，所有实例的X都是2了，因为类变量是被 //所有实例共享的，任何实例都可以对类变量做最终的修改 System.out.println("myX.x = " + myX.x()); System.out.println("anotherX.x = " + anotherX.x());&#125;&#125; 结果为： 若将static int x;改成int x;，则结果为： 若将static int x;改成int x;，将x()方法和setX()加上static变成静态方法，则会提示错误让把X变成静态，是因为类方法不能直接访问实例变量！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用例图学习笔记]]></title>
      <url>%2F2017%2F04%2F15%2F%E7%94%A8%E4%BE%8B%E5%9B%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[基本概念 主要用来图示化系统的主事件流程 用例就是软件的功能模块，是设计系统分析阶段的起点 描述软件应该具备哪些功能模块以及这些模块之间的调用关系 用例图包含“用例”和“参与者” 用例之间通过关联来连接，以便把系统的整个结构和功能反映给客户 对应的是软件的结构和功能分解 用例之间可以抽象出：包含、扩展、泛化关系。（最常见是：关联） 图示 关联 包含 扩展 泛化 示例 包含 扩展 泛化 具体讲解请戳 组成：系统、用例、参与者、关系 解释 被包含的用例可以单独执行 一个用例被定义为基础用例的增量扩展，称作为扩展关系，在特定的条件发生时，扩展用例才会被执行 泛化关系中，父用例往往表现为抽象用例，任何父用例出现的地方，子用例也可出现 简单说： 泛化侧重子用例之间的互斥性； 包含侧重被包含用例对参与者提供服务的间接性； 扩展侧重扩展用例的出发不确定性。 参与者种类： 系统用户 与所建造的系统交互的其他系统 一些可以运行的进程 用例图建模技术分为：对语境建模、对需求建模 对语境建模 对需求建模 实现步骤 确定系统涉及的总体信息 确定系统的参与者 确定系统的用例 绘制系统的用例图 例子 绘制步骤 添加参与者与用例 添加参与者与用例之间的关系 添加用例之间的关系]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NexT主题配置进阶]]></title>
      <url>%2F2017%2F04%2F15%2FNexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%BF%9B%E9%98%B6%2F</url>
      <content type="text"><![CDATA[主题配置包括： 设置「RSS」 添加「标签」页面 如何为文章添加标签或者分类 添加「分类」页面 设置「字体」 设置「代码高亮主题」 侧边栏社交链接 开启打赏功能 设置友情链接 腾讯公益404页面 站点建立时间 订阅微信公众号 设置「动画效果」 设置「背景动画」 第三方服务包括： 评论系统 数据统计与分析 内容分享服务 搜索服务 其他服务 稍微写一下基本操作：标签 新建标签页面：（这样标签合辑的页面被制作出来） 编辑刚刚新建的页面，将其页面类型设置为tags（这样主题将知道这是一个标签页面，并为这个页面显示标签云） 编辑主题配置文件，添加tags到menu目录中 之后在新建的文章中就可以通过设置文章中的开始的声明来为文章添加标签了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo安装及默认主题配置]]></title>
      <url>%2F2017%2F04%2F15%2FHexo%E5%AE%89%E8%A3%85%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[#安装Hexo 想重建博客，又不想花时间从头设计实现网站，就开始找有什么方法能快速实现页面布局和设计，最开始用了wordpress平台，后来又看到大佬推荐Hexo,就看了看。 PS:Hexo依赖于Node,所以电脑得有Node.js环境，然后就可以用Node中强大的npm命令来安装各种东西，当然包括Hexo。Node和Git的安装教程自己百度。 Hexo安装教程 hexo入门指南 yilia主题 Next主题 yelee主题 另外还找到jekyll直接托管在github上，好像挺牛逼的，有时间再折腾吧准备自己建一个个人博客，有什么好的框架推荐？ 我的安装过程 在git bash内使用npm install hexo -g安装，直接在根目录下装的 然后在想要创建博客的地方使用hexo init blog命令创建blog文件夹（不只是文件夹，整个默认的hexo博客主题等都将从github上下到该文件夹下） 完成后，在blog文件夹内，hexo generate生成静态页面，生成的静态页面存储在public文件夹下，只要有一个web server就可以独立运行网站了 hexo server启动本地服务，浏览器输入http://localhost:4000/即可访问刚刚创建的博客了 如果不行，说明端口被占用，用hexo s -p 5000重新开启本地服务，然后http://localhost:5000/即可访问创建的页面 就是这么简单，主要都是细节问题，对于刚入门的同道，需要知道的是，以上命令都在git bash里面执行就可以，因为cmd有的功能bash基本上都有，Node博主当时是默认安装在C盘，用npm install npm -g升级了下Node自带的npm，然后直接在根目录（刚打开git bash时的目录）执行的npm install hexo -g安装hexo，在其他目录安装的话，用全局安装应该也可以，不过我没折腾过。 部署到github部署到github 修改blog目录下的_config.yml文件如下：title为网站主标题，subtitle为副标题，都是顾名思义的，language和timezone要注意书写格式，还有，每个“：”之后要记得加上空格 更改完_config.yml之后，输入npm install hexo-deployer-git --save（不知道是不是必须的，可能是怕没有安装deploy，怕在后面发布到github的时候出错） 在终端输入hexo new &quot;文章标题&quot;来新建文章，也可以在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件。 可能会出现发布后中文乱码的问题，只要把相应的.md文件保存成UTF-8格式就行了。比如用txt打开，然后另存为UTF-8格式。 然后进行本地发布：$ hexo server 此时浏览器输入http://localhost:4000/可以看到我们搭建好的博客和发布的文章 目前只能在本机看到 接下来用 $ hexo generate//生成静态页面 $ hexo deploy//发布到更改_config.yml时指定的githubc仓库上 这样使用github的仓库地址例如本例的http://inerdstack.github.io就可以访问我们的博客了 部署步骤每次部署的步骤，可按以下三步来进行。 hexo clean hexo generate hexo deploy 一些常用命令： hexo new”postName” #新建文章 hexo new page”pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo的hexo deploy无法使用]]></title>
      <url>%2F2017%2F04%2F15%2FHexo%E7%9A%84hexo-deploy%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[具体情况是，在hexo generate生成静态页面后，用hexo deploy命令想发布到github上，却出现了问题，报错如下： 即提示找不到用户名，这应该是ssh配置的问题，索性就没用ssh传输，直接在博客文件夹下用 $ git init $ git remote add origin https://github.com/{USER_NAME}/{REPOSITORY_NAME}.git 然后再执行hexo deploy就成功了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-NexT主题]]></title>
      <url>%2F2017%2F04%2F15%2FHexo-NexT%E4%B8%BB%E9%A2%98%2F</url>
      <content type="text"><![CDATA[看来很多Hexo主题，最后还是想用NexT主题的Mist版本，简直不能再棒。不愧是最受欢迎的Hexo主题。 官网讲得已经很好了 我稍微再说一下。 能想到用NexT的肯定对Hexo、Node、Git、Github有了解了，我就不再过多描述了。 步骤 在终端窗口（比如：git bash），定位到Hexo的博客目录下，输入以下命令： $ cd your-hexo-site //比如我的博客目录是blog,就写blog $git clone https://github.com/iissnan/hexo-theme-next themes/next 完成后，更改站点配置文件，即blog目录下的_config.yml,找到theme字段，将其值置为next 这样其实就已经完成了 在终端输入$ hexo server通过相应端口访问就可以验证主题是否设置成功了 选择样式 Next有3种样式默认的是Muse，另外还有Mist和Pisces，可以通过更改主题的配置文件来选择样式，主题配置文件路径为\themes\next_config.yml 搜索scheme关键字，找到三行scheme的配置，将要启用的样式前的“#”去掉，不用的样式前加上“#”即可 另外主题语言、菜单、头像等的相关设置可以参见官网，讲得通俗易懂，已经很容易理解了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node安装]]></title>
      <url>%2F2017%2F04%2F15%2FNode%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[之前就久仰Node.js大名，最近想弄个Hexo+github的博客，需要Node支持，所以开始接触这个方面的内容。 这个链接介绍了Node安装和通过Node创建简单的服务器：我们安装了Nodejs是安装了什么 Node安装完后，安装目录下会多出几个文件，其中： Node_modules（Nodejs的模块都在这里，默认有一个Npm包管理模块） Node.exe（nodejs的核心解析器） 网上对Node.js的说法 Node 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”。 node.js…它既是开发平台, 也是运行环境, 也是个新的语言…它本身是基于google的javascript v8引擎开发的 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，使得Javascript也具备了写“服务器端”的能力。 支持多用户的高并发是其优势之一 它的出现能够让前端工程师更好的理解后端服务器运作原理，搭建一个功能全面的web应用。学习nodejs对于了解http、tcp协议是很好的。 什么是npm经常看到一些npm开头的命令，所以搜了一下 npm 是 nodejs 的包管理和分发工具。它可以让 javascript 开发者能够更加轻松的共享代码和共用代码片段，并且通过 npm 管理你分享的代码也很方便快捷和简单。 安装完 nodejs 就已经有了npm, 不过由于 nodejs 更新速度要慢于npm ，因此在一般情况下要升级你的 npm 到最新版本，输入如下命令： npm install npm -g 我的安装步骤： 到官网下载node.js 然后直接默认安装 听说自带的npm版本会比较低，所以就用npm install npm -g命令升级了一下 命令操作都是在cmd里面进行的，在git bash里面好像也行，难道这俩是互通的？？？ 查了下，确实是相通的，git bash和windows里的cmd功能差不多，只不过git bash里加了几个实用的linux命令以及git自己的命令]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WampServer 3.0环境配置问题]]></title>
      <url>%2F2017%2F04%2F15%2FWampServer%203.0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[在网上直接搜“WampServer 3.0”配置，不要只搜“WampServer配置”，因为这样收到的很多都是旧版本的教程，新版本的配置方法略有差别 配置包括： Apache根目录的改变 Wamp根目录的改变（此版本还要更改虚拟主机配置文件中的虚拟主机根目录才能奏效），具体的看教程 还有一个问题是：“wampserver 主页里点击“Your Projects”下面项目名，显示错误的问题。”解决这个问题需要更改Wamp根目录下的index.php文件中的路径代码，具体方法如下： 进入index.php文件，（wamp 3.0.6是在第445行），搜索$projectContents(这是YourProjects文件内容的相关变量)，在搜索结果里，找到一行代码中以$projectContents.=&#39;http://&#39;.$UrlPort.&#39;开头的，改成$projectContents .= &#39;http://localhost&#39;.$UrlPort.&#39;/&#39;.$file.&#39;/&quot;&#39;;如图： 这样子就可以了。 如何让Wampserver允许局域网甚至是外网访问？看这里]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[php环境问题]]></title>
      <url>%2F2017%2F04%2F15%2Fphp%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[用的是phpstorm和wamp搭建的环境，php版本为5.6 提交表单后，运行老是报错“Deprecated: Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version. To avoid this warning set ‘always_populate_raw_post_data’ to ‘-1’ in php.ini and use the php://input stream instead. in Unknown on line 0” 我运行是直接点的phpstorm里面的chrome快捷键，结果出现上面的错误，网上的方法试了，更改php.ini文件的always_populate_raw_post_data的值无效。 后来发现，从phpstorm直接运行的页面地址跟wamp根目录运行的页面地址是不一样的（废话，肯定不一样，因为我phpstorm的项目地址跟wamp的不在一起），而且很奇怪的一点，wamp提供的更改php.ini的地址不是php安装目录里的那个php.ini。搞得我有点晕。 后来索性把要运行的那个项目移动到wamp根目录，用localhost（wamp根地址）运行，结果就成功了，成功了，没错，不报错了，就是这么简单，具体为什么等我把这项目弄完了再好好研究吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Html常用标签大全]]></title>
      <url>%2F2017%2F04%2F14%2FHtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[基本&lt;html&gt;…&lt;/html&gt; 定义 HTML 文档 &lt;head&gt;…&lt;/head&gt; 文档的信息 &lt;meta&gt; HTML 文档的元信息 &lt;title&gt;…&lt;/title&gt; 文档的标题 &lt;link&gt; 文档与外部资源的关系 &lt;style&gt;…&lt;/style&gt; 文档的样式信息 &lt;body&gt;…&lt;/body&gt; 可见的页面内容、 &lt;!--…--&gt; 注释 文本&lt;h1&gt;...&lt;/h1&gt; 标题字大小（h1~h6） &lt;b&gt;...&lt;/b&gt; 粗体字 &lt;strong&gt;...&lt;/strong&gt; 粗体字(强调) &lt;i&gt;...&lt;/i&gt; 斜体字 &lt;em&gt;...&lt;/em&gt; 斜体字(强调) &lt;u&gt;...&lt;/u&gt; 下划线 &lt;del&gt;...&lt;/del&gt; 删除线(表示删除) &lt;center&gt;…&lt;/center&gt; 居中文本 &lt;ul&gt;…&lt;/ul&gt; 无序列表 &lt;ol&gt;…&lt;/ol&gt; 有序列表 &lt;li&gt;…&lt;/li&gt; 列表项目 &lt;a href=”…”&gt;…&lt;/a&gt; 超链接 &lt;font&gt; 定义文本字体尺寸、颜色、大小 &lt;sub&gt; 下标 &lt;sup&gt; 上标 &lt;br&gt; 换行 &lt;p&gt; 段落 图形&lt;img src=’”…”&gt; 定义图像 &lt;hr&gt; 水平线 表格&lt;table&gt;…&lt;/table&gt; 定义表格 &lt;th&gt;…&lt;/th&gt; 定义表格中的表头单元格 &lt;tr&gt;…&lt;/tr&gt; 定义表格中的行 &lt;td&gt;…&lt;/td&gt; 定义表格中的单元 其它&lt;form&gt;…&lt;/form&gt; 定义供用户输入的 HTML 表单 &lt;frame&gt; 定义框架集的窗口或框架 另加16进制颜色，但仅仅有16种颜色名可用英文字母，其余的要用16进制值。 记住哦！ aqua, black, blue, fuchsia, gray, green, lime,maroon, navy, olive, purple, red, silver, teal, white, yellow]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git上传github仓库步骤]]></title>
      <url>%2F2017%2F04%2F07%2FGit%E4%B8%8A%E4%BC%A0github%E4%BB%93%E5%BA%93%E6%AD%A5%E9%AA%A4%2F</url>
      <content type="text"><![CDATA[完整的Git的教程请看这里 这个教程是基于电脑上已经装有git和拥有github账号的基础上的。（没装git的可以去git官网下载，本文以windows64位系统为基础） 在git bash内输入以下命令在配置文件中保存身份： git config −−global user.name “github账号” git config −−global user.email “注册github时用的邮箱” 比如你要上传的本地仓库是在桌面的test文件夹内的所有文件：用命令行进入到test文件夹下（本例是上传test内的test.txt文件），涉及相关文件操作命令同linux。 在github中创建新仓库test: 在bash内，输入git init进行初始化： 将所有文件添加到上传队列中(“.”表示全部文件，可以用特定文件名来代替，进行特定文件上传；中间可以用git status 命令来查看文件所在所处的状态)：git add . 提交文件到本地git仓库：git commit −m “注释” 连接github中的test仓库：git remote add origin https://github.com/zifenggao/test.git（此段代码可以到创建成功后的github test仓库的code栏内复制得到） 然后输入git push origin master命令即可完成本地git仓库上传到github仓库的操作： 这样就完成了本地git上传到github仓库的操作，到github中刷新test仓库可以查看到我们上传的内容：]]></content>
    </entry>

    
  
  
</search>
