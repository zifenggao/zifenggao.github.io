<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java之输入与输出]]></title>
      <url>%2F2017%2F05%2F31%2FJava%E4%B9%8B%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%2F</url>
      <content type="text"><![CDATA[过程中发生的所有异常都是IOException的子类。 字节流文件输入流1234567891011121314151617181920212223242526import java.io.*;public class ByteReader &#123; public static void main(String[] arguments) &#123; try ( FileInputStream file = new FileInputStream("save.gif") ) &#123; boolean eof = false; int count = 0; while (!eof) &#123; int input = file.read(); System.out.print(input + " "); if (input == -1) eof = true; else count++; &#125; file.close(); System.out.println("\nBytes read: " + count); &#125; catch (IOException e) &#123; System.out.println("Error -- " + e.toString()); &#125; &#125;&#125; 文件输出流12345678910111213141516171819202122import java.io.*;public class ByteWriter &#123; public static void main(String[] arguments) &#123; int[] data = &#123; 71, 73, 70, 56, 57, 97, 13, 0, 12, 0, 145, 0, 0, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 0, 13, 0, 12, 0, 0, 2, 38, 132, 45, 121, 11, 25, 175, 150, 120, 20, 162, 132, 51, 110, 106, 239, 22, 8, 160, 56, 137, 96, 72, 77, 33, 130, 86, 37, 219, 182, 230, 137, 89, 82, 181, 50, 220, 103, 20, 0, 59 &#125;; try (FileOutputStream file = new FileOutputStream("pic.gif")) &#123; for (int i = 0; i &lt; data.length; i++) &#123; file.write(data[i]); &#125; file.close(); &#125; catch (IOException e) &#123; System.out.println("Error -- " + e.toString()); &#125; &#125;&#125; 字符流读取文本文件例一： 12345678910111213import java.io.*;public class FileCopy &#123; public static void main(String args[]) throws IOException&#123; FileReader f1; FileWriter f2; f1=new FileReader("FileCopy.java"); f2=new FileWriter("acopy_of_java_file.java"); int temp; while((temp=f1.read())!=-1); f2.write(temp); f1.close(); f2.close(); &#125; public FileCopy() &#123; &#125;&#125; 例二： 12345678910111213141516171819202122232425import java.io.*;public class SourceReader &#123; public static void main(String[] arguments) &#123; try ( FileReader file = new FileReader("SourceReader.java"); BufferedReader buff = new //这是讲读取的字符存储到缓冲区，以提高效率。 BufferedReader(file)) &#123; boolean eof = false; while (!eof) &#123; String line = buff.readLine(); if (line == null) &#123; eof = true; &#125; else &#123; System.out.println(line); &#125; &#125; buff.close(); &#125; catch (IOException e) &#123; System.out.println("Error -- " + e.toString()); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之C/S通信]]></title>
      <url>%2F2017%2F05%2F31%2FJava%E4%B9%8BC-S%E9%80%9A%E4%BF%A1%2F</url>
      <content type="text"><![CDATA[客户端使用BufferedReader从Socket上读取数据 建立对服务器的Socket连接 Socket chatSocket=new Socket(&quot;127.0.0.1&quot;,5000); 建立连接到Socket上底层输入串六的InputStreamReader InputStreamReader stream=new InputStreamReader(chatSocket.getInputStream()); 建立BufferedReader来读取 12BufferedReader reader=new BufferedReader(stream);String message=reader.readLine(); 用PrintWriter写数据到Socket 对服务器建立Socket连接 Socket chatSocket=new Socket(&quot;127.0.0.1&quot;,5000); 建立链接到Socket的PrintWriter PrintWriter=new PrintWriter(chatSocket.getOutputStream()); 写入数据 12writer.printIn("message to send");writer.print("another message"); 示例代码DailyAdviceClient客户端程序 12345678910111213141516171819202122232425import java.io.*;import java.net.*;public class DailyAdviceClient &#123; public void go()&#123; try &#123; Socket s = new Socket("127.0.0.1",4242); InputStreamReader streamReader = new InputStreamReader(s.getInputStream()); BufferedReader reader = new BufferedReader(streamReader); String advice = reader.readLine(); System.out.println("Today you should: " + advice); reader.close(); &#125; catch(IOException ex)&#123; ex.printStackTrace(); &#125; &#125; public static void main(String[] arg)&#123; DailyAdviceClient client = new DailyAdviceClient(); client.go(); &#125;&#125; 服务端工作方式 服务器应用程序对特定端口创建出ServerSocket ServerSocket serverSock=new ServerSocket(4242); 客户端对服务器应用程序建立Socket连接 Socket sock=new Socket(&quot;190.165.1.103&quot;,4242); 服务器创建出与客户端通信的新Socket Socket sock=serverSock.accept(); 示例代码DailyAdviceServer程序代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.*;import java.net.*;public class DailyAdviceServer &#123; String[] adviceList = &#123; "Take smaller bites", "Go for the tight jeans,No they do NOT make you look fat.", "One word: inappropriate", "Just for today, be honest. Tell your boss what you *really* think", "YOu might want to rethink that haircut" &#125;; public void go()&#123; try&#123; //ServerSocket会家庭客户端对这台机器在4242端口上的请求 ServerSocket serverSock = new ServerSocket(4242); //服务器进入无穷循环等待服务客户端的请求 while(true)&#123; Socket sock = serverSock.accept(); //这个方法会停下来等待要求到达后才会继续 PrintWriter writer = new PrintWriter(sock.getOutputStream()); String advice = getAdvice(); writer.println(advice); writer.close(); System.out.println(advice); &#125; &#125;catch(IOException ex)&#123; ex.printStackTrace(); &#125; &#125; private String getAdvice()&#123; int random = (int) (Math.random() * adviceList.length); return adviceList[random]; &#125; public static void main(String[] args)&#123; DailyAdviceServer server = new DailyAdviceServer(); server.go(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之序列化]]></title>
      <url>%2F2017%2F05%2F30%2FJava%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
      <content type="text"><![CDATA[简介序列化(serialize) 先回答这几个问题： 序列化是干什么的？ 简单说就是为了保存在内存中的各种对象的状态，并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存Object States，但是Java给你提供一种应该比你自己好的保存对象状态的机制,那就是序列化。 什么情况下需要序列化? 当你想把的内存中的对象保存到一个文件中或者数据库中时候； 当你想用套接字在网络上传送对象的时候； 当你想通过RMI传输对象的时候； 什么是实现对象序列化？ 对象序列化可以将一个对象保存到一个文件，可以将通过流的方式在网络上传输，可以将文件的内容读取转化为一个对象。所谓对象流也就是将对象的内容流化，可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对象流进行读写操作时引发的问题 如何实现对象序列化？ 将需要被序列化的类实现serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流（如FileOutputStream)来构造一个ObjectOutputStream（对象流）对象，接着使用ObjectOutputStream对象的writeObject（Object obj）方法就可以将参数obj的对象写出，要恢复的话则用输入流 实现序列化（保存到一个文件）的步骤 Make a FileOutputStream FileOutputStream fs = new FileOutputStream(&quot;foo.ser&quot;); Make a ObjectOutputStream ObjectOutputStream os = new ObjectOutputStream(fs); write the object os.writeObject(myObject1); os.writeObject(myObject2); os.writeObject(myObject3); close the ObjectOutputStream os.close(); 例子123456789101112131415161718192021222324252627282930import java.io.*;public class Box implements Serializable &#123; private int width; private int height; public void setWidth(int width) &#123; this.width = width; &#125; public void setHeight(int height) &#123; this.height = height; &#125; public static void main(String[] args) &#123; Box myBox = new Box(); myBox.setWidth(50); myBox.setHeight(30); try &#123; FileOutputStream fs = new FileOutputStream("foo.ser"); ObjectOutputStream os = new ObjectOutputStream(fs); os.writeObject(myBox); os.close(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; 注意事项 当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口； 当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化； 并非所有的对象都可以序列化，,至于为什么不可以，有很多原因了,比如： 安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输 等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。 资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且也是没有必要这样实现把一个对象完全转成字节序列，方便传输。 就像你寄一箱饼干，因为体积太大，就全压成粉末紧紧地一包寄出去，这就是序列化的作用。 只不过JAVA的序列化是可以完全还原的。 所谓序列化其实就是将程序中的数据(对象)通过某种方式，保存到本地中。然后把Java对象转换为字节序列的过程称为对象的序列化。 本文主要内容转载于：java 中的序列化是什么意思?有什么好处? 详细了解序列化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之AWT编程]]></title>
      <url>%2F2017%2F05%2F30%2FJava%E4%B9%8BAWT%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[简介AWTAWT 是Java基本类库的一部分,它在你的Java程序中提供了图形化用户界面,并且能够接收来自键盘,鼠标和其他输入设备的用户输入。 使用AWT包，则需要import java.awt.;（用于支持GUI的包还有java.swing.。这里直接用java.awt.*导入，其实主要是两个包：java.awt和java.awt.event） SwingSwing是AWT的一个扩展。使用Swing包，则需要import Javax.swing.*; Swing容器是java.awt.Container的子类，包含用于在容器中添加或产出组件、使用布局管理器来排列组件以及设置容器边框的方法。容器通常可放置到其他容器中。对象类层次结构如下 界面介绍注意窗口和面板的区别 创建窗口通过AWT12345678910111213141516171819202122import java.awt.*;class MyFirstFrame extends Frame &#123; private static final int FRAME_WIDTH = 300; private static final int FRAME_HEIGHT = 200; private static final int FRAME_X_ORIGIN = 150; private static final int FRAME_Y_ORIGIN = 250; public MyFirstFrame() &#123; setSize(FRAME_WIDTH, FRAME_HEIGHT); setResizable(false); setTitle("Program MyFirstFrame"); setLocation(FRAME_X_ORIGIN, FRAME_Y_ORIGIN); &#125;&#125;class TestMyFirstFrame &#123; public static void main(String args[]) &#123; MyFirstFrame frame = new MyFirstFrame(); frame.setVisible(true); &#125;&#125; 通过Swing1234567891011121314151617181920212223242526import javax.swing.*;public class SimpleFrame extends JFrame &#123;//继承JFrame框架类 public SimpleFrame() &#123; //创建构造方法 super("Frame Title"); setSize(300, 100); //设置框架大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setLookAndFeel(); setVisible(true); //刚创建时框架是不可见的，可使用该方法使框架可见 &#125; private static void setLookAndFeel() &#123; try &#123; UIManager.setLookAndFeel( "com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel" ); &#125; catch (Exception exc) &#123; // ignore error &#125; &#125; public static void main(String[] arguments) &#123; setLookAndFeel(); SimpleFrame sf = new SimpleFrame(); &#125;&#125; 添加组件通过AWT123456789101112131415161718192021222324252627282930313233import java.awt.*;class MyFirstFrame extends Frame &#123; private static final int FRAME_WIDTH = 300; private static final int FRAME_HEIGHT = 200; private static final int FRAME_X_ORIGIN = 150; private static final int FRAME_Y_ORIGIN = 250; private static final int BUTTON_WIDTH = 60; private static final int BUTTON_HEIGHT = 30; Button cancelButton, okButton;//添加两个按钮 public MyFirstFrame() &#123; setSize(FRAME_WIDTH, FRAME_HEIGHT); setResizable(false); setTitle("Program MyFirstFrame"); setLocation(FRAME_X_ORIGIN, FRAME_Y_ORIGIN); // add ok button okButton = new Button("OK"); okButton.setBounds(100, 150, BUTTON_WIDTH, BUTTON_HEIGHT); add(okButton); // add cancel button cancelButton = new Button("Cancel"); cancelButton.setBounds(170, 150, BUTTON_WIDTH, BUTTON_HEIGHT); add(cancelButton); &#125;&#125;class TestMyFirstFrame &#123; public static void main(String args[]) &#123; MyFirstFrame frame = new MyFirstFrame(); frame.setVisible(true); &#125;&#125; 通过Swing添加按钮12345678910111213141516171819202122232425262728293031323334import javax.swing.*;public class ButtonFrame extends JFrame &#123; JButton load = new JButton("Load"); JButton save = new JButton("Save"); JButton unsubscribe = new JButton("Unsubscribe"); public ButtonFrame() &#123; super("Button Frame"); setSize(340, 170); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel pane = new JPanel(); pane.add(load); pane.add(save); pane.add(unsubscribe); add(pane); setVisible(true); &#125; private static void setLookAndFeel() &#123; try &#123; UIManager.setLookAndFeel( "com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel" ); &#125; catch (Exception exc) &#123; System.out.println(exc.getMessage()); &#125; &#125; public static void main(String[] arguments) &#123; setLookAndFeel(); ButtonFrame bf = new ButtonFrame(); &#125;&#125; 创建一个登陆界面页面包含组件有：标签（JLabel）、文本框（JTextField、JPasswordField）、文本区域（JTextArea）、按钮（JButton） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import javax.swing.*;public class Authenticator extends javax.swing.JFrame &#123; JTextField username = new JTextField(15); JPasswordField password = new JPasswordField(15); JTextArea comments = new JTextArea(4, 15); JButton ok = new JButton("OK"); JButton cancel = new JButton("Cancel"); public Authenticator() &#123; super("Account Information"); setSize(300, 220); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel pane = new JPanel(); JLabel usernameLabel = new JLabel("Username: "); JLabel passwordLabel = new JLabel("Password: "); JLabel commentsLabel = new JLabel("Comments: "); comments.setLineWrap(true); comments.setWrapStyleWord(true); pane.add(usernameLabel); pane.add(username); pane.add(passwordLabel); pane.add(password); pane.add(commentsLabel); pane.add(comments); pane.add(ok); pane.add(cancel); add(pane); setVisible(true); &#125; private static void setLookAndFeel() &#123; try &#123; UIManager.setLookAndFeel( "com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel" ); &#125; catch (Exception exc) &#123; System.out.println(exc.getMessage()); &#125; &#125; public static void main(String[] arguments) &#123; Authenticator.setLookAndFeel(); Authenticator auth = new Authenticator(); &#125;&#125; 运行结果： 添加单选框或复选框 单选框： JRadioButton 复选框： JCheckBox 1234567891011121314151617181920212223242526272829303132333435363738394041import javax.swing.*;public class FormatFrame extends JFrame &#123; JRadioButton[] teams = new JRadioButton[4]; public FormatFrame() &#123; super("Choose an Output Format"); setSize(320, 120); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); teams[0] = new JRadioButton("Atom"); teams[1] = new JRadioButton("RSS 0.92"); teams[2] = new JRadioButton("RSS 1.0"); teams[3] = new JRadioButton("RSS 2.0", true); JPanel panel = new JPanel(); JLabel chooseLabel = new JLabel( "Choose an output format for syndicated news items."); panel.add(chooseLabel); ButtonGroup group = new ButtonGroup(); for (JRadioButton team : teams) &#123; group.add(team); panel.add(team); &#125; add(panel); setVisible(true); &#125; private static void setLookAndFeel() &#123; try &#123; UIManager.setLookAndFeel( "com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel" ); &#125; catch (Exception exc) &#123; System.out.println(exc.getMessage()); &#125; &#125; public static void main(String[] arguments) &#123; FormatFrame.setLookAndFeel(); FormatFrame ff = new FormatFrame(); &#125;&#125; 运行结果： 事件当用户移动鼠标、单击按钮时，一个事件就产生了 一个对象既可以是事件源对象，也可以是事件侦听对象，或二种角色兼有 如果界面使用Swing实现，则若要进行界面的事件操作，应该引入三个包： import java.awt.event.*; import javax.swing.*; import java.awt.*; 设置组件将类用作时间监听器是，必须首先设置它要监听的时间类型。如果不进行第二步操作——将匹配的监听器加入到GUI组建中，这种情况将不会发生。组件被使用时，该监听器将激发相应的事件。、 创建组件后，可以调用组件的下述方法之一将监听器与组件关联起来。 addActionListener()、addFocusListener()…其实就是在上面所给图中的接口的前面加一个”add”就行了。 事件处理方法将接口与类关联起来是，这个类必须处理接口包含的所有方法。 以接口ActionListener为例，其只有一个方法actionPerformed()。所有实现ActionListener的类都必须有一个结构与下面类似的方法： 123public void actionPerformed(ActionEvent event)&#123; //handle event here&#125; 事件创建举例各个事件的操作都差不多，这里只先提供焦点事件操作的过程。其它的时间操作先留个坑，以后再补。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.awt.event.*;import javax.swing.*;import java.awt.*;public class Calculator extends JFrame implements FocusListener &#123; JTextField value1, value2, sum; JLabel plus, equals; public Calculator() &#123; super("Add Two Numbers"); setSize(350, 90); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setLookAndFeel(); FlowLayout flow = new FlowLayout(FlowLayout.CENTER); setLayout(flow); //设置框架展示在什么位置 // create components value1 = new JTextField("0", 5); plus = new JLabel("+"); value2 = new JTextField("0", 5); equals = new JLabel("="); sum = new JTextField("0", 5); // add listeners value1.addFocusListener(this);//表示当前类就是事件监听器 value2.addFocusListener(this); // set up sum field sum.setEditable(false); // add components add(value1); add(plus); add(value2); add(equals); add(sum); setVisible(true); &#125; public void focusGained(FocusEvent event) &#123; try &#123; float total = Float.parseFloat(value1.getText()) + Float.parseFloat(value2.getText()); sum.setText("" + total); &#125; catch (NumberFormatException nfe) &#123; value1.setText("0"); value2.setText("0"); sum.setText("0"); &#125; &#125; public void focusLost(FocusEvent event) &#123; focusGained(event); &#125; private void setLookAndFeel() &#123; try &#123; UIManager.setLookAndFeel( "com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel" ); SwingUtilities.updateComponentTreeUI(this); &#125; catch (Exception exc) &#123; System.err.println("Couldn't use the system " + "look and feel: " + exc); &#125; &#125; public static void main(String[] arguments) &#123; Calculator frame = new Calculator(); &#125;&#125; 运行结果：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之JDBC语句对象]]></title>
      <url>%2F2017%2F05%2F30%2FJava%E4%B9%8BJDBC%E8%AF%AD%E5%8F%A5%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[JDBC 提供三种类型的语句对象： Statement ， PreparedStatement ， CallableStatement 其中 PreparedStatement 是 Statement 的子类， CallableStatement 是 PreparedStatement 的子类。每一种语句对象用来运行特定类型的 SQL 语句 Statement 对象用来运行简单类型的 SQL 语句，语句中无需指定参数 PreparedStatement 对象用来运行包含（或不包含） IN 类型参数的预编译 SQL 语句 CallableStatement 对象用来调用数据库存储过程 Statement概述Statement 对象用于将 SQL 语句发送到数据库服务器 创建 Statement 对象建立连接后， Statement 对象用 Connection 对象的 createStatement 方法创建，以下代码创建 Statement 对象： 12Connection con = DriverManager.getConnection(url, SYSDBA, SYSDBA);Statement stmt = con.createStatement(); 使用 Statement 对象执行语句tatement 接口提供了三种执行 SQL 语句的方法： executeQuery 、 executeUpdate 和 execute 方法 executeQuery 用于产生单个结果集的语句，例如 SELECT 语句 方法 executeUpdate 用于执行 INSERT 、 UPDATE 或 DELETE 语句以及 SQL DDL 语句，如 CREATE TABLE 和 DROP TABLE 。 INSERT 、 UPDATE 或 DELETE 语句的效果是修改表中零行或多行中的一列或多列。 executeUpdate 的返回值是一个整数，表示受影响的行数。对于 CREATE TABLE 或 DROP TABLE 等 DDL 语句， executeUpdate 的返回值总为零 方法 execute 用于执行返回多个结果集、多个更新元组数或二者组合的语句 执行语句的三种方法都将关闭所调用的 Statement 对象的当前打开结果集（如果存在）。这意味着在重新执行 Statement 对象之前，需要完成对当前 ResultSet 对象的处理。 关闭 Statement 对象Statement 对象可由 Java 垃圾收集程序自动关闭。但作为一种好的编程风格，应在不需要 Statement 对象时显式地关闭它们。这将立即释放数据库服务器资源，有助于避免潜在的内存问题 PreparedStatement概述PreparedStatement 继承 Statement ，并与之在两方面有所不同： PreparedStatement 对象包含已编译的 SQL 语句，语句已经 “ 准备好 ” 包含于 PreparedStatement 对象中的 SQL 语句可具有一个或多个 IN 参数。 IN 参数的值在 SQL 语句创建时未被指定。相反，该语句为每个 IN 参数保留一个问号（ “ ？ ” ）作为占位符。每个问号所对应的值必须在该语句执行之前，通过适当的 setXXX 方法来提供。 由于PreparedStatement 对象已预编译过，所以其执行速度要快于 Statement 对象。因此，需要多次重复执行的 SQL 语句经常创建为 PreparedStatement 对象，以提高效率。 作为 Statement 的子类， PreparedStatement 继承了 Statement 的所有功能。另外它还添加了一整套方法，用于设置发送给数据库以取代 IN 参数占位符的值。同时，三种方法 execute 、 executeQuery 和 executeUpdate 能执行设置好参数的语句对象 创建 PreparedStatement 对象以下的代码段（其中 con 是 Connection 对象）创建一个 PreparedStatement 对象： 1PreparedStatement pstmt = con.prepareStatement( UPDATE 厂商登记 SET 厂商名 = ? WHERE 厂商编号 = ?); 对象 pstmt 包含语句 UPDATE 厂商登记 SET 厂商名 = ? WHERE 厂商编号 = ? ，该语句带两个 IN 参数占位符，它已发送给数据库，并由服务器为其执行作好了准备。 CallableStatement概述CallableStatement 用来运行 SQL 存储过程。存储过程是数据库中已经存在的 SQL 语句，它通过名字调用 CallableStatement 是 PreparedStatement 的子类。 CallableStatement 中定义的方法用于处理 OUT 参数或 INOUT 参数的输出部分：注册 OUT 参数的 JDBC 类型（一般 SQL 类型）、从这些参数中检索结果，或者检查所返回的值是否为 JDBC NULL。 创建 CallableStatement 对象CallableStatement 对象是用 Connection.prepareCall 创建的。 以下代码创建 CallableStatement 对象，其中含有对存储过程 p1 的调用， con 为连接对象： 1CallableStatement cstmt = con.prepareCall(call p1(?, ?)); 其中 ? 占位符为 IN 、 OUT 还是 INOUT 参数，取决于存储过程 p1 。 详细介绍地址——JDBC语句对象 示例12345678910111213141516171819202122232425262728improt java.sql.*;public class JDBCExample&#123;public static void main(String args[])&#123;try&#123;Statement stmt;ResultSet rs;Class.forName(“com.mysql.jdbc.Driver”);String url = “jdbc:mysql://localhost:3306/db”;Connection con = DriverManager.getConnection(url,“root”,“1234”);stmt = con.createStatement();rs = stmt.executeQuery(“select name from empt whereage=‘25’”);while(rs.next())&#123;String name = rs.getString (“name”);&#125;rs.close(); //关闭结果集对象stmt.close(); //关闭SQL语句对象con.close(); //关闭连接对象&#125;catch(Exception ex)&#123;ex.printStackTrace();&#125;&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之初识JDBC]]></title>
      <url>%2F2017%2F05%2F30%2FJava%E4%B9%8B%E5%88%9D%E8%AF%86JDBC%2F</url>
      <content type="text"><![CDATA[简介JDBC：（Java Database Connectivity,Java数据库连接）是一组类。通过JDBC，可以在Java程序中使用相容的类和方法来读写记录以及执行其他是数据库访问操作。被称为驱动程序的类是连接到数据源的桥梁——对于每种流行的数据库（Oracle、Mysql等），都有相应的驱动程序。 对于每种常见的数据库使用任务，JDBC库中都有相应的类： 连接到数据库 使用SQL创建语句 在数据库中执行SQL查询 查看结果 这些JDBC类都位于java.sql包中 通过示例学习基本操作本示例用的是Mysql数据库 先来规定一个环境123456789101112131415161718192021222324252627282930313233343536373839404142434445static class Student &#123; private String Id; private String Name; private String Sex; private String Age; Student(String Name, String Sex, String Age) &#123; this.Id = null; //default this.Name = Name; this.Sex = Sex; this.Age = Age; &#125; public String getId() &#123; return Id; &#125; public void setId(String Id) &#123; this.Id = Id; &#125; public String getName() &#123; return Name; &#125; public void setName(String Name) &#123; this.Name = Name; &#125; public String getSex() &#123; return Sex; &#125; public void setSex(String Sex) &#123; this.Sex = Sex; &#125; public String getAge() &#123; return Age; &#125; public void setage(String Age) &#123; this.Age = Age; &#125;&#125; 连接数据库123456789101112131415161718 private static Connection getConn() &#123; String driver = "com.mysql.jdbc.Driver"; String url = "jdbc:mysql://localhost:3306/samp_db"; String username = "root"; String password = ""; Connection conn = null; try &#123; Class.forName(driver); //classLoader,加载对应驱动 conn = (Connection) DriverManager.getConnection(url, username, password);//也可以写成： Connection conn =DriverManager.getConnection(url, username, password); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; 开始操作数据库insert(增)123456789101112131415161718private static int insert(Student student) &#123; Connection conn = getConn(); int i = 0; String sql = "insert into students (Name,Sex,Age) values(?,?,?)"; PreparedStatement pstmt; try &#123; pstmt = (PreparedStatement) conn.prepareStatement(sql); pstmt.setString(1, student.getName()); pstmt.setString(2, student.getSex()); pstmt.setString(3, student.getAge()); i = pstmt.executeUpdate(); pstmt.close(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i;&#125; update(改)12345678910111213141516private static int update(Student student) &#123; Connection conn = getConn(); int i = 0; String sql = "update students set Age='" + student.getAge() + "' where Name='" + student.getName() + "'"; PreparedStatement pstmt; try &#123; pstmt = (PreparedStatement) conn.prepareStatement(sql); i = pstmt.executeUpdate(); System.out.println("resutl: " + i); pstmt.close(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i;&#125; select(查)123456789101112131415161718192021222324private static Integer getAll() &#123; Connection conn = getConn(); String sql = "select * from students"; PreparedStatement pstmt; try &#123; pstmt = (PreparedStatement)conn.prepareStatement(sql); ResultSet rs = pstmt.executeQuery(); int col = rs.getMetaData().getColumnCount(); System.out.println("============================"); while (rs.next()) &#123; for (int i = 1; i &lt;= col; i++) &#123; System.out.print(rs.getString(i) + "\t"); if ((i == 2) &amp;&amp; (rs.getString(i).length() &lt; 8)) &#123; System.out.print("\t"); &#125; &#125; System.out.println(""); &#125; System.out.println("============================"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null;&#125; delete(删)12345678910111213141516private static int delete(String name) &#123; Connection conn = getConn(); int i = 0; String sql = "delete from students where Name='" + name + "'"; PreparedStatement pstmt; try &#123; pstmt = (PreparedStatement) conn.prepareStatement(sql); i = pstmt.executeUpdate(); System.out.println("resutl: " + i); pstmt.close(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i;&#125; 调用运行12345678public static void main(String args[]) &#123; JDBCOperation.getAll(); JDBCOperation.insert(new Student("Achilles", "Male", "14")); JDBCOperation.getAll(); JDBCOperation.update(new Student("Bean", "", "7")); JDBCOperation.delete("Achilles"); JDBCOperation.getAll();&#125; 分析通过以上代码可以看出，JDBC的操作有通用的流程： 创建Connection对象、SQL查询命令字符串 对Connection对象传入SQL查询命令，获得PreparedStatement对象 对PreparedStatement对象执行executeUpdate()或executeQurey()获得结果 先后关闭PreparedStatement对象和Connection对象 可见，使用JDBC时，最常打交道的是Connection、PreparedStatement这两个类，以及select中的ResultSet类。 本文主要内容转载于：通过JDBC进行简单的增删改查（以MySQL为例）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之线程]]></title>
      <url>%2F2017%2F05%2F30%2FJava%E4%B9%8B%E7%BA%BF%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[创建线程有两种方法可以创建线程： 需要从Java.lang.Thread类派生一个新的线程类，重载它的run()方法 实现Runnable接口，重载Runnable接口中的run()方法 为什么要提供两种方法来创建线程呢？ 在Java中，类仅支持单继承，也就是说，当定义一个新的类的时候，它只能扩展一个外部类.这样，如果创建自定义线程类的时候是通过扩展 Thread类的方法来实现的，那么这个自定义类就不能再去扩展其他的类，也就无法实现更加复杂的功能。因此，如果自定义类必须扩展其他的类，那么就可以使用实现Runnable接口的方法来定义该类为线程类，这样就可以避免Java单继承所带来的局限性。另外，使用实现Runnable接口的方式创建的线程可以处理同一资源，从而实现资源的共享。 Runnable这个接口只有一个方法：public void run(); 通过Runnable接口创建线程 建立Runnable对象 Runnable threaJob=new MyRunnable(); 建立Thread对象并赋值Runnable任务 Thread就像一个工人，需要一个任务才能进行工作，而这个任务就在Runnable()的run()方法中 Thread myThread new Thread(threadJob); 启动Thread 工人有了任务滞后，就可以让他去工作了 myThread.start(); 例子： 12345678910111213141516171819202122232425262728//每个任务都是Runable接口的一个实例，任务是可运行对象，线程是便于任务执行的对象。必须创建任务类，重写run方法定义任务public class ThreadDemo1 implements Runnable &#123; private int countDown = 10; @Override //重写run方法，定义任务 public void run() &#123; while(countDown-- &gt;0) &#123; System.out.println("$" + Thread.currentThread().getName() + "(" + countDown + ")");//该方法若要访问当前线程，应使用Thread.currentThread() &#125; &#125; //调用start方法会启动一个线程，导致任务中的run方法被调用，run方法执行完毕则线程终止 public static void main(String[] args) &#123; Runnable demo1 = new ThreadDemo1(); Thread thread1 = new Thread(demo1); Thread thread2 = new Thread(demo1); thread1.start(); thread2.start(); System.out.println("火箭发射倒计时:"); &#125;&#125; 运行结果： 火箭发射倒计时: $Thread-0(9) $Thread-0(8) $Thread-0(7) $Thread-0(6) $Thread-0(5) $Thread-0(4) $Thread-0(3) $Thread-0(2) $Thread-0(1) $Thread-0(0) 如果同时运行两个任务对象，体会其不同的之处： 123456789101112public static void main(String[] args) &#123; Runnable demo1 = new ThreadDemo1(); Runnable demo2 = new ThreadDemo1(); Thread thread1 = new Thread(demo1); Thread thread2 = new Thread(demo2); thread1.start(); thread2.start(); System.out.println("火箭发射倒计时:"); &#125; 运行结果： 火箭发射倒计时: $Thread-0(9) $Thread-0(8) $Thread-0(7) $Thread-0(6) $Thread-1(9) $Thread-0(5) $Thread-1(8) $Thread-0(4) $Thread-1(7) $Thread-0(3) $Thread-1(6) $Thread-1(5) $Thread-0(2) $Thread-1(4) $Thread-1(3) $Thread-1(2) $Thread-1(1) $Thread-1(0) $Thread-0(1) $Thread-0(0) 继承Thread类来创建线程 首先创建一个任务类extends Thread类，因为Thread类实现了Runnable接口，所以自定义的任务类也实现了Runnable接口，重写run()方法，其中定义具体的任务代码或处理逻辑 创建一个任务类对象，可以用Thread或者Runnable作为自定义的变量类型 调用自定义对象的start()方法，启动一个线程 例子： 123456789101112131415161718192021222324252627//每个任务都是Runable接口的一个实例，任务是可运行对象，线程即可运行对象。必须创建任务类，重写run方法定义任务public class ExtendFromThread extends Thread &#123; private int countDown = 10; @Override //重写run方法，定义任务 public void run() &#123; while(countDown-- &gt;0) &#123; System.out.println("$" + this.getName() + "(" + countDown + ")"); &#125; &#125; //调用start方法会启动一个线程，导致任务中的run方法被调用，run方法执行完毕则线程终止 public static void main(String[] args) &#123; ExtendFromThread thread1 = new ExtendFromThread(); ExtendFromThread thread2 = new ExtendFromThread(); thread1.start(); thread2.start(); System.out.println("火箭发射倒计时:"); &#125;&#125; 运行结果： 火箭发射倒计时: $Thread-0(9) $Thread-0(8) $Thread-0(7) $Thread-0(6) $Thread-0(5) $Thread-0(4) $Thread-0(3) $Thread-0(2) $Thread-0(1) $Thread-0(0) $Thread-1(9) $Thread-1(8) $Thread-1(7) $Thread-1(6) $Thread-1(5) $Thread-1(4) $Thread-1(3) $Thread-1(2) $Thread-1(1) $Thread-1(0) 两种创建方法的比较 使用实现Runnable接口方式创建线程可以共享同一个目标对象，实现了多个相同线程处理同一份资源，即一个线程对资源的操作会影响到另一个进程的操作 而继承Thread创建线程的方式，new出了两个任务类对象，有各自的成员变量，相互之间不干扰。 各自的优缺点 采用继承Thread类方式： 优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程 缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类 采用实现Runnable接口方式： 优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想 缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法 本文以上主要内容转载于：java多线程总结一：线程的两种创建方式及比较 线程睡眠直接上代码： 1234567891011121314151617181920212223242526272829303132public class MyRunnable implements Runnable &#123; public void run()&#123; go(); &#125; public void go()&#123; //线程睡眠代码块 try&#123; Thread.sleep(2000); &#125;catch(InterruptedException ex)&#123; ex.printStackTrace(); &#125;//代码块结束 doMore(); &#125; public void doMore()&#123; System.out.println("top 0' the stack"); &#125;&#125;class ThreadTestDrive&#123; public static void main(String[] args)&#123; Runnable threadJob=new MyRunnable(); Thread mythread=new Thread(threadJob); mythread.start(); System.out.println("back in main"); &#125;&#125; 线程同步机制为什么要线程同步？我们现在知道，可以实现多个线程共享同一个资源（变量或者对象）的情况，如果这些线程都对需要对资源进行读或者写操作，由于线程之间的调度等其它问题，会导致资源的状态出现紊乱，导致程序异常。举个例子：如果一个银行账户同时被两个线程操作，一个取100块，一个存钱100块。假设账户原本有0块，如果取钱线程和存钱线程同时发生，会出现什么结果呢？取钱不成功，账户余额是100.取钱成功了，账户余额是0.那到底是哪个呢？由于是同时发生的两件事，很难说清楚。因此多线程同步就是要解决这个问题。 Java的同步机制是通过对象锁来实现的： 一段synchronized的代码被一个线程执行之前，他要先拿到执行这段代码的权限，在 Java里边就是拿到某个同步对象的锁（一个对象只有一把锁）； 如果这个时候同步对象的锁被其他线程拿走了，他（这个线程）就只能等了（线程阻塞在锁池 等待队列中）。 取到锁后，他就开始执行同步代码(被synchronized修饰的代码）；线程执行完同步代码后马上就把锁还给同步对象，其他在锁池中 等待的某个线程就可以拿到锁执行同步代码了。这样就保证了同步代码在统一时刻只有一个线程在执行。 例子： 1234567891011121314151617181920public class ThreadTest2 extends Thread &#123; private int threadNo; private String lock; public ThreadTest2(int threadNo, String lock) &#123; this.threadNo = threadNo; this.lock = lock; &#125; public static void main(String[] args) throws Exception &#123; String lock = new String("lock"); for (int i = 1; i &lt; 10; i++) &#123; new ThreadTest2(i, lock).start(); Thread.sleep(1); &#125; &#125; public void run() &#123; synchronized (lock) &#123; //原子单位 for (int i = 1; i &lt; 10000; i++) &#123; System.out.println("No." + threadNo + ":" + i); &#125; &#125; &#125; &#125; 该程序通过在main方法启动10个线程之前，创建了一个String类型的对象。并通过ThreadTest2的构造函数，将这个对象赋值 给每一个ThreadTest2线程对象中的私有变量lock。根据Java方法的传值特点，我们知道，这些线程的lock变量实际上指向的是堆内存中的 同一个区域，即存放main函数中的lock变量的区域。run方法加一个synchronized块来实现。这个同步块的对象锁，就是 main方法中创建的那个String对象。换句话说，他们指向的是同一个String类型的对象，对象锁是共享且唯一的！ 于是，我们看到了预期的效果：10个线程不再是争先恐后的报数了，而是一个接一个的报数。 同步的实现方式可分为： 同步方法 同步代码块 使用特殊域变量(volatile)实现线程同步 使用重入锁实现线程同步 详细介绍链接 多线程的使用场景 为了不阻塞主线程，启动其他线程来做耗时的事情。比如app开发中耗时的操作都不在UI主线程中做。 实现响应更快的应用程序， 即主线程专门监听用户请求，子线程用来处理用户请求。以获得大的吞吐量。感觉这种情况下，多线程的效率未必高。 这种情况下的多线程是为了不必等待， 可以并行处理多条数据。比如JavaWeb的就是主线程专门监听用户的HTTP请求，然后启动子线程去处理用户的HTTP请求。 某种优先级虽然很低的服务，但是却要不定时去做。比如Jvm的垃圾回收。 某种任务，虽然耗时，但是不耗CPU的操作时，开启多个线程，效率会有显著提高。比如读取文件，然后处理。 磁盘IO是个很耗费时间，但是不耗CPU计算的工作。 所以可以一个线程读取数据，一个线程处理数据。肯定比一个线程读取数据，然后处理效率高。 因为两个线程的时候充分利用了CPU等待磁盘IO的空闲时间。曾几何时想过使用多线程读取磁盘数据， 但是读取磁盘数据的性能瓶颈是IO，而不是CPU。 使用多线程的目的是为了不让CPU闲下来，明显不适合用于读取磁盘数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之异常]]></title>
      <url>%2F2017%2F05%2F29%2FJava%E4%B9%8B%E5%BC%82%E5%B8%B8%2F</url>
      <content type="text"><![CDATA[简介Java的异常处理依赖于你已经知道所调用的方法是有风险的（也就是方法可能产生异常），因此你可编写出处理此可能性的代码，如果你知道调用某个方法可能会有异常状况，你就可以与预先准备好对问题的处理程序，或者是从错误中恢复。 在Java中最好将有风险的程序代码包含在try/catch块中，这样才能对异常进行捕获和处理。 异常是一种Exception类型的对象。 格式： 12345try&#123; //危险动作&#125;catch(Exception ex)&#123;//因为异常是对象，所以你catch住的也是对象。 //尝试恢复&#125; 创建和抛出异常没错，我们不仅能写处理异常的程序，也可以自己创建和抛出异常，具体方式请往下看。 创建有风险、会抛出异常的程序代码： 12345public void takeRisk() throws BadException &#123;//必须声明它会抛出BadException if(abandonAllHope)&#123; throw new BadException();//创建Exception对象并抛出 &#125;&#125; 调用该方法的程序代码 12345678public void crossFingers()&#123; try&#123; anObject.takeRisk(); &#125;catch(BadException ex)&#123; System.out.printIn("Aaargh!"); ex.printStackTrace();//如果无法从异常中恢复，至少也使用printStackTrace()列出有用的信息 &#125;&#125; 如果你有抛出异常，则一定要使用throw来声明这件事。 注意： 编译器不会注意RuntimeException类型的异常。RuntimeExcetion不需要声明或被包含在try/catch的块中（然而你还是可以这样做）。编译器所关心的是成为检查异常（checked exception）的异常，程序必须要认识有以上可能的存在。 方法可以用trow关键系抛出异常对象： throw new FileIsTooSmallException(); 可能会抛出异常的方法必须声明成throws Exception try/catch块的流程控制当你调用有风险的方法时，发生的事有两种可能的情况： 成功的把try块完成 把异常丢回调用方的方法 finally:无论如何都要执行的部分打个比方，你做菜，得把火打开，然后会有两种情况，一种是全程没问题，你顺利把菜炒完，另一种是出现状况了，比如锅漏了这种异常导致你做菜大业失败，但是不管哪种情况，发生之后都必须执行的是把炉子关掉，而关炉子这个流程就是放在finally块中的。 很明显，finally块是用来存放不管有没有异常都得执行的程序。 格式： 12345678try&#123; turnOvenOn(); x.bake();&#125;catch(BakingException ex)&#123; ex.printStackTrace();&#125;finally&#123; turnOvenOff();&#125; 值得注意的是，就酸try或catch块中有return子凌，finally还是会执行，流程调到finally然后在回到return指令，就是这么厉害。 举个栗子： 123456789101112131415161718192021222324252627public class TestExceptions &#123; public static void main(String[] args) &#123; String test = "no"; //String test = "yes"; try&#123; System.out.println("start try"); doRisky(test); System.out.println("end try"); &#125; catch (ScaryException se) &#123; System.out.println("scary exception"); &#125; finally &#123; System.out.println("finally"); &#125; System.out.println("end of main"); &#125; //(API中没有此类)因此要自己写ScaryException类 static void doRisky(String test) throws ScaryException &#123; System.out.println("start risky"); if("yes".equals(test))&#123; throw new ScaryException(); &#125; System.out.println("end risky"); return; &#125;&#125; 运行结果为： start try start risky end risky end try finally end of main 若第三行改为“String test = "no";”则结果应为： start try start risky scary exception finally end of main 多重异常如果有必要，方法可以排除多个异常。但该方法的声明必须要有含有全部可能的检查异常（若两个或两个以上的异常有共同的父类是，可以只声明该父类就行） 格式： 123456789101112131415161718public class Laundry&#123; public void doLaundry() throws PantsException,LingerieException&#123; //有可能抛出两个异常的程序代码 &#125;&#125;public class Foo&#123; public void go()&#123; Laundry laundry=new Laundry(); try&#123; laundry.doLaundry(); &#125;catch(PantsException pex)&#123; //恢复程序代码 &#125;catch(LingerieException pex)&#123; //恢复程序代码 &#125; &#125;&#125; 异常具有多态性是基于类的继承关系得来的，父类或者子类的异常可以直接catch父类的异常来包含所有异常，catch子类的异常则只能用来处理子类的异常，对父类的不起作用。但是这也不意味着就可以都直接catch父类的异常来省去catch子类异常的步骤，因为直接catch父类的异常会导致不知道是哪个子类发生的异常，你会搞不清到底哪里出错了。 有多个catch块时要从大到小排列“从大到小”指的是按照类的继承关系，从最下面的子类放第一个位置，最开始的父类放最下面。兄弟之间次序不重要，可以随便放。 duck异常没错，不想处理的异常可以duck（躲避）掉。 方法时让调用的方法抛出异常，让调用那个方法的方法也抛出异常，就像踢皮球一样，不去管那个异常，只管抛出去，自己不管。既然都不管，这样踢来踢去最后只能落到Java虚拟机上，而Java虚拟机并不在意异常，所以程序就能编译通过。 123456789101112public class Test &#123; Laundry laundry=new Laundry(); public void foo() throws ClothingException&#123; laundry.doLaundry(); &#125; public static void main(String[] args) throws ClothingException&#123; Washer a=new Washer(); a.foo(); &#125;&#125; 以上代码如果将main函数里的throws ClothingException去掉，即没有duck掉异常，则无法通过编译，还会出现“unzepozted eception”的错误信息。如果不想duck掉，就老老实实用try/catch块将a.foo()这一危险操作包起来。 异常处理的结构规则 catch与finally不能没有try try与catch之间不能有程序 try一定要有catch或finally 只带有finally的try必须要声明异常 栗子： 12345void go() throws FooException&#123;//只带有finally的try try&#123; x.doStuff(); &#125;finally&#123; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java入门（五）]]></title>
      <url>%2F2017%2F05%2F29%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
      <content type="text"><![CDATA[继承 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。 多个类可以称为子类，单独这个类称为父类、超类或者基类。 子类可以直接访问父类中的非私有的属性和行为。 通过 extends 关键字让类与类之间产生继承关系。 具体实现为，通过extends关键字让类与类之间产生继承关系： class SubDemo extends Demo{} //SubDemo是子类，Demo是父类 继承提高了代码的复用性，让类与类之间产生关系，是多态的前提。 super和this的区别super是一个关键字，代表父类的存储空间标识。(可以理解为父亲的引用) this代表对象的引用(谁调用就代表谁)； super代表当前子类对父类的引用。 使用场景 当子父类出现同名成员时，可以用super进行区分 子类要调用父类构造函数时，可以使用super语句 具体用法 成员变量 构造方法 成员方法 注意： super();和this();都是在构造函数的第一行，不能同时出现（this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过） this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块 举个栗子： 123456789101112131415161718192021222324252627282930313233343536373839class Person &#123; public static void prt(String s) &#123; System.out.println(s); &#125; Person() &#123; prt("父类·无参数构造方法： "+"A Person."); &#125;//构造方法(1) Person(String name) &#123; prt("父类·含一个参数的构造方法： "+"A person's name is " + name); &#125;//构造方法(2) &#125; public class Chinese extends Person &#123; Chinese() &#123; super(); // 调用父类构造方法（1） prt("子类·调用父类”无参数构造方法“： "+"A chinese coder."); &#125; Chinese(String name) &#123; super(name);// 调用父类具有相同形参的构造方法（2） prt("子类·调用父类”含一个参数的构造方法“： "+"his name is " + name); &#125; Chinese(String name, int age) &#123; this(name);// 调用具有相同形参的构造方法（3） prt("子类：调用子类具有相同形参的构造方法：his age is " + age); &#125; public static void main(String[] args) &#123; System.out.println("第一条语句执行结果为："); Chinese cn = new Chinese(); System.out.println("第二条语句执行结果为："); cn = new Chinese("codersai"); System.out.println("第三条语句执行结果为："); cn = new Chinese("codersai", 18); &#125; &#125; 运行结果为： 抽象类 Java中可以定义没有方法体的方法，该方法的具体实现由子类完成，该方法称为抽象方法，包含抽象方法的类就是抽象类 抽象方法和抽象类都必须被abstract关键字修饰 抽象类不可以用new创建对象，因为调用抽象方法没意义 抽象类中的抽象方法要被使用，必须由子类复写其所有的抽象方法后，建立子类对象调用； 如果子类只覆盖了部分的抽象方法，那么该子类还是一个抽象类 抽象类中可以有抽象方法，也可以有非抽象方法，抽象方法用于子类实例化 如果一个类是抽象类，那么，继承它的子类，要么是抽象类，要么重写所有抽象方法。特殊：抽象类中可以不定义抽象方法，这样做仅仅是不让该类建立对象 栗子： 123456789101112131415161718192021222324abstract class 葵花宝典 &#123; public abstract void 自宫();&#125;class 岳不群 extends 葵花宝典 &#123; public void 自宫()&#123; System.out.println("剪刀"); &#125;&#125;class 林平之 extends 葵花宝典&#123; public void 自宫()&#123; System.out.println("指甲刀"); &#125;&#125;class AbstractTest &#123; public static void main(String[] args) &#123; 岳不群 岳 = new 岳不群(); 岳.自宫(); 林平之 林 = new 林平之(); 林.自宫(); &#125;&#125; 抽象类不能被实例化，为什么还有构造函数？ 只要是class定义的类里面就肯定有构造函数。抽象类中的函数是给子类实例化的。 一个类没有抽象方法，为什么定义为抽象类? 不想被继承，还不想被实例化。 抽象关键字abstract不可以和哪些关键字共存？ final：如果方法被抽象，就需要被覆盖，而final是不可以被覆盖，所以冲突。 private：如果函数被私有了，子类无法直接访问，怎么覆盖呢？ static：不需要对象，类名就可以调用抽象方法。而调用抽象方法没有意义。 接口接口是抽象方法和常量值的集合。从本质上讲，接口是一种特殊的抽象类，这种抽象类只包含常量和方法的定义，而没有变量和方法的实现。 格式：interface 接口名{}（注意没有“class”） 实现：class 类名 implements 接口名 {} 接口的成员特点： 成员常量：public static final，接口里定义的变量是全局常量，而且修饰符只能是这三个关键字，都可以省略，常量名要大写 成员方法：public abstract，接口里定义的方法都是抽象的，两个修饰符关键字可省略 推荐：永远手动给出修饰符 抽象类与接口的区别 成员变量： 抽象类能有变量也可以有常量 接口只能有常量 成员方法： 抽象类可以有非抽象的方法,也可以有抽象的方法 接口只能有抽象的方法 构造方法： 抽象类有构造方法 接口没有构造方法 类与抽象类和接口的关系： 类与抽象类的关系是继承 extends 类与接口的关系是实现 implements 一个类可以实现多个接口吗？答案是肯定可以的，接口本身就是解决多重继承衍生的产物，如果不能实现多个接口那接口姐没有什么意义了。 例子： 1234567891011121314151617//A接口interface A&#123; public int getA();&#125;//B接口interface B&#123; public int getB();&#125;//实现了某个接口必须实现其全部的方法public class ImpAB implements A,B&#123; public int getA() &#123; return 0; &#125; public int getB() &#123; return 0; &#125;&#125; 内部类将一个类定义在另一个类里面，里面的那个类就称为内部类 内部类可以直接访问外部类的成员，包括私有成员 外部类要访问内部类的成员，必须要建立内部类的对象 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 内部类不能用普通的方式访问。内部类是外部类的一个成员，因此内部类可以自由地访问外部类的成员变量，无论是否是private的 成员内部类 静态内部类 局部内部类 匿名内部类 本文主要内容转载于：Java 继承详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java入门（四）]]></title>
      <url>%2F2017%2F05%2F28%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
      <content type="text"><![CDATA[equals()与====比较的是两个值是否相等，这里的值分为两种情况： 基本类型的值，即float、double、byte、short、int、long、char、boolean这八种java的基本数据类型，这里比较的就是值本身，举个例子： 123int a=2;int b=2;System.out.printIn(a==b);//结果:true 而对于非基本数据类型（或者说引用类型）的变量，比较的就不是“值”本身，因为引用类型的变量存储的并不是“值”本身，而是预期关联对象在内存中的地址，举个例子： 123456789String str = new String("hello"); String str1 = new String("hello"); String str2 = new String("hello"); System.out.println(str1==str2);//结果为: false，因为str1和str2声明的是两个不同的对象，存储地址自然不同 str1 = str; str2 = str; System.out.println(str1==str2);//结果: true，因为此时str1和str2都指向了同一个对象，存储的地址相同了 equals()equals方法是基类Object中的方法，因此对于所有的继承于Object的类都会有该方法。equals比较的是两个对象的引用是否相等，即是否指向同一个对象，不过看下下面的代码： 1234567891011121314public class Main &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub String str1 = new String("hello"); String str2 = new String("hello"); System.out.println(str1.equals(str2)); &#125;&#125;//结果：true 之所以会变成这样是因为Java的equals方法在用来比较String、Double，Date，Integer等对象时，其内部对equals方法进行了重写（可以直接去看自己JDK的中String.java的源代码，确实是对equals方法进行了重写），使其用来比较指向对象所处的内容是否相等。 小结 对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等,如果作用于引用类型的变量，则比较的是所指向的对象的地址。 对于equals方法，注意：equals方法不能作用于基本数据类型的变量如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址，诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。 本节内容转载于:浅谈Java中的equals和== static、final和static finalfinal final类不能被继承，没有子类，final类中的方法默认是final的 在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会再被扩展，那么就设计为final类 final方法不能被子类的方法覆盖，但可以被继承 如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法 把方法锁定，防止任何继承类修改它的意义和实现 高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率 final成员变量表示常量，只能被赋值一次，赋值后值不再改变 final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量 final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征 final不能用于修饰构造方法 父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的 当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值 例子 1234567891011121314151617181920212223242526272829303132//关于用final修饰方法的情况public class Test1 &#123; public static void main(String[] args) &#123; // TODO 自动生成方法存根 &#125; public void f1() &#123; System.out.println("f1"); &#125; //无法被子类覆盖的方法 public final void f2() &#123; System.out.println("f2"); &#125; public void f3() &#123; System.out.println("f3"); &#125; private void f4() &#123; System.out.println("f4"); &#125; &#125; public class Test2 extends Test1 &#123; public void f1()&#123; System.out.println("Test1父类方法f1被覆盖!"); &#125; public static void main(String[] args) &#123; Test2 t=new Test2(); t.f1(); t.f2(); //调用从父类继承过来的final方法 t.f3(); //调用从父类继承过来的方法 //t.f4(); //调用失败，无法从父类继承获得 &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//关于final修饰成员变量的情况public class Test3 &#123; private final String S = "final实例变量S"; private final int A = 100; public final int B = 90; public static final int C = 80; private static final int D = 70; public final int E; //final空白,必须在初始化对象的时候赋初值 public Test3(int x) &#123; E = x; &#125; /** * @param args */ public static void main(String[] args) &#123; Test3 t = new Test3(2); //t.A=101; //出错,final变量的值一旦给定就无法改变 //t.B=91; //出错,final变量的值一旦给定就无法改变 //t.C=81; //出错,final变量的值一旦给定就无法改变 //t.D=71; //出错,final变量的值一旦给定就无法改变 System.out.println(t.A); System.out.println(t.B); System.out.println(t.C); //不推荐用对象方式访问静态字段 System.out.println(t.D); //不推荐用对象方式访问静态字段 System.out.println(Test3.C); System.out.println(Test3.D); //System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. System.out.println(t.E); Test3 t1 = new Test3(3); System.out.println(t1.E); //final空白变量E依据对象的不同而不同 &#125; private void test() &#123; System.out.println(new Test3(1).A); System.out.println(Test3.C); System.out.println(Test3.D); &#125; public void test2() &#123; final int a; //final空白,在需要的时候才赋值 final int b = 4; //局部常量--final用于局部变量的情形 final int c; //final空白,一直没有给赋值. a = 3; //a=4; 出错,已经给赋过值了. //b=2; 出错,已经给赋过值了. &#125; &#125; 1234567891011//关于final修饰函数参数的情况public class Test4 &#123; public static void main(String[] args) &#123; new Test4().f1(2); &#125; public void f1(final int i) &#123; //i++; //i是final类型的,值不允许改变的. System.out.print(i); &#125; &#125; static static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法 被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享 static对象可以在它的任何对象创建之前访问，无需引用任何对象 用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量 static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用，但是不能在其他类中通过类名来直接引用。原因是private是访问权限限定，static表示不要实例化就可以使用 static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问 用法为： 类名.静态方法名(参数列表…) 类名.静态变量名 static变量 静态变量或类变量 被static修饰的变量 在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的） 实例变量 没有被static修饰的变量 每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活） 静态方法 静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！ 因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract static代码块 也叫静态代码块 是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次 1234567891011121314151617181920212223242526272829303132333435363738//static代码块的例子public class Test5 &#123; private static int a; private int b; static &#123; Test5.a = 3; System.out.println(a); Test5 t = new Test5(); t.f(); t.b = 1000; System.out.println(t.b); &#125; static &#123; Test5.a = 4; System.out.println(a); &#125; public static void main(String[] args) &#123; // TODO 自动生成方法存根 &#125; static &#123; Test5.a = 5; System.out.println(a); &#125; public void f() &#123; System.out.println("hhahhahah"); &#125; &#125;//结果：//3//hhahhahah//1000//4//5 static final static final用来修饰成员变量和成员方法，可简单理解为“全局常量” 对于变量，表示一旦给值就不可修改，并且通过类名可以访问 对于方法，表示不可覆盖，并且可以通过类名直接访问 对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多 例子123456789101112131415161718192021222324252627282930313233343536373839public class TestStaticFinal &#123; private static final String strStaticFinalVar = "aaa"; private static String strStaticVar = null; private final String strFinalVar = null; private static final int intStaticFinalVar = 0; private static final Integer integerStaticFinalVar = new Integer(8); private static final ArrayList&lt;String&gt; alStaticFinalVar = new ArrayList&lt;String&gt;(); private void test() &#123; System.out.println("-------------值处理前----------\r\n"); System.out.println("strStaticFinalVar=" + strStaticFinalVar + "\r\n"); System.out.println("strStaticVar=" + strStaticVar + "\r\n"); System.out.println("strFinalVar=" + strFinalVar + "\r\n"); System.out.println("intStaticFinalVar=" + intStaticFinalVar + "\r\n"); System.out.println("integerStaticFinalVar=" + integerStaticFinalVar + "\r\n"); System.out.println("alStaticFinalVar=" + alStaticFinalVar + "\r\n"); //strStaticFinalVar="哈哈哈哈"; //错误，final表示终态,不可以改变变量本身. strStaticVar = "哈哈哈哈"; //正确，static表示类变量,值可以改变. //strFinalVar="呵呵呵呵"; //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 //intStaticFinalVar=2; //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 //integerStaticFinalVar=new Integer(8); //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 alStaticFinalVar.add("aaa"); //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 alStaticFinalVar.add("bbb"); //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 System.out.println("-------------值处理后----------\r\n"); System.out.println("strStaticFinalVar=" + strStaticFinalVar + "\r\n"); System.out.println("strStaticVar=" + strStaticVar + "\r\n"); System.out.println("strFinalVar=" + strFinalVar + "\r\n"); System.out.println("intStaticFinalVar=" + intStaticFinalVar + "\r\n"); System.out.println("integerStaticFinalVar=" + integerStaticFinalVar + "\r\n"); System.out.println("alStaticFinalVar=" + alStaticFinalVar + "\r\n"); &#125; public static void main(String args[]) &#123; new TestStaticFinal().test(); &#125; &#125; 运行结果如下： -------------值处理前---------- strStaticFinalVar=aaa strStaticVar=null strFinalVar=null intStaticFinalVar=0 integerStaticFinalVar=8 alStaticFinalVar=[] -------------值处理后---------- strStaticFinalVar=aaa strStaticVar=哈哈哈哈 strFinalVar=null intStaticFinalVar=0 integerStaticFinalVar=8 alStaticFinalVar=[aaa, bbb] Process finished with exit code 0 通过static final修饰的容器类型变量中所“装”的对象是可改变的。这是和一般基本类型和类类型变量差别很大的地方 本节内容转载于：Java关键字final、static使用总结 对象和对象句柄的区别12345678910class value&#123; int i;&#125;public class EqualsMethod&#123; public static void main(string[] args)&#123; value v1=new value(); value v2=new value(); vl.i=v2.i=100; &#125;&#125; 如以上代码： value v1和value v2声明了两个value类型的句柄 然后通过new操作符实例化了v1、v2这两个对象 注意：经过上面的操作，对象是确实已经被声明且实例化出来了，但是我们并不能直接的去操纵对象实例，你可能会问，v1和v2不就是对象了吗？不是的，v1和v2只是两个标识符，代表的是两个指向对象实例的句柄，我们通过句柄访问对象实例，使用v1.i时对v1执行的对象的i进行赋值就是这个道理。它们指向的对象我们实际上是看不到的。 举个比较贴近生活的浅显易懂的例子：就好比遥控器和电视的关系，电视是对象实例，而遥控器就是这个对象的句柄，我们通过遥控器来控制电视的音量或者换台等等，电视一直摆在那，我们直接控制不了（不要钻牛角尖），而遥控器我们可以随意拿来拿去，通过它来控制电视的相关内容。另外，遥控器可以独立于电视机而存在，即句柄可以被声明出来，只是没有连接对象而已，比如：String str;，这就是声明了一个还未连接任何对象的String类型的句柄。 这样解释应该就懂了，value v1和value v2是声明了两个value类型的变量（句柄），还没有与任何对象关联，new value()则真正的产生了一个value类型的对象，使用value v1=new value();是将句柄与对象进行了绑定操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux常用命令介绍]]></title>
      <url>%2F2017%2F05%2F14%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[Git Bash的一些命令是Linux的命令，虽然使用的是windows系统，但因为使用git bash，所以还是得了解一些常用的Linux命令操作 删除文件夹rm -rf 目录名 r表示向下递归不管多少级，一并删除；f表示直接强行删除，不说任何提示的意思 查看文件内容cat 文件名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[什么是wiki]]></title>
      <url>%2F2017%2F05%2F14%2F%E4%BB%80%E4%B9%88%E6%98%AFwiki%2F</url>
      <content type="text"><![CDATA[github如何使用wiki，github上每个仓库偶有自己的wiki，用github自己的帮助文档中的话来说就是： 每个GitHub存储库都配备了一个托管文档的部分，称为wiki。GitHub Wiki是您的存储库中的一个地方，您可以在其中分享关于您的项目的长形内容，例如如何使用它，如何设计，阐述其核心原则等。而README旨在使读者快速了解您的项目可以做什么，wiki可用于提供其他文档 简单介绍wiki它其实是一种新技术，一种超文本系统。这种超文本系统支持面向社群的协作式写作，同时也包括一组支持这种写作的辅助工具。也就是说，这是多人协作的写作工具。而参与创作的人，也被称为维客。 从技术角度看，Wiki是一种超文本系统，是任何人都可以编辑网页的社会性软件。Wiki包含一套能简易创造、改变HTML网页的系统，再加上一套纪录以及编目所有改变的系统，以提供还原改变的功能。利用Wiki系统构建的网站称为Wiki网站，称之为维基主页；“客”隐含人的意思，所以使用Wiki的用户称之为维客（Wikier）。 从使用者角度看，Wiki是一种多人协作的写作工具系统，属于一种人类知识的网络管理系统。Wiki站点可以有多人（甚至任何访问者）维护，每个人都可以发表自己的意见，或者对共同的主题进行扩展或者探讨。 在维客页面上，每个人都可浏览、创建、更改文本，系统可以对不同版本内容进行有效控制管理，所有的修改记录都保存下来，不但可事后查验，也能追踪、回复至本来面目。这也就意味着每个人都可以方便地对共同的主题进行写作、修改、扩展或者探讨。同一维客网站的写作者自然构成了一个社群，维客系统为这个社群提供简单的交流工具。 Wiki的特点 使用方便 维护快捷：快速创建、存取、更改超文本页面（这也是为什麼叫作 “wiki wiki” 的原因）。 格式简单：用简单的格式标记来取代 HTML 的复杂格式标记。（类似所见即所得的风格） 链接方便：通过简单标记，直接以关键字名来建立链接（页面、外部连接、图像等）。 命名平易：关键字名就是页面名称，并且被置於一个单层、平直的名空间中。 可增长：页面的链接目标可以尚未存在，通过点击链接，我们可以创建这些页面，从而使系统得以增长。 修订历史：记录页面的修订历史，页面的各个版本都可以被获取。 开放的：社群内的成员可以任意创建、修改、或删除页面。 可观察：系统内页面的变动可以被来访者清楚观察得到。 补充Wiki也指一种超文本系统，支持面向社群的协作式写作，也就是每个人都可以改这个网站的数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Wampserver3.0局域网访问设置方法]]></title>
      <url>%2F2017%2F05%2F14%2FWampserver3.0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在wampserver3.0上跑起来的站点怎么设置才能让局域网中的设备访问到，各个步骤网上都有教程，我就直接帖网址了 首先应该设置wampserver使其本身支持局域网访问,方法如下： WampServer3.0.4 允许外网访问配置教程。注意要将wampserver调成在线模式 这样下来，有的时候还是不能访问，那是因为你电脑的防火墙把你站点的端口的外部接入响应阻止了，最简单的方法是关掉防火墙，另外也可以设置防火墙开放你网站的端口号，方法如下： win7系统如何在防火墙里开放端口。win10设置方法也一样，大同小异。 设置完后，就可以通过局域网设备访问了，方法是在想连接的设备上搜索url：“http://电脑（服务器主机）的IP地址：端口号”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端行业的你需要哪些网站]]></title>
      <url>%2F2017%2F05%2F11%2F%E5%89%8D%E7%AB%AF%E8%A1%8C%E4%B8%9A%E7%9A%84%E4%BD%A0%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E7%BD%91%E7%AB%99%2F</url>
      <content type="text"><![CDATA[除了肯定会逛的掘金、CSDN、知乎等技术论坛。 技术社区Stackoverflow是一个与程序相关的IT技术问答网站。用户可以在网站免费提交问题，浏览问题，索引相关内容，在创建主页的时候使用简单的HTML。在问题页面，不会弹出任何广告，销售信息，JavaScript 窗口等。有这么一个说法：“作为一名程序员，如果没有听过 Stackoverflow，那么你最好去面壁思过一下。” Segmentfault是一家中文的开发者社区及媒体。最初的产品原型来自于国外最大的程序员问答社区 Stackoverflow，但其产品形态经过一年多的发展，已经有问答、博客、活动等，它还是多个黑客马拉松活动的组织方 提高开发效率teambition是一个简单,高效的项目协作工具,你可以在这里管理项目,跟踪任务进度,存储项目文件,让你的团队协作更高效 tower功能与teambition差不多 Travis CI自动测试系统,CI意思为持续集成，Travis可以将你github上的项目自动编译，有人提交即可执行编译让你第一时间知道提交是否OK Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。具体介绍看官方文档 社交类领英全球最大的职业社交网站，是一家面向商业客户的社交网络（SNS） Github全球最大的男性交友平台，毫无疑问，不需要解释 设计灵感UI中国前身为 iconfans,是专业的 UI 设计师交流、学习与展示的平台。会员均为职业 UI 设计师,覆盖全国互联网公司。 Behance著名设计社区，在上面，创意设计人士可以展示自己的作品，发现别人分享的创意作品（上面有许多质量上乘的设计作品），相互还可以进行互动（评论、关注、站内短信等） 乐乎国内优质图片社交平台]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysql数据库基本使用]]></title>
      <url>%2F2017%2F05%2F10%2FMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[太久没有用命令行操作Mysql,今天有个项目想用下都不知道怎么用了，都是些最近本的东西，把这些坑记下来吧。 记得本地的Mysql数据库服务（当然下面要将的第一条是要求不能启动，我说的是正常操作的情况下，的启动Mysql服务才行），启动方法是，win+R代开运行窗口之后输入services.msc，打开服务功能视图，找到MySQL那个选项，将它启动就可以了。 忘记登录密码怎么办直接看这里吧，挺好的一个教程 教程中是还要进到mysql安装目录的bin文件夹下，运行mysql.exe，这是没有添加系统环境变量的缘故，把bin文件夹的目录路径添加到环境变量的path中就行，具体过程就不多说了，自己百度。添加了之后，就能在cmd的任意地方输入mysql登陆命令直接登陆mysql而不用一定得在bin目录下才可以。 教程最后还讲了绕过用户认证登陆后进行更改密码的操作，这也不失为一种更改密码的方法，不过更改完后必须重新启动数据库服务才能生效，记住是services.msc里面的数据库服务，而不是简单地把cmd窗口打开再关掉。 注意，mysql数据库初始状态有个示例账户，是不需要账户名和密码就能登陆的，但是数据库却只有示例的数据库，并不是真正的账户里面的数据库信息。所以不要在命令行输入mysql后出现mysql欢迎信息就以为自己已经成功登陆了，其实只是个让你来看看mysql示例数据库的账号而已。虽然也可以用，但是还是自己的账号好，毕竟自己的账号有用户名和密码，你用个没名没分的账号来操作数据库心里也难免有种不安全感。 怎么登陆在命令窗口输入：mysql -u用户名 -p密码 这样就能登陆了，在此之前记得像最开始说的先启动mysql服务，另外注意-u和用户名之间没有空格，-p和密码之间也没有空格 查看mysql版本方法一命令窗口下：mysql –version 方法二登录mysql后输入：status;或者输入：select version(); 查看端口号登录mysql后输入：show global variables like ‘port’; 基本命令查看当前用户下的数据库show databases; 选中某个数据库（决定对某个数据库进行操作）use 数据库名; 查看数据库中都有什么表show tables;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github团队协作基础教程]]></title>
      <url>%2F2017%2F05%2F08%2FGithub%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[创建组织既然是团队项目，说明该项目是属于某个组织的，应该先建立一个组织，如下图： 进入组织的创建页面，填好组织名称和接收的消息的邮箱，这里我们将组织名称命名为TestWebTeam，选免费的方案，如果是真正的公司，则就会付费去创建一个组织，因为有些内容不能公开。点击create organization即完成组织的创建。（注意组织名称不能重复，接收邮箱必须添加） 点击创建后会进入成员邀请页 ，我们先直接点击finish跳过，只有再进行邀请。 这样组织就创建完成了。 创建小组组织就是现实意义上的组织，一个组织内部可以有很多个小组，他们之间可以共享一些仓库，拥有对不同仓库不同的控制权限，我们下面来创建一个小组，比如说这小组叫Designer，即设计小组。点击team,r然后点击create new team 进入小组创建页，填写小组名称Team name和小组描述Description,Team visibility是用户显示的内容，英语都看得懂就不说了，默认选第一个。然后点击create创建。 这就小组创建成功了，可以通过addmember来搜索github用户添加组员 创建和配置代码仓库权限组织有了，组织内部的开发小组也有了，需要的就是代码仓库了，一个组织可以有多个代码仓库，下面先创建一个，组织主页，点击创建新的仓库。（另外也可以像建个人仓库一样点击右上角的加号创建仓库，只是到时候将所属对象从个人改成目的组织就行了） 跟创建个人仓库没什么区别，只是owner变了，仓库名字命名为TestRepository 创建成功，点击setting给这个仓库指定哪些小组可以使用，并规定访问权限 中途会让你输入用户密码，输入就是了。然后左边选择Collaborators&amp;team、右边选择team，选择select team添加可以操作该仓库的小组。 添加完后，可以编辑该小组使用该仓库时的权限，三个权限，既然是想让小组来用这个代码仓库，则选择write即可，admin权限将使所有小组成员变成该项目管理员，可以随意编辑该仓库的设置，慎重选择。 下面的collaborators是添加该仓库的个人协作者（区别于小组），可自行扩展 为小组创建Pull Request组织通过Pull Request进行代码检查，当你对代码进行更改时可以邀请你的小组审核你的更改并提供反馈。下面来创建一个小的Pull Request，主要是对我们之前创建的代码仓库TestRepository的README文件进行更改。 移到最下面，添加主要提交的描述以及选择创建一个新的分支，因为我们要使用pull request，如果选第一个选项就直接合并到主分支去了 点击propose file change,进入open a pull prequest界面，这个页面是让你来更加详细的描述这次更改的原因，以及更改了什么地方，另外还可以用“@”来通知全体组员（就像QQ的@全体成员），让他们知道你的这次pull request 然后点击create pull request,这样小组的所有成员就都将知道你创建了一个pull request Pull Request的作用鉴于有些人可能不大清楚Pull Request的作用，下面来讲一下。 要打开一个pull request必须先拥有一个带有更改的分支，所以pull request适合团队工作，因为个人的话一般会一直工作在主分支上。 Pull Request用于提出对项目的更改，是一个开始提交讨论的方式，经常用于代码审查当中，如果是 一个人工作，则可能用Pull Request比较少，因为个人可以通过git命令推送更改到主分支中，并不 存在其他的分支，但如果在公司项目或者开源项目这种团队工作的情况下，就必须使用Pull Request了。 Pull Request是在开发者在创建一个区别于master的分支并进行相应的更改之后，想仓库管理者提出的将自己的分支（即更改内容）合并到主分支的一个请求，发出的这个请求可以被可访问这个仓库的所有人看见，并进行讨论，看是否合并、更改是否合理等等。即Pull Request用于对正在更改的代码仓库的讨论。 拿上面创建的pull request为例： 有三个视图，conversation视图用来讨论这次的更改 commit 提交视图包含了有关谁对这个文件进行更改的信息，每个提交都被记录到这个视图中，让我们知道提交前后发生了什么变化 files changed 文件更改视图，用来查看文件的更改记录。绿色表示已经添加的内容，红色表示内容被删除 那如何合并分支，对于公司，一般会有人来签署更改，但如果是个人在自己仓库的操作，则自己就可以进行合并操作，在coversation视图点击merge pull request就可以将这个提交合并到主分支了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现console.log不换行输出的方法]]></title>
      <url>%2F2017%2F05%2F06%2F%E5%AE%9E%E7%8E%B0console-log%E4%B8%8D%E6%8D%A2%E8%A1%8C%E8%BE%93%E5%87%BA%2F</url>
      <content type="text"><![CDATA[有点标题党的感觉，因为console.log()是无法实现不换行输出的，每执行一次console.log()都会自动占据一行。不过我们可以改变我们的输出思路。 用数组以及其方法：toString(),join(),reverse()来解决。 例子： 1234for(var i=0;i&lt;3;i++)&#123; console.log(i);&#125; 结果将是： 0 1 2 但我们想在一行内输出：0,1,2或者0–&gt;1–&gt;2或者2,1,0该怎么办？相信看来最开始我说的用数组及其方法的应该已经想到了。 先用一个数组把想输出的内容存储下来，之后再用相关的数组方法将其打印就可以了。 例子： 12345678910var A=[],k=0;for(var i=0;i&lt;3;i++)&#123; A[k]=i; k++;&#125;console.log(A.toString());console.log(A.reverse().join('--&gt;')); 很明显，结果将是： 0,1,2 2–&gt;1–&gt;0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js实现简单排序算法]]></title>
      <url>%2F2017%2F04%2F29%2FJs%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[这里用JavaScript实现冒泡排序、选择排序、插入排序、归并排序以及快速排序这些基本的排序算法 首先我们给本文约定一个实现的框架：定义一个ArrayList类里面包含排序数组声明、数组元素添加、排序算法实现以及数组输出的方法。 代码框架： 123456789101112131415161718192021222324function ArrayList()&#123; var array=[]; this.inputArraymember=function()&#123; //将10个大小在1~15的随机数添加到数组中 var ins=0; for(var i=0;i&lt;10;i++)&#123; ins=Math.floor(Math.random()*15+1); array.push(ins); &#125; &#125;; this.相应的排序算法=function()&#123;...算法的具体实现代码...&#125;; //代码块替换部分 this.toString=function(separator)&#123; //将数组按指定分隔符生成字符串方便输出 return array.join(separator); &#125;;&#125;var a = new ArrayList();a.inputArraymember();console.log("随机生成的原始数组为："+a.toString('-'));a.bubbleSort();console.log("排序后数组为："+a.toString('-')); 冒泡排序用两层循环，第一层用来记录剩余的还未排序的数的个数，第二层用来在剩下的未排序的数中找到最大的数并将其放到未排序数的最后面（冒泡）。 代码实现： 12345678910this.bubbleSort=function()&#123; var length=array.length; for(var i=0;i&lt;length;i++)&#123; for(var j=0;j&lt;length-1-i;j++)&#123; if(array[j]&gt;array[j+1])&#123; var t=array[j]; array[j]=array[j+1];array[j+1]=t; &#125; &#125; &#125;&#125;; 冒泡排序的时间复杂度是O(n&sup2;)。将以上代码替换文章开始约定的代码框架中的“代码块替换部分”即可用于在调试工具中运行查看代码运行结果。 选择排序思路很简单，每次都找出未排序的数当中最小的数并放在开头，直到所有数的位置确定下来。说清楚点就是从所有序列中先找到最小的，然后放到第一个位置。之后再看剩余元素中最小的，放到第二个位置……以此类推。 代码实现： 1234567891011121314151617this.selectsort=function()&#123; var length=array.length,currentMin; for(var i=0;i&lt;length-1;i++)&#123; //每循环一趟就会有一个数得到排序 currentMin=i; //用来记录最小数的下标，默认为最开始的未排序的元素下标 for(var j=i;j&lt;length;j++)&#123; if(array[currentMin]&gt;array[j])&#123; currentMin=j; &#125; &#125; if(i!==currentMin)&#123; //若下标不是未排序的最开始的那个元素的下标，则将两者的值交换 var t=array[currentMin]; array[currentMin]=array[i]; array[i]=t; &#125; &#125;&#125;; 可看出，选择排序也用了两个嵌套着的循环，所以时间复杂度也是O(n&sup2;)，是一种原址排序。 插入排序从第二个数开始（因为第一个数只有一个，前面没得比。），与前面的数挨个比较，直到找到前一个数比当前值小，后一个数比当前值大的位置，让后将当前值置于此处，以此类推。 代码实现： 12345678910111213this.insertsort=function()&#123; var length=array.length, j,temp; for(var i=1;i&lt;length;i++)&#123; j=i; temp=array[i]; //先存储待比较的数 while(j&gt;0&amp;&amp;array[j-1]&gt;temp)&#123; //如果这个数比上一个数小，则让上一个数占据现在这个数的位置（右移每个比当前数小的数） array[j]=array[j-1]; j-- &#125; array[j]=temp; //直到这个数不比上一个数小的时候，将这个数放在当前的位置 &#125;&#125;; 归并排序时间复杂度为O(nlogn)。归并用的是分治的思想，将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着讲小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142 this.mergeSort=function() &#123; array = mergeSortRec(array); &#125;;//建堆函数，将数组一直拆分成两部分，直到各部分数组长度都为1的时候停止，然后进行merge操作 var mergeSortRec = function(array)&#123; var length = array.length; if (length === 1) &#123; return array; &#125; var mid = Math.floor(length / 2), left = array.slice(0, mid),//slice() 方法可从已有的数组中返回选定的元素,语法 arrayObject.slice(start,end) right = array.slice(mid, length); return merge(mergeSortRec(left), mergeSortRec(right)); &#125;;//将各部分进行归并 var merge = function(left, right) &#123; var result = [], il = 0, ir = 0; while(il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; if (left[il] &lt; right[ir]) &#123; result.push(left[il++]); &#125; else &#123; result.push(right[ir++]); &#125; &#125; //如果il数组还有剩余，则将其剩余部分添加到结果数组中 while (il &lt; left.length) &#123; result.push(left[il++]); &#125; //如果ir数组还有剩余，则将其剩余部分添加到结果数组中 while (ir &lt; right.length) &#123; result.push(right[ir++]); &#125; return result; &#125;; 快速排序时间复杂度为O(logn)。用的是分治的思想。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 this.quickSort = function()&#123; quick(array, 0, array.length - 1); &#125;; var partition = function(array, left, right) &#123; //划分过程//主元的选择方法最好是随机选择一个数组想或是选择中间项，这里选择中间项 var pivot = array[Math.floor((right + left) / 2)], i = left, j = right; console.log('pivot is ' + pivot + '; left is ' + left + '; right is ' + right); while (i &lt;= j) &#123; while (array[i] &lt; pivot) &#123; i++; console.log('i = ' + i); &#125; while (array[j] &gt; pivot) &#123; j--; console.log('j = ' + j); &#125; if (i &lt;= j) &#123; console.log('swap ' + array[i] + ' with ' + array[j]); swapQuickStort(array, i, j); i++; j--; &#125; &#125; return i; &#125;; var swapQuickStort = function(array, index1, index2)&#123; var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux; &#125;; var quick = function(array, left, right)&#123;//将子数组分离为较小值数组和较大值数组 var index; if (array.length &gt; 1) &#123; index = partition(array, left, right); if (left &lt; index - 1) &#123; quick(array, left, index - 1); &#125; if (index &lt; right) &#123; quick(array, index, right); &#125; &#125; return array; &#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript数组介绍]]></title>
      <url>%2F2017%2F04%2F27%2FJavaScript%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[JavaScript的数组中的元素可以具有不同的类型，即var a=[&#39;hello&#39;,12,&#39;kk&#39;];是合法的。 对于一维数组，可直接用console.log(数组名)来输出数组内容，若是多维数组则需要自行构建函数来输出 创建和初始化数组123456var everyday=new Array();var everyday=new Array();var everyday=new Array('hello','world',123,'china');var evaryday=[];var evaryday=['hello','world',123,'china']; 可使用everyday.length来获得数组的长度 添加和删除数组元素添加到数组末尾123everyday[everyday.length]='新元素';或everyday.push('新元素1','新元素2'); 添加到数组首部1eveday.unshit('新元素1','新元素2'); 删除最靠后元素1everyday.pop(); 用push()和pop()可以用数组来模拟栈 删除第一个元素1everyday.shift(); 用shift()和unshift()可以用数组模拟队列 删除任意位置的元素1everyday.splice(2,3); 注解：表示删除了从下标2的元素开始往后的两个元素（包括下标为2的），即everyday[2]、everyday[3]、everyday[4]。 插入任意为位置 任意值1everyday.splice(2,0,5,3,6) 注释：这才是splice()函数的完整用法。第一个参数是要执行删除操作的开始下标，第二个是要删除的个数，咱现在目的是为了添加，所以写0，第三个参数及以后则是要新添加的元素，此例执行后everyday[2]值变成5，以此类推。 二维和多维数组JavaScript只支持一维数组，但由于JavaScript数组对元素类型的宽容性，我们可以采用数组套数组的方法来实现多维数组。 12345678var a1=[];a1[0]=['hello',23,'world'];a1[2]=['china','england'];或var a2=[];a2[0]=[];a2[0][0]='hello';a2[0][1]='woeld'; 此时用console.log(a2)将不能输出数组内容，因为console.log()之只能用来输出具体的元素，应该自行创建一个函数来简化输出 123456789function printfMatrix(myMatrix)&#123;for(var i=0;i&lt;myMatrix.length;i++)&#123; for(var j=0;j&lt;myMatrix[i].length;j++)&#123; console.log(myMatrix[i][j]); &#125; &#125;&#125;printfMatrix(数组名); 操作数组的方法（函数）数组合并–concat方法 按照指定的顺序连接起来，很好理解 迭代器函数every方法every会迭代数组中的每一个元素，直到返回false 注释：给每个元素迭代执行zhengshu这个方法（是小于0则继续迭代，直到遇到正数，返回false） some方法every会迭代数组中的每一个元素，直到返回true 注释：给每个元素迭代执行zhengshu这个方法（是大于0则继续迭代，直达遇到负数，返回true） forEach方法foreach会迭代整个数组的元素 map方法map会生成一个数组，用来保存迭代所有元素时产生的结果 filter方法filter会生成一个新数组，用来保存迭代所有元素时时函数返回true的元素 reduce方法reduce接收一个函数作为参数，这个函数有四个参数：prevousValue、currentValue、index和array。这个函数会返回一个将被叠加到累加器的值，reduce方法停止执行后返回这个累加器。如果要对一个数组中的所有元素求和，这就很有用。 搜索和排序数组反序–reverse方法就是将原本数组元素的排列顺序颠倒 数组自动排序–sort方法sort在排序的时候，是默认把元素当成字符串来比较。比如底下这样用就会出错： 那应该怎么办？ 自己写比较函数 123var a=[2,6,18,19,1];console.log(a.sort(function(a,b)&#123;return a-b;&#125;)); 主要的是代码a.sort(function(a,b){return a-b;})，此代码表示当a小于b时返回负数，当a大于b时返回正数，相等时放回0，这样sort方法就会根据返回值的情况给数组排序，当然这行代码额可以改写成比较好理解的以下以下代码： 注意比较函数的调用方法（没有传参） 自定义排序可以创建任何对象类型的数组排序，也可以创建compareFunction来比较元素： 12345678910111213var person=[&#123;name:'小明',age:15&#125;,&#123;name:'小王',age:14&#125;,&#123;name:'小东',age:18&#125;];function comparePerson(a,b)&#123; if(a.age&lt;b.age)&#123; return -1; &#125; if(a.age&gt;b.age)&#123; return 1; &#125; return 0;&#125;console.log(person.sort(comparePerson)); 结果: 字符串排序对于字符创的比较，sort是根据ASCII值来比较的，比如： 即Jmn会排在apple的前面，如果我们想让它排序正确，则需要自己写一个忽略大小写的比较函数： 搜索 indexOf()方法：返回与参数匹配的第一个元素的索引 lastIndexOf()方法：返回与参数匹配的最后一个元素的索引。 例子： 结果分析，前两个没什么好说的，第三个查找10，因为没有这个元素，所以返回-1 输出数组为字符串及指定分隔符 toString()将数组里的所有元素输出为一个字符串 join()用一个不同的分隔符把元素隔开 例子：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 Canvas入门]]></title>
      <url>%2F2017%2F04%2F26%2FHTML5-Canvas%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Canvas元素本身没有绘图能力，所有的绘图工作必须在JavaScript内部完成。拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 直接上代码。 绘制2d线条 先在html页面下添加Canvas元素。设定画布的id和宽高。 1&lt;canvas id="myCanvas" width="200" height="100" style="border:1px solid #000;"&gt;&lt;/canvas&gt; 用JavaScript在画布上面绘制图像 123456789 // 获得画布 var c=document.getElementById("huabu"); // 创建基于所获得画布的2d画笔 var pan= c.getContext("2d"); pan.moveTo(10,10);//移动画笔 pan.lineTo(40,40);//从源点绘制到指定点（30,40）pan.lineTo(50,100);//从源点绘制到指定点（50,100） pan.lineTo(150,20); pan.stroke();//之前是在构建，这里是把构思正式画到画布上，一定要这一步 结果 注意 如果想绘制两条线，不能想当然的moveTo(),然后再lineTo()，应该再声明一支画笔 12345var pan2= c.getContext("2d"); pan2.moveTo(40,10);pan2.lineTo(30,60); pan2.lineTo(188,170); pan2.stroke(); 结果：（绘制两条线） 绘制圆形 先在html页面下添加Canvas元素。设定画布的id和宽高。 1&lt;canvas id="myCanvas" width="200" height="100" style="border:1px solid #000;"&gt;&lt;/canvas&gt; 用JavaScript在画布上面绘制图像 12345678910111213 //获得画布var c=document.getElementById("huabu");var pan= c.getContext("2d");//设置图形填充的颜色pan.fillStyle='#00f';//开始绘制图形pan.beginPath();//arc是圆的英文前几个字母//括号内指定（圆心x轴坐标、圆心y轴坐标、圆半径、开始角度、结束角度、顺时针(false)还是逆时针(true)）pan.arc(100,100,50,0,Math.PI/2,true);//结束绘图pan.closePath();pan.fill();//一定要有，将构建好的图形正式填充到画布上去 学习以下代码 获得2d画笔后，用beginPath()方法绘制新路径 用strokeStyle指定路径颜色 arc()设置圆的属性 stroke()绘制弧线 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;HTML5 Canvas绘制弧线入门示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 添加canvas标签，并加上红色边框以便于在页面上查看 --&gt;&lt;canvas id="myCanvas" width="400px" height="300px" style="border: 1px solid red;"&gt;您的浏览器不支持canvas标签。&lt;/canvas&gt;&lt;script type="text/javascript"&gt;//获取Canvas对象(画布)var canvas = document.getElementById("myCanvas");//简单地检测当前浏览器是否支持Canvas对象，以免在一些不支持html5的浏览器中提示语法错误if(canvas.getContext)&#123; //获取对应的CanvasRenderingContext2D对象(画笔) var ctx = canvas.getContext("2d"); //开始一个新的绘制路径 ctx.beginPath(); //设置弧线的颜色为蓝色 ctx.strokeStyle = "blue"; var circle = &#123; x : 100, //圆心的x轴坐标值 y : 100, //圆心的y轴坐标值 r : 50 //圆的半径 &#125;; //沿着坐标点(100,100)为圆心、半径为50px的圆的顺时针方向绘制弧线 ctx.arc(circle.x, circle.y, circle.r, 0, Math.PI / 2, false); //按照指定的路径绘制弧线 ctx.stroke();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 给画布添加图像1234567891011&lt;script type="text/javascript"&gt;var c=document.getElementById("myCanvas");var cxt=c.getContext("2d");var img=new Image()img.src="image.png"//drawImage(图像元素，左上角顶点x轴坐标，左上角顶点y轴坐标)cxt.drawImage(img,0,0);&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS动画入门]]></title>
      <url>%2F2017%2F04%2F26%2FCSS%E5%8A%A8%E7%94%BB%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[css3常用动画+动画库 transitionCSS过渡 介绍俗称“过渡”，是指某元素从一种样式逐渐转变为另一种样式的过程。即用于转换元素两个不同的状态，这个转换过程（或者说触发过程）可以是伪类比如:hover, :active 或者是通过 javascript 动态设定。IE10+支持 transitionz是简写，主要包含的是一下属性。 用法必须规定了两个属性 要添加过渡效果的属性 效果转换的持续时间 多个属性转换用逗号隔开 例子12345678910111213141516171819&lt;!--HTML--&gt; &lt;div id="zi"&gt;&lt;/div&gt;&lt;!--CSS--&gt;#zi&#123; height:100px; width: 100px; background-color: yellow; transition: width 2s,height 2s,color 2s;&lt;!--不同属性效果用逗号隔开--&gt; -webkit-transition: width 2s,height 2s,background-color 2s;-o-transition: width 2s,height 2s,background-color 2s; -moz-transition: width 2s,height 2s,background-color 2s;&#125;#zi:hover&#123; background-color: red; height: 150px; width: 200px;&#125; animationCSS动画 介绍animation属性结合@keyframes规则,能创建由当前样式逐渐改为新样式的动画效果。Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。 用法@keyframes创建动画并制定动画的名字（随便起，主要是用来给animation选择），animation中选择相应的动画名字来使用对应的动画，还要设置动画执行的持续时间，还可设置所选动画的执行方式。即： @keyframes 用于创建动画 用法： 规定动画名，内容为from某种样式to某种样式，还要设置不同浏览器的前缀。也可以不用from-to而是直接用百分比来划分时间，进而规定特定时间内的动画样式。 “from” 和 “to”，等同于 0% 和 100%，0% 是动画的开始，100% 是动画的完成 例1： 例2： animation 用于选择动画并规定动画的执行方式 用法： 必须固定的有动画名称和动画时长 另外还可以添加其他规定项： 例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:100px;height:100px;background:red;position:relative;animation-name:myfirst;animation-duration:5s;animation-timing-function:linear;/*表示变换速度，linear表示从头到尾匀速*/animation-delay:2s;animation-iteration-count:infinite;/*表示动画无限次循环，可改为常数来规定执行次数*/animation-direction:alternate;animation-play-state:running;/* Firefox: */-moz-animation-name:myfirst;-moz-animation-duration:5s;-moz-animation-timing-function:linear;-moz-animation-delay:2s;-moz-animation-iteration-count:infinite;-moz-animation-direction:alternate;-moz-animation-play-state:running;/* Safari and Chrome: */-webkit-animation-name:myfirst;-webkit-animation-duration:5s;-webkit-animation-timing-function:linear;-webkit-animation-delay:2s;-webkit-animation-iteration-count:infinite;-webkit-animation-direction:alternate;-webkit-animation-play-state:running;/* Opera: */-o-animation-name:myfirst;-o-animation-duration:5s;-o-animation-timing-function:linear;-o-animation-delay:2s;-o-animation-iteration-count:infinite;-o-animation-direction:alternate;-o-animation-play-state:running;&#125;@keyframes myfirst&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123;0% &#123;background:red; left:0px; top:0px;&#125;25% &#123;background:yellow; left:200px; top:0px;&#125;50% &#123;background:blue; left:200px; top:200px;&#125;75% &#123;background:green; left:0px; top:200px;&#125;100% &#123;background:red; left:0px; top:0px;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 也可以将animation简写成： animation：动画名称 持续时间 执行速度变化 动画延迟 循环次数 是否下一周期逆向播放 div { width:100px; height:100px; background:red; position:relative; animation:myfirst 5s linear 2s infinite alternate; /* Firefox: */ -moz-animation:myfirst 5s linear 2s infinite alternate; /* Safari and Chrome: */ -webkit-animation:myfirst 5s linear 2s infinite alternate; /* Opera: */ -o-animation:myfirst 5s linear 2s infinite alternate; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Powershell基本命令]]></title>
      <url>%2F2017%2F04%2F26%2FPowershell%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[Powershell是微软在cmd基础上改进后推出的励志于提高用户开发体验的命令行程序，可以这么说，cmd有的Powershell全都有，Powershell有的cmd不全有，而且Powershell还比cmd漂亮，为什么不用呢。稍微讲下Powershell的基本命令。 Powershell用的时候会出现中文乱码，用以下命令把Encoding改成UTF8即可：$OutputEncoding = New-Object -typename System.Text.UTF8Encoding 注意命令中的空格,。以下命令均默认在要进行操作的文件夹下进行，如果不是在要操作的文件目录下，请自行在操作项目前添加文件路径。 创建文件夹mkdir Folder 创建文件dir &gt; a.txt 向文件内写入内容echo 内容 &gt; a.txt 这种方法会覆盖掉文件原有内容，如果是追加，应用： echo 内容 &gt;&gt; c.txt 这种方法，每次写入内容后面都会自动换行 图形化编辑txt文件notepad a.txt 这会直接以记事本的形式打开指定的文件 读取文件内容cat a.txt 此命令只能在操作当前目录的文件时可用 type a.txt 此命令可跨目录使用，即可添加路径 打开doc文件路径没错的情况下，直接输入文件名，然后回车，即可用相应的软件将其打开 指定用某软件打开某文件 将要使用的软件的exe文件所在的目录添加到系统环境变量里面 之后就可以用该软件打开想要打开的文件了 软件名或软件名.exe 文件名.文件后缀 删除文件del a.txt 删除文件夹del 文件夹 重命名文件ren a.txt b.txt 将文件a,txt重命名为b.txt 重命名文件夹ren 文件夹名1 文件夹名2 将文件夹名1改为文件夹名2 复制文件copy b.txt 文件夹1 将当前文件夹下的b.txt文件拷贝到当前文件夹下的文件夹1里面，其他操作可自行添加路径解决。 复制文件夹和剪切操作之后再做补充查看文件夹的目录结构 tree 可以查看当前目录及以下各级的目录结构，但是查看不了文件 tree /f可以查看对当前目录及以下各级的目录结构以及相应的文件 tree /f &gt;123.txt将查询到的文件目录结构保存在123.txt（新建）文件中 关闭某个软件 taskkill /im 软件名.exe 先输入tasklist 获取改进程的PID，假设PID号为3502， 再输入 taskkill /f /pid 3502 从命令行模式打开文件夹窗口start 文件夹的绝对路径]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js相等操作符]]></title>
      <url>%2F2017%2F04%2F25%2FJs%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[对于有其他编程语言编程经验的人来说，在判断两个值是否相等时，会用“==”，但是此方法用于Js，特别是用Webstorm等前端IDE编写Js程序时，会发现此方法会报错，并提示应该更改为“===”，这到底是怎么回事，下面我们就来区别一下Js这两个相等操作符——“==”和“===” 总的一句：==不管类型相不相同，只要进行转化后条件符合（具体怎么转化请往下看），就会判定为相等；===必须比较的两个值类型和值相等时才相等，即===要比==严格。 “===”先说简单的，===。 用于比较的两个值，类型不相等则不相等，类型相等且值相等，则相等。 例子例一： 12console.log('test'===true); //结果为：false，以为类型不相等，一个字符串一个布尔值console.log('test'==='test'); //结果为：true，因为类型相等且值相等 值得注意的一点是，关于对象，就算是分别定义的两个对象的内容一样，用’===’进行比较也是不相等的，因为存储的位置不同，除非是用引用的方式将一个对象的值赋给另一个对象，这才返回true。（什么是对象的引用可以看这篇文章：对象引用问题上Java和Js是相通的–Java入门） 例二： 123456789var person1=&#123;a:'xiao'&#125;;var person2=&#123;a:'xiao'&#125;;console.log(person1===person2);//结果为：false，因为person1和person2的存储位置不一样，所以是不同的对象var person1=&#123;a:'xiao'&#125;;var person2=person1;console.log(person1===person2);//结果为：true，因为person2是对person1的引用，它们指向的是用一个内存块，所以相等 “==”使用==时，不同类型的值也可以被看做相等，不过Js会对其进行一定的转化后再惊醒比较，下面来看看如果对不同类型的值使用“==”进行比较，Js会进行怎样的转化： 若x和y类型相同，Js会比较它们的值或者对向值。如果不同，则按上面的形式进行转化后再比较。其他没有列在表格中的情况都会返回false。 toNumber和toPrimitive的转化结果toNumber toPrimitive 例子例一： 1console.log('test'?true:false);//结果为:true 原因：这里是判断test字符串变成布尔值后是什么，因为字符串的长度大于一。这里涉及到Js中true和false的问题，稍微说下Js中true和false是怎么转换的： 例二： 1console.log('test'==true); //结果为：false 原因：进行比较的时候，布尔值true被toNumber变成数字1；而字符串test则被toNumber转换成NaN，进而表达式转换成判断NaN==1，结果自然为false。 例三： 1console.log('test'==false); //结果为：false 原因：同例二一样的道理，结果表达式被转换成判断NaN==0,结果仍然为false。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[远方]]></title>
      <url>%2F2017%2F04%2F23%2F%E8%BF%9C%E6%96%B9%2F</url>
      <content type="text"><![CDATA[“当你发现日子特别艰难的时候 可能这次的收获特别巨大”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github Pages托管静态页面]]></title>
      <url>%2F2017%2F04%2F22%2FGithub-Pages%E6%89%98%E7%AE%A1%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[什么是 Github Pages？ Github Pages 是 Github 的静态页面托管服务。它设计的初衷是为了用户能够直接通过 Github仓库来托管用户个人、组织或是项目的专属页面。 我们可以利用 Github 的静态页面托管服务 Github Pages 来帮助我们做页面展示。见得最多的就是把它拿来托管自己的博客，当然博客是静态的，不过，不止博客，我们github账户上的所有仓库只要把Github Pages的功能代开，就都能拥有自己的展示主页。 托管博客github提供的博客托管仓库只有一个，那就是username.github.io，下面说一下具体怎么弄： 创建一个名为username.github.io的仓库，其中username是你的github用户名，其他的默认即可 进入username.github.io这个仓库，点击setting选项进行设置 本地git关联和上传到这个仓库的步骤我就不说了，也就是git init、git add、git commit、git remote add origin https://仓库地址、git push origin master这些基本步骤，相信能来看这个的对git的基本操作都已经掌握了。 进入到setting里面，左边学则Options这一栏,右边滑到GitHub Pages那一栏，将Source的Node改成你放博客文件的分支名字，一般是直接用master分支，然后Save Theme chooser那一个选项是给你的这个主页设置显示的主题的，咱们是自己创建的博客不需要它的东西，直接跳过就行了 此时访问在浏览器搜索框输入username.github.io其实已经可以访问，只是会提示404，因为咱们没有放页面 此时只要上传本地的博客文件到这个仓库就可以了 注意：博客的首页必须命名为index.html且放在这个仓库的最外面，不能放在某某文件夹里面，不然访问username.github.io还是会找不到页面 上面的工作都做完后，就能通过输入username.github.io(记住，这里提到的username都得改成自己的用户名)访问自己托管的静态博客了 如果不喜欢github提供的这个username.github.io域名怎么办，也可以绑定到自己注册的域名，详情请看我的这篇博客：挂载Hexo主题的Github绑定自己的域名,博主用的是Hexo的Next主题，不过不影响，操作都差不多 到服务商购买域名 username.github.io仓库添加最外面添加一个CNAME文件，里面写上自己购买的域名 解析购买的域名到github的域名和IP地址，等待一会儿就能通过自己的域名访问了 生成项目的展示主页这才是Github Pages这功能开放的真正目的，为的是让托管在github上的仓库都能有直接进行展示的机会 步骤跟托管博客的步骤一样，随便一个仓库，Setting-&gt;Options-&gt;GitHub Pages-&gt;Source-&gt;分支名这样就成功了，通过http://博客域名/仓库名，就可也访问了，同样该仓库需要一个放在最外面的index.html页面来做首页 Github Pages的限制好东西还是有限制的： 仓库存储的所有文件不能超过 1 GB 页面的带宽限制是低于每月 100 GB 或是每月 100,000 次请求。 每小时最多只能部署 10 个静态网站。不够对于托管个博客应该是绰绰有余了，如果真的不小心超了，Github 那边不会采取什么强制措施，而是会发一份邮件提醒你应该找一个更适合你的托管对象的服务。 至于仓库的存储的文件大小限度是各个仓库的总和还是自己有自己的1GB，这我没研究过，毕竟Github还没给我发过提醒邮件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[“百花齐放”的前端时代]]></title>
      <url>%2F2017%2F04%2F21%2F%E2%80%9C%E7%99%BE%E8%8A%B1%E9%BD%90%E6%94%BE%E2%80%9D%E7%9A%84%E5%89%8D%E7%AB%AF%E6%97%B6%E4%BB%A3%2F</url>
      <content type="text"><![CDATA[笼统的前端 现在前端领域各种框架、库并行，新技术层出不穷，暂且称它为“繁荣”吧。 对一个刚刚走进这个江湖的菜鸟来说，jQuery、Angular、React、Vue、Bootstrap、Node这些经常在各大公司招聘要求以及各大前端论坛信息中的看到词到底是什么，有什么作用，一会儿框架，一会儿库的，还有MVC、MVVM以及npm、gulp、webpack等，就像各大帮派一样，搞得人一头雾水。 链接 我眼中的前端框架jQuery，Angular，React，Vue——以及我看前端架构 浅析angular，react，vue.js，jQuery使用区别 Gulp和webpack的区别，是一种工具吗？ nodejs+gulp+webpack基础实战篇 各路英雄的见解关于框架 前端框架天下三分：Angular、React 和 Vue 按照时代出场顺序排序：jQuery、Angular、React、Vue jQuery肯定要学的，Angular、React 和 Vue三个先学一个，三个都是比较类似的 React，Angular,Vue三个也是没有关联相互独立的框架。使用这三个框架搭建的网站主要特点就是动态刷新，路由控制不通过后端，全是JS完成，每次跳转页面都是动态替换index.html页面root节点的内容 Angular、React、Vue是Js框架，本身都是用js原生写的，就是别人把一些js的代码封装了，你调用之后就能用别人写好的方法，会方便很多，也被局限在别人的框架内部了 Bootstrap是UI框架 vue是国人弄出来的，官方文档都是中文，学起来比较不麻烦 分清楚 库，框架，构建工具、 插件的作用 需要引用或者调用，就可以直接用，并不会对你做太多约束。那么这种大部分都称之为库。如jQuery 需要按照他的标准构建文件结构或者文件夹结构或者代码书写方式那么这东西可以称之为框架，一般框架都是多种组合在一起的，如React+gulp 或者 jQuery mobile 解决开发过程中重复或者需要自动化智能化完成事情，也就是构建工具，如grunt和gulp 基于 库，框架，工具，提供的补充优化的模块就叫做插件 关于工具 gulp是工具链、构建工具，可以配合各种插件做js压缩，css压缩，less编译 替代手工实现自动化工作 webpack是文件打包工具，可以把项目的各种js文、css文件等打包合并成一个或多个文件，主要用于模块化方案，预编译模块的方案 关于node一个让我笑半天的回答 node到底是什么？ 让Js也可以做后端 Node.js 通过用单线程取代多线程，事件驱动 I/O 来解决了高并发，取代了 Java 平台的标准]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[定义和声明的区别]]></title>
      <url>%2F2017%2F04%2F20%2F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[声明就是指给除了当前变量或者函数，或者类什么的名字，不给其中的内容，就是先告诉你有这样一个什么类型的变量或者函数，但是这个变量或者函数的具体信息却是不知道的。就好比跟你介绍一个人的时候，声明就是只告诉你这个人叫什么，但是缺不给你说这个人到底怎么样，他有哪些优点，缺点，喜好问题是什么的 定义就不一样了，定义直接告诉你了所有的东西，这个变量是什么，这个函数是什么功能，这个类里面包含了什么东西。很具体的说明 当然一般对于变量来说，我们不怎么区分声明或者定义之类的，一般没有人去说我要声明一个变量，然后定义这个变量什么的。要说都是直接说定义变量 声明一般都是对函数或者类来说的，声明在前，定义在后 int a;可以说是声明，广泛的说是定义一个变量a，也不算错 例子：123456789int a; //等价于 声明一个人：小张int a = 3; //等价于 定义一个人 ：小张 年龄为三岁。//定义是带有初始化的//函数的声明和定义void My(); // 这个是声明//这个是定义void My()&#123;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[挂载Hexo主题的Github绑定自己的域名]]></title>
      <url>%2F2017%2F04%2F19%2F%E6%8C%82%E8%BD%BDHexo%E4%B8%BB%E9%A2%98%E7%9A%84Github%E7%BB%91%E5%AE%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%2F</url>
      <content type="text"><![CDATA[用的Hexo的博客框架，本地生成并托管到github上之后，通过“username.github.io”便能访问自己的博客了，但是如何将url改成自己想要的域名，需要如下一些步骤。 到域名提供商那注册自己想要的域名，国内比较大的有阿里云、百度云等等、国外有godaddy、bluehost等，bluehost还支持支付宝，还不错，其实一个域名也不用纠结太多，毕竟域名不管在国内还是国外买的，只要服务器是国外的就不用走中国内地的备案套路，比如本篇文章讲的博客在github上就不用担心什么备案，不过要注意的是如果买的是.cn这种中国域名，就需要购买人提供身份证电子照片进行验证，政府部门通过后才能用。 到github的username.github.io目录下，创建新文件CNAME（一定要大写，而且不加任何后缀）,其中包含你注册的域名，注意要填的是顶级域名，比如roderic.cn 第二步是告诉github你要将该博客地址转到你CNAME文件中指定的域名。现在到你购买域名的服务商那为你购买的域名添加三条解析记录，如下： 前两条记录是指定该域名跳转的IP（github pages的，固定的，照抄，不用管）地址，第三条是指定该域名跳转到username.github.io（注意这里的username都得用你github的用户名替换） 这样经过短时间的等待，你就可以用你注册的域名访问你的博客了，当然此时用username。github.io也还是能访问博客的。 本例讲的是Hexo的博客框架，都知道Hexo每次都要重新生成静态文件再上传，这样每次CNAME都得重新创建很麻烦，解决方法是把CNAME文件放在source文件夹下，这样生成静态文件的时候，就会自动添加CNAME这个文件了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java入门（三）]]></title>
      <url>%2F2017%2F04%2F17%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[有关读取用户输入的问题首先导入包import java.util.Scanner;这里面有处理用户输入的方法。 输入数字情况123456789101112public static void main(String[] args) &#123; //创建输入对象 Scanner sc=new Scanner(System.in); //获取用户输入的数字 System.out.print("请输入任意数字:"); int str=sc.nextInt(); //用来获取数字 System.out.println("你输入的数字为:"+str); &#125; 输入字符串12345678910111213public static void main(String[] args) &#123; //创建输入对象 Scanner sc=new Scanner(System.in); //获取用户输入的字符串 String str=null; System.out.print("请输入任意字符:"); str=sc.nextLine(); //用来获取字符串 System.out.println("你输入的字符为:"+str); &#125; 若要输入字符数组思路：先用输入字符串的方法读入字符串，然后再将其转换为字符数组 注经过测试，一个输入对象只能接受一种数据类型，要想输入不同的数据对象，就得现创建不同的输入对象1234567Scanner in1=new Scanner(System.in); //接受数字输入int x1=in1.nextInt(); int x2=in1.nextInt(); //同种类型不必再new输入对象Scanner sc2=new Scanner(System.in); //接受字符串输入，不同类型得创新new输入对象，而且不同名String str=sc2.nextLine(); String str=sc2.nextLine();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java入门（二）]]></title>
      <url>%2F2017%2F04%2F15%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[注： 同一个包下，不同java文件中的类名不能相同，因为同一包下，不同java文件中的类是可以相互继承的！ 不同java类文件中的内部类（一个类中还包含着另外一个类）可以同名，但是同一文件下的public或者是默认范围的java类是不可以同名的。 当类中方法的访问权限修饰符为private时，该方法只能被自己的类访问，不能被外部的类访问 初始化时，若没有赋值则为默认值，具体时：数字为0、对象为null、布尔值为false、字符值为’\0’ 对象的引用 引用是一个地址，它指明了对象的变量和方法的存储位置 将对象赋给变量或将其作为参数传递给方法时，实际上并没有使用对象，甚至没有使用对象的拷贝，使用的是对象的引用 例子：123456789101112131415package Mypackage;import java.awt.Point;class RefTester&#123;public static void main(String[] args)&#123; Point pt1,pt2; pt1=new Point(100,100); pt2=pt1; pt1.x=200; pt1.y=200; System.out.println("Point1:"+pt1.x+","+pt1.y); System.out.println("Point2:"+pt2.x+","+pt2.y);&#125;&#125; 执行结果： 可以发现，pt2的值也被改变了，这是pt2=pt1是让pt2引用pt1，而不是将pt1的拷贝纸给pt2，pt1和pt2现在是指向同一个对象 如果改成：12pt1=new Point(100,100);pt2=new Point(100,100); 结果就将是： 注：(不想重写代码，假设pt1和pt2现在是String类型) 若pt2=pt1，此时用“==”来判断pt1和pt2是否相等，得到的结果是“true”,因为指向同一个对象，用“pt2.equals(pt1)”得到的结果也将是“true”，因为两个字符串值相同 若pt1=new Point(100,100);pt2=new Point(100,100);，此时用“==”来判断pt1和pt2是否相等，得到的结果是“false”,因为它们现在在内存中不是同一个对象，用“pt2.equals(pt1)”得到的结果也将是“true”，因为两个字符串值相同 方法重写与方法重载方法重写 子类可以定义新的特征，当子类需要修改父类的一些方法进行扩展，增大功能，程序设计者常常把这样的一种操作方法称为重写，也叫称为覆写或覆盖，重写是建立在继承关系上 所谓方法的重写是指子类中的方法与父类中继承的方法有完全相同的返回值类型、方法名、参数个数以及参数类型。这样，就可以实现对父类方法的覆盖 例子： 1234567891011121314151617class Person//定义父类&#123;public void print()&#123;//父类中的方法System.out.println( 父类Person的print方法! );&#125;&#125;class Student extends Person//定义子类继承Person类&#123;public void print()&#123;//方法的重写System.out.println( 子类Student的print方法! );&#125;&#125;public class 0verrideExampleO1&#123;public static void main(String args[])&#123;Student s=new Student();S.print();&#125;&#125; 运行结果：子类Student的print方法! 可见当子类重写了父类中的print()方法后，使用S调用的是子类的print()方法，如果一定要调用父类中的方法，可以用super关键字，super关键字可以从子类访问父类中的内容，如果要访问被重写过的方法，使用“super.方法名(参数列表)”的形式调用 例子： 1234567891011121314151617class Person2&#123;public void print () &#123;System.out.println( "父类Person的print方法! ");&#125;&#125;class Student2 extends Person2&#123;public void print () &#123;super.print();//访问父类中被子类覆写过的方法System.out.println(" 子类Student的print方法!" );&#125;&#125;public class OverrideExample02&#123;public static void main(String args[])&#123;Student2 s=new Student2();s.print();&#125;&#125; 运行结果： 被子类重写的方法不能拥有比父类方法更加严格的访问权限 当父类中方法的访问权限修饰符为private时，该方法只能被自己的类访问，不能被外部的类访问，在子类是不能被重写的。如果定义父类的方法为public，在子类定义为private，程序运行时就会报错 在继承过程中如果父类当中的方法抛出异常，那么在子类中重写父类的该方法时，也要抛出异常，而且抛出的异常不能多于父类中抛出的异常(可以等于父类中抛出的异常)。换句话说，重写方法一定不能抛出新的检查异常，或者比被重写方法声明更加宽泛的检查型异常。例如，父类的一个方法申明了一个检查异常IOException，在重写这个方法时就不能抛出Exception，只能抛出IOException的子类异常，可以抛出非检查异常 方法重载 方法重载是让类以统一的方式处理不同类型数据的一种手段。调用方法时通过传递给它们的不同个数和类型的参数来决定具体使用哪个方法，这就是多态性 所谓方法重载是指在一个类中，多个方法的方法名相同，但是参数列表不同，参数列表不同指的是参数个数、参数类型或者参数的顺序不同 不仅是一般的方法，构造方法也可以重载 例子： 1234567891011121314151617181920212223242526 Class Person &#123;&#123;String name; int age;void print()&#123; System.out.println("姓名：" +name+"年龄：" +age); &#125;void print(String a，int b)&#123; System.out.println("姓名：" +a+"年龄："+b); void print(String a，int b，intC)&#123; System.out.println("姓名："+a+"年龄：" +b+"ID号：" +c); &#125;void print(String a，int b，doubleC)&#123; System.out.println("姓名："+a+"年龄：" +b+"ID号："+c); &#125; &#125;public class OverLoadExampleOL &#123;public static void main(String[] args) &#123;Personpl=new Person();p1.name="李明";p1.age=22;p1.print(); p1.print("王小早",19); p1.print("金波",18,100325); p1.print("婉宁",25,110903); &#125; &#125; 在上面的程序中，可以看到Person类中有多个名为 void print的方法，这就是方法的重载。执行程序，运行结果如下： 每个重载方法可以有不同的返回类型,只要参数列表不同就可以了 可以有不同的访问修饰符 可以抛出不同的异常 总结 在面向对象程序设计的思想中，类的继承和多态性主要就是体现在子类重写父类的方法。而构造方法的重载作为方法重载的一个典型特例，可以通过重载构造方法来表达对象的多种初始化行为。灵活的运用方法重写与方法重载，不仅能减少编码的工作量，也能大大提高程序的可维护性及可扩展性 参考文章链接 注意以下这个方法重载的例子，实例方法可以用类名来作为返回类型创建！！ 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.awt.Point;//该类定义了一个矩形class Box &#123; int x1 = 0; int y1 = 0; int x2 = 0; int y2 = 0; Box buildBox(int x1, int y1, int x2, int y2) &#123; this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2; return this; &#125; Box buildBox(Point topLeft, Point bottomRight) &#123; x1 = topLeft.x; y1 = topLeft.y; x2 = bottomRight.x; y2 = bottomRight.y; return this; &#125; Box buildBox(Point topLeft, int w, int h) &#123; x1 = topLeft.x; y1 = topLeft.y; x2 = (x1 + w); y2 = (y1 + h); return this; &#125; void printBox()&#123; System.out.print("Box: &lt;" + x1 + ", " + y1); System.out.println(", " + x2 + ", " + y2 + "&gt;"); &#125; public static void main(String[] arguments) &#123; Box rect = new Box(); System.out.println("Calling buildBox with " + "coordinates (25,25) and (50,50):"); rect.buildBox(25, 25, 50, 50); rect.printBox(); System.out.println("\nCalling buildBox with " + "points (10,10) and (20,20):"); rect.buildBox(new Point(10, 10), new Point(20, 20)); rect.printBox(); System.out.println("\nCalling buildBox with " + "point (10,10), width 50 and height 50:"); rect.buildBox(new Point(10, 10), 50, 50); rect.printBox(); &#125;&#125; 结果为：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java入门（一）]]></title>
      <url>%2F2017%2F04%2F15%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Java作为一种面向对象语言。支持以下基本概念： 多态 继承 封装 抽象 类 对象 实例 方法 重载 成员变量包括：实例变量、类变量 成员方法包括：实例方法、类方法、构造方法 基本数据类型包括：byte、short、int、long、float、double、boolean、char 指针问题：不能说Java没有指针，它只是没有显示指针。对象引用实际上就是指针 Java中工程（项目）、包、类区别 项目就是project，包就是package，而class就是类了，项目里面包括所有的包，包是用来便于管理类，防止命名冲突，类是代码的容器，它们的关系就是上级与下级的关系，项目的下一级就是包，包的下级就是类 工程相当于一个软件，包相当于模块，类相当于模块下各个功能的实现 类下再有各种自己具体完成任务需要的成员变量和实现方法。主方法也在某一个public类中 包(package)相当于姓名中的“姓”，类(class)相当于“名”。所以在调用某类方法的时候，不仅需要指明方法所在的“名”，即类，还要指明方法类所在的“姓”，即类。这样编译器才知道你调用的方法是哪一个。 包类具体使用： 注意： 类名和文件名相同，一个Java文件中最好仅定义一个类，多类不方便管理。 如果多类定义，则仅有一个类可以被public修饰，这个类且必须和文件同名，其他类则不能被其他包里类所引用。此外，若存在主方法main函数，public的main方法只能存放在这个public类当中。 由于main方法是静态的，所以不可以直接调用类中非静态成员变量或方法。但是可以在main函数中创建实体（对象）再调用方法和变量。(即用new) 包建议小写字母开头，而类以大写字母开头。 问题 包用来解决什么问题？ 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类 java.awt.*是什么 java.awt包，即java抽象窗口工具包（Abstract Window Toolkit,AWT)提供了许多用来设计GUI（Graphics User Interface,图形用户界面）组件类。 友好变量、友好方法、友好类 友好变量、友好方法 所谓友好即 不被public、protected、private关键修饰的变量和方法区别在于 比public低一级，用于只能在同一包下访问的变量 Java一共有四种权限，private (私有)，public（公有）。Protected（受保护）还有友好型。这些语句都可以修饰类中的成员变量和方法，但是只有public和友好型可以修饰类。 类、实例、对象区别 类是对一项事物的抽象概括，是一个模板，可以包含该事物的一些属性定义，以及操作属性的方法 实例简单理解，就是new，就是对类的实例化，创建这个类对应的实际对象，类只是对事物的描述，而实例化就相当于为这个描述新开辟了一块内存，可以改变这块区域里的各种属性（成员变量），当然，也可以实例化多块区域，只是不同的对象而已。 类跟对象 可以这么说，对象就是实例，new的过程就是对象实例化的过程 例：1234567891011121314//ps就是对象的一个**引用**，要对这个对象进行操作的时候，就可以通过这个引用public class Peason &#123; String name; String sex; int age; public static void main(String [] args) &#123; Peason ps=new Peason(); ps.name=”张三”; ps.sex=”男”; ps.age=10; &#125; &#125; 构造方法（即构造函数） 是一种特殊的方法，它是一个与类同名且没有返回值类型的方法 对象的创建就是通过构造方法来完成，其功能主要是完成对象的初始化 满足如下语法规则： 方法名与类名相同 不要声明返回类型 不能被static、final、synchronized、abstract和native修饰。构造方法不能被子类继承，所以用final和abstract修饰没有意义 不能使用return语句来返回一个值 例子：一个类可以有多个构造方法！ 12345678910111213141516//以下Sample类中，具有int返回类型的Sample(int x)方法只是个普通的实例方法，不能作为构造方法public class Sample &#123;private int x; public Sample() &#123; // 不带参数的构造方法 this(1); &#125; public Sample(int x) &#123; //带参数的构造方法 this.x=x; &#125; public int Sample(int x) &#123; //不是构造方法 return x++; &#125; &#125; 如果构造函数的部分行为与已有的构造函数相同，可以在该构造函数中调用已有的构造函数。 例子： 123456789101112131415//第二个构造函数只接受x和y的坐标作为参数，由于没有定义半径，//因此使用默认值1——调用第一个构造函数，并将xPoint、yPoint、1作为参数传递给它 class Circle&#123; int x,y,radius; Circle(int xPoint,int yPoint,int rediusLength)&#123; this.x=xPoint; this.y=yPoint; this.radius=rediusLength; &#125; Circle(int xPoint,int yPoint)&#123; this(xPoint,yPoint,1); &#125;&#125; 注意： 构造方法可以重载，以参数的数目，类型，顺序 如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造器，这个构造器不执行任何代码。 构造方法不能被继承： 子类只继承父类的默认(缺省)构造函数（即无形参构造函数），如果父类没有默认构造函数，那子类不能从父类继承默认构造函数。 子类从父类处继承来的父类默认构造函数，不能成为子类的默认构造函数。 在创建对象时，先调用父类默认构造函数对对象进行初始化，然后调用子类自身自己定义的构造函数。 如果子类想调用父类的非默认构造函数，则必须使用super来实现 内存管理不同于其他面向对象语言，Java在内存管理是动态的、自动的，当你创建对象时，Java自动分配相应的内存，当使用完对象后，Java虚拟机自动查找未用的对象并回收这些对象占用的内存 权限问题 Java类的访问控制 Java中不同控制符对应的权限java中的访问修饰符讲解 实例变量与类变量的区别，实例方法和类方法的区别详细链接一详细链接二 类变量：静态域，静态字段，或叫静态变量，它属于该类所有实例共有的属性，在内存中只有一个地方存储这个变量 类变量、类方法就是类中的变量、方法，必须是静态的，要加static；故其又称静态变量、静态方法。 实例变量：实例域，实例字段，或叫成员变量。 实例方法：或叫成员方法，必须先有实例，然后才能通过实例调用该实例方法 类变量和实例变量都必须在方法和语句块之外，区别在于类变量static而实例变量不是，类方法和实例方法的区别也是在有没有static上 类方法是属于整个类，而不属于某个对象 类方法的调用可以通过类名.类方法和对象.类方法，而实例方法只能通过对象.实例方法访问 类方法只能访问类方法，而实例方法可以访问类方法和实例方法。 类方法不能被覆盖，实例方法可以被覆盖（待验证） 每个实例都将有一个实例变量的一个副本，他们可以修改实例变量的值，而不会影响其他的示例；类变量只有一个副本，修改它的值将影响所有的实例 类方法与类变量一样，适用于整个类，而不是某个实例。类方法通常用作通用的工具方法，然不是直接操作某个对象，而是整个类。 类方法还可以用来将通用的方法集中起来，放在一个地方（即类中）。例如：在java.lang包中定义的类Math,将大量的数学运算作为类方法。不能创建Math对象，但可以只用它的类方法，并将数字和布尔值作为参数 使用方法： 类方法可以直接调用类变量和类方法 类方法不可以直接调用实例变量和实例方法 类方法中没有this，因为没有实例，this不知道调用哪个实例(只能在实力方法的定义体内使用this)，super也不行 类方法可以从类里面直接访问类成员 实例方法可以调用类方法，访问类变量，但是不提倡这样做，会把类方法和类变量混淆成实例方法和实例变量 例子： 12345678910111213141516171819202122232425262728293031 package Mypackage; class AnIntegerNamedX &#123; static int x; // 这里写成static，结果就变成全是2了，因为类变量是被实例所共享的， //包括myX和anotherX调用anotherX时所有的实例都改变了。 public int x() &#123; return x; &#125; public void setX(int newX) &#123; x = newX; &#125;&#125;public class Practice &#123;public static void main(String args[]) &#123; AnIntegerNamedX myX = new AnIntegerNamedX(); AnIntegerNamedX anotherX = new AnIntegerNamedX(); myX.setX(1); anotherX.x = 2; // 这里把X的值改成2，所有实例的X都是2了，因为类变量是被 //所有实例共享的，任何实例都可以对类变量做最终的修改 System.out.println("myX.x = " + myX.x()); System.out.println("anotherX.x = " + anotherX.x());&#125;&#125; 结果为： 若将static int x;改成int x;，则结果为： 若将static int x;改成int x;，将x()方法和setX()加上static变成静态方法，则会提示错误让把X变成静态，是因为类方法不能直接访问实例变量！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用例图学习笔记]]></title>
      <url>%2F2017%2F04%2F15%2F%E7%94%A8%E4%BE%8B%E5%9B%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[基本概念 主要用来图示化系统的主事件流程 用例就是软件的功能模块，是设计系统分析阶段的起点 描述软件应该具备哪些功能模块以及这些模块之间的调用关系 用例图包含“用例”和“参与者” 用例之间通过关联来连接，以便把系统的整个结构和功能反映给客户 对应的是软件的结构和功能分解 用例之间可以抽象出：包含、扩展、泛化关系。（最常见是：关联） 图示 关联 包含 扩展 泛化 示例 包含 扩展 泛化 具体讲解请戳 组成：系统、用例、参与者、关系 解释 被包含的用例可以单独执行 一个用例被定义为基础用例的增量扩展，称作为扩展关系，在特定的条件发生时，扩展用例才会被执行 泛化关系中，父用例往往表现为抽象用例，任何父用例出现的地方，子用例也可出现 简单说： 泛化侧重子用例之间的互斥性； 包含侧重被包含用例对参与者提供服务的间接性； 扩展侧重扩展用例的出发不确定性。 参与者种类： 系统用户 与所建造的系统交互的其他系统 一些可以运行的进程 用例图建模技术分为：对语境建模、对需求建模 对语境建模 对需求建模 实现步骤 确定系统涉及的总体信息 确定系统的参与者 确定系统的用例 绘制系统的用例图 例子 绘制步骤 添加参与者与用例 添加参与者与用例之间的关系 添加用例之间的关系]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NexT主题配置进阶]]></title>
      <url>%2F2017%2F04%2F15%2FNexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%BF%9B%E9%98%B6%2F</url>
      <content type="text"><![CDATA[主题配置包括： 设置「RSS」 添加「标签」页面 如何为文章添加标签或者分类 添加「分类」页面 设置「字体」 设置「代码高亮主题」 侧边栏社交链接 开启打赏功能 设置友情链接 腾讯公益404页面 站点建立时间 订阅微信公众号 设置「动画效果」 设置「背景动画」 第三方服务包括： 评论系统 数据统计与分析 内容分享服务 搜索服务 其他服务 稍微写一下基本操作：标签 新建标签页面：（这样标签合辑的页面被制作出来） 编辑刚刚新建的页面，将其页面类型设置为tags（这样主题将知道这是一个标签页面，并为这个页面显示标签云） 编辑主题配置文件，添加tags到menu目录中 之后在新建的文章中就可以通过设置文章中的开始的声明来为文章添加标签了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo安装及默认主题配置]]></title>
      <url>%2F2017%2F04%2F15%2FHexo%E5%AE%89%E8%A3%85%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[#安装Hexo 想重建博客，又不想花时间从头设计实现网站，就开始找有什么方法能快速实现页面布局和设计，最开始用了wordpress平台，后来又看到大佬推荐Hexo,就看了看。 PS:Hexo依赖于Node,所以电脑得有Node.js环境，然后就可以用Node中强大的npm命令来安装各种东西，当然包括Hexo。Node和Git的安装教程自己百度。 Hexo安装教程 hexo入门指南 yilia主题 Next主题 yelee主题 另外还找到jekyll直接托管在github上，好像挺牛逼的，有时间再折腾吧准备自己建一个个人博客，有什么好的框架推荐？ 我的安装过程 在git bash内使用npm install hexo -g安装，直接在根目录下装的 然后在想要创建博客的地方使用hexo init blog命令创建blog文件夹（不只是文件夹，整个默认的hexo博客主题等都将从github上下到该文件夹下） 完成后，在blog文件夹内，hexo generate生成静态页面，生成的静态页面存储在public文件夹下，只要有一个web server就可以独立运行网站了 hexo server启动本地服务，浏览器输入http://localhost:4000/即可访问刚刚创建的博客了 如果不行，说明端口被占用，用hexo s -p 5000重新开启本地服务，然后http://localhost:5000/即可访问创建的页面 就是这么简单，主要都是细节问题，对于刚入门的同道，需要知道的是，以上命令都在git bash里面执行就可以，因为cmd有的功能bash基本上都有，Node博主当时是默认安装在C盘，用npm install npm -g升级了下Node自带的npm，然后直接在根目录（刚打开git bash时的目录）执行的npm install hexo -g安装hexo，在其他目录安装的话，用全局安装应该也可以，不过我没折腾过。 部署到github部署到github 修改blog目录下的_config.yml文件如下：title为网站主标题，subtitle为副标题，都是顾名思义的，language和timezone要注意书写格式，还有，每个“：”之后要记得加上空格 更改完_config.yml之后，输入npm install hexo-deployer-git --save（不知道是不是必须的，可能是怕没有安装deploy，怕在后面发布到github的时候出错） 在终端输入hexo new &quot;文章标题&quot;来新建文章，也可以在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件。 可能会出现发布后中文乱码的问题，只要把相应的.md文件保存成UTF-8格式就行了。比如用txt打开，然后另存为UTF-8格式。 然后进行本地发布：$ hexo server 此时浏览器输入http://localhost:4000/可以看到我们搭建好的博客和发布的文章 目前只能在本机看到 接下来用 $ hexo generate//生成静态页面 $ hexo deploy//发布到更改_config.yml时指定的githubc仓库上 这样使用github的仓库地址例如本例的http://inerdstack.github.io就可以访问我们的博客了 部署步骤每次部署的步骤，可按以下三步来进行。 hexo clean hexo generate hexo deploy 一些常用命令： hexo new”postName” #新建文章 hexo new page”pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo的hexo deploy无法使用]]></title>
      <url>%2F2017%2F04%2F15%2FHexo%E7%9A%84hexo-deploy%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[具体情况是，在hexo generate生成静态页面后，用hexo deploy命令想发布到github上，却出现了问题，报错如下： 即提示找不到用户名，这应该是ssh配置的问题，索性就没用ssh传输，直接在博客文件夹下用 $ git init $ git remote add origin https://github.com/{USER_NAME}/{REPOSITORY_NAME}.git 然后再执行hexo deploy就成功了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-NexT主题]]></title>
      <url>%2F2017%2F04%2F15%2FHexo-NexT%E4%B8%BB%E9%A2%98%2F</url>
      <content type="text"><![CDATA[看来很多Hexo主题，最后还是想用NexT主题的Mist版本，简直不能再棒。不愧是最受欢迎的Hexo主题。 官网讲得已经很好了 我稍微再说一下。 能想到用NexT的肯定对Hexo、Node、Git、Github有了解了，我就不再过多描述了。 步骤 在终端窗口（比如：git bash），定位到Hexo的博客目录下，输入以下命令： $ cd your-hexo-site //比如我的博客目录是blog,就写blog $git clone https://github.com/iissnan/hexo-theme-next themes/next 完成后，更改站点配置文件，即blog目录下的_config.yml,找到theme字段，将其值置为next 这样其实就已经完成了 在终端输入$ hexo server通过相应端口访问就可以验证主题是否设置成功了 选择样式 Next有3种样式默认的是Muse，另外还有Mist和Pisces，可以通过更改主题的配置文件来选择样式，主题配置文件路径为\themes\next_config.yml 搜索scheme关键字，找到三行scheme的配置，将要启用的样式前的“#”去掉，不用的样式前加上“#”即可 另外主题语言、菜单、头像等的相关设置可以参见官网，讲得通俗易懂，已经很容易理解了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node安装]]></title>
      <url>%2F2017%2F04%2F15%2FNode%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[之前就久仰Node.js大名，最近想弄个Hexo+github的博客，需要Node支持，所以开始接触这个方面的内容。 这个链接介绍了Node安装和通过Node创建简单的服务器：我们安装了Nodejs是安装了什么 Node安装完后，安装目录下会多出几个文件，其中： Node_modules（Nodejs的模块都在这里，默认有一个Npm包管理模块） Node.exe（nodejs的核心解析器） 网上对Node.js的说法 Node 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”。 node.js…它既是开发平台, 也是运行环境, 也是个新的语言…它本身是基于google的javascript v8引擎开发的 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，使得Javascript也具备了写“服务器端”的能力。 支持多用户的高并发是其优势之一 它的出现能够让前端工程师更好的理解后端服务器运作原理，搭建一个功能全面的web应用。学习nodejs对于了解http、tcp协议是很好的。 什么是npm经常看到一些npm开头的命令，所以搜了一下 npm 是 nodejs 的包管理和分发工具。它可以让 javascript 开发者能够更加轻松的共享代码和共用代码片段，并且通过 npm 管理你分享的代码也很方便快捷和简单。 安装完 nodejs 就已经有了npm, 不过由于 nodejs 更新速度要慢于npm ，因此在一般情况下要升级你的 npm 到最新版本，输入如下命令： npm install npm -g 我的安装步骤： 到官网下载node.js 然后直接默认安装 听说自带的npm版本会比较低，所以就用npm install npm -g命令升级了一下 命令操作都是在cmd里面进行的，在git bash里面好像也行，难道这俩是互通的？？？ 查了下，确实是相通的，git bash和windows里的cmd功能差不多，只不过git bash里加了几个实用的linux命令以及git自己的命令]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WampServer 3.0环境配置问题]]></title>
      <url>%2F2017%2F04%2F15%2FWampServer%203.0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[在网上直接搜“WampServer 3.0”配置，不要只搜“WampServer配置”，因为这样收到的很多都是旧版本的教程，新版本的配置方法略有差别 配置包括： Apache根目录的改变 Wamp根目录的改变（此版本还要更改虚拟主机配置文件中的虚拟主机根目录才能奏效），具体的看教程 还有一个问题是：“wampserver 主页里点击“Your Projects”下面项目名，显示错误的问题。”解决这个问题需要更改Wamp根目录下的index.php文件中的路径代码，具体方法如下： 进入index.php文件，（wamp 3.0.6是在第445行），搜索$projectContents(这是YourProjects文件内容的相关变量)，在搜索结果里，找到一行代码中以$projectContents.=&#39;http://&#39;.$UrlPort.&#39;开头的，改成$projectContents .= &#39;http://localhost&#39;.$UrlPort.&#39;/&#39;.$file.&#39;/&quot;&#39;;如图： 这样子就可以了。 如何让Wampserver允许局域网甚至是外网访问？看这里]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[php环境问题]]></title>
      <url>%2F2017%2F04%2F15%2Fphp%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[用的是phpstorm和wamp搭建的环境，php版本为5.6 提交表单后，运行老是报错“Deprecated: Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version. To avoid this warning set ‘always_populate_raw_post_data’ to ‘-1’ in php.ini and use the php://input stream instead. in Unknown on line 0” 我运行是直接点的phpstorm里面的chrome快捷键，结果出现上面的错误，网上的方法试了，更改php.ini文件的always_populate_raw_post_data的值无效。 后来发现，从phpstorm直接运行的页面地址跟wamp根目录运行的页面地址是不一样的（废话，肯定不一样，因为我phpstorm的项目地址跟wamp的不在一起），而且很奇怪的一点，wamp提供的更改php.ini的地址不是php安装目录里的那个php.ini。搞得我有点晕。 后来索性把要运行的那个项目移动到wamp根目录，用localhost（wamp根地址）运行，结果就成功了，成功了，没错，不报错了，就是这么简单，具体为什么等我把这项目弄完了再好好研究吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Html常用标签大全]]></title>
      <url>%2F2017%2F04%2F14%2FHtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[基本&lt;html&gt;…&lt;/html&gt; 定义 HTML 文档 &lt;head&gt;…&lt;/head&gt; 文档的信息 &lt;meta&gt; HTML 文档的元信息 &lt;title&gt;…&lt;/title&gt; 文档的标题 &lt;link&gt; 文档与外部资源的关系 &lt;style&gt;…&lt;/style&gt; 文档的样式信息 &lt;body&gt;…&lt;/body&gt; 可见的页面内容、 &lt;!--…--&gt; 注释 文本&lt;h1&gt;...&lt;/h1&gt; 标题字大小（h1~h6） &lt;b&gt;...&lt;/b&gt; 粗体字 &lt;strong&gt;...&lt;/strong&gt; 粗体字(强调) &lt;i&gt;...&lt;/i&gt; 斜体字 &lt;em&gt;...&lt;/em&gt; 斜体字(强调) &lt;u&gt;...&lt;/u&gt; 下划线 &lt;del&gt;...&lt;/del&gt; 删除线(表示删除) &lt;center&gt;…&lt;/center&gt; 居中文本 &lt;ul&gt;…&lt;/ul&gt; 无序列表 &lt;ol&gt;…&lt;/ol&gt; 有序列表 &lt;li&gt;…&lt;/li&gt; 列表项目 &lt;a href=”…”&gt;…&lt;/a&gt; 超链接 &lt;font&gt; 定义文本字体尺寸、颜色、大小 &lt;sub&gt; 下标 &lt;sup&gt; 上标 &lt;br&gt; 换行 &lt;p&gt; 段落 图形&lt;img src=’”…”&gt; 定义图像 &lt;hr&gt; 水平线 表格&lt;table&gt;…&lt;/table&gt; 定义表格 &lt;th&gt;…&lt;/th&gt; 定义表格中的表头单元格 &lt;tr&gt;…&lt;/tr&gt; 定义表格中的行 &lt;td&gt;…&lt;/td&gt; 定义表格中的单元 其它&lt;form&gt;…&lt;/form&gt; 定义供用户输入的 HTML 表单 &lt;frame&gt; 定义框架集的窗口或框架 另加16进制颜色，但仅仅有16种颜色名可用英文字母，其余的要用16进制值。 记住哦！ aqua, black, blue, fuchsia, gray, green, lime,maroon, navy, olive, purple, red, silver, teal, white, yellow]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git上传github仓库步骤]]></title>
      <url>%2F2017%2F04%2F07%2FGit%E4%B8%8A%E4%BC%A0github%E4%BB%93%E5%BA%93%E6%AD%A5%E9%AA%A4%2F</url>
      <content type="text"><![CDATA[完整的Git的教程请看这里 这个教程是基于电脑上已经装有git和拥有github账号的基础上的。（没装git的可以去git官网下载，本文以windows64位系统为基础） 在git bash内输入以下命令在配置文件中保存身份： git config −−global user.name “github账号” git config −−global user.email “注册github时用的邮箱” 比如你要上传的本地仓库是在桌面的test文件夹内的所有文件：用命令行进入到test文件夹下（本例是上传test内的test.txt文件），涉及相关文件操作命令同linux。 在github中创建新仓库test: 在bash内，输入git init进行初始化： 将所有文件添加到上传队列中(“.”表示全部文件，可以用特定文件名来代替，进行特定文件上传；中间可以用git status 命令来查看文件所在所处的状态)：git add . 提交文件到本地git仓库：git commit −m “注释” 连接github中的test仓库：git remote add origin https://github.com/zifenggao/test.git（此段代码可以到创建成功后的github test仓库的code栏内复制得到） 然后输入git push origin master命令即可完成本地git仓库上传到github仓库的操作： 这样就完成了本地git上传到github仓库的操作，到github中刷新test仓库可以查看到我们上传的内容：]]></content>
    </entry>

    
  
  
</search>
